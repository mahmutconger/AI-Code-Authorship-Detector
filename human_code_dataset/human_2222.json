{
    "code": "class Config:\n    default_config: ClassVar[dict[str, Any]] = {\n        \"cache-dir\": str(DEFAULT_CACHE_DIR),\n        \"data-dir\": str(data_dir()),\n        \"virtualenvs\": {\n            \"create\": True,\n            \"in-project\": None,\n            \"path\": os.path.join(\"{cache-dir}\", \"virtualenvs\"),\n            \"options\": {\n                \"always-copy\": False,\n                \"system-site-packages\": False,\n                \"no-pip\": False,\n            },\n            \"use-poetry-python\": False,\n            \"prompt\": \"{project_name}-py{python_version}\",\n        },\n        \"requests\": {\n            \"max-retries\": 0,\n        },\n        \"installer\": {\n            \"re-resolve\": True,\n            \"parallel\": True,\n            \"max-workers\": None,\n            \"no-binary\": None,\n            \"only-binary\": None,\n            \"build-config-settings\": {},\n        },\n        \"python\": {\"installation-dir\": os.path.join(\"{data-dir}\", \"python\")},\n        \"solver\": {\n            \"lazy-wheel\": True,\n        },\n        \"system-git-client\": False,\n        \"keyring\": {\n            \"enabled\": True,\n        },\n    }\n\n    def __init__(self, use_environment: bool = True) -> None:\n        self._config = deepcopy(self.default_config)\n        self._use_environment = use_environment\n        self._config_source: ConfigSource = DictConfigSource()\n        self._auth_config_source: ConfigSource = DictConfigSource()\n\n    @property\n    def config(self) -> dict[str, Any]:\n        return self._config\n\n    @property\n    def config_source(self) -> ConfigSource:\n        return self._config_source\n\n    @property\n    def auth_config_source(self) -> ConfigSource:\n        return self._auth_config_source\n\n    def set_config_source(self, config_source: ConfigSource) -> Config:\n        self._config_source = config_source\n\n        return self\n\n    def set_auth_config_source(self, config_source: ConfigSource) -> Config:\n        self._auth_config_source = config_source\n\n        return self\n\n    def merge(self, config: dict[str, Any]) -> None:\n        from poetry.utils.helpers import merge_dicts\n\n        merge_dicts(self._config, config)\n\n    def all(self) -> dict[str, Any]:\n        def _all(config: dict[str, Any], parent_key: str = \"\") -> dict[str, Any]:\n            all_ = {}\n\n            for key in config:\n                value = self.get(parent_key + key)\n                if isinstance(value, dict):\n                    if parent_key != \"\":\n                        current_parent = parent_key + key + \".\"\n                    else:\n                        current_parent = key + \".\"\n                    all_[key] = _all(config[key], parent_key=current_parent)\n                    continue\n\n                all_[key] = value\n\n            return all_\n\n        return _all(self.config)\n\n    def raw(self) -> dict[str, Any]:\n        return self._config\n\n    @staticmethod\n    def _get_environment_repositories() -> dict[str, dict[str, str]]:\n        repositories = {}\n        pattern = re.compile(r\"POETRY_REPOSITORIES_(?P<name>[A-Z_]+)_URL\")\n\n        for env_key in os.environ:\n            match = pattern.match(env_key)\n            if match:\n                repositories[match.group(\"name\").lower().replace(\"_\", \"-\")] = {\n                    \"url\": os.environ[env_key]\n                }\n\n        return repositories\n\n    @staticmethod\n    def _get_environment_build_config_settings() -> Mapping[\n        NormalizedName, Mapping[str, str | Sequence[str]]\n    ]:\n        build_config_settings = {}\n        pattern = re.compile(r\"POETRY_INSTALLER_BUILD_CONFIG_SETTINGS_(?P<name>[^.]+)\")\n\n        for env_key in os.environ:\n            if match := pattern.match(env_key):\n                if not build_config_setting_validator(os.environ[env_key]):\n                    logger.debug(\n                        \"Invalid value set for environment variable %s\", env_key\n                    )\n                    continue\n                build_config_settings[canonicalize_name(match.group(\"name\"))] = (\n                    build_config_setting_normalizer(os.environ[env_key])\n                )\n\n        return build_config_settings\n\n    @property\n    def repository_cache_directory(self) -> Path:\n        return Path(self.get(\"cache-dir\")).expanduser() / \"cache\" / \"repositories\"\n\n    @property\n    def artifacts_cache_directory(self) -> Path:\n        return Path(self.get(\"cache-dir\")).expanduser() / \"artifacts\"\n\n    @property\n    def virtualenvs_path(self) -> Path:\n        path = self.get(\"virtualenvs.path\")\n        if path is None:\n            path = Path(self.get(\"cache-dir\")) / \"virtualenvs\"\n        return Path(path).expanduser()\n\n    @property\n    def python_installation_dir(self) -> Path:\n        path = self.get(\"python.installation-dir\")\n        if path is None:\n            path = Path(self.get(\"data-dir\")) / \"python\"\n        return Path(path).expanduser()\n\n    @property\n    def installer_max_workers(self) -> int:\n        # This should be directly handled by ThreadPoolExecutor\n        # however, on some systems the number of CPUs cannot be determined\n        # (it raises a NotImplementedError), so, in this case, we assume\n        # that the system only has one CPU.\n        try:\n            default_max_workers = (os.cpu_count() or 1) + 4\n        except NotImplementedError:\n            default_max_workers = 5\n\n        desired_max_workers = self.get(\"installer.max-workers\")\n        if desired_max_workers is None:\n            return default_max_workers\n        return min(default_max_workers, int(desired_max_workers))\n\n    def get(self, setting_name: str, default: Any = None) -> Any:\n        \"\"\"\n        Retrieve a setting value.\n        \"\"\"\n        keys = setting_name.split(\".\")\n        build_config_settings: Mapping[\n            NormalizedName, Mapping[str, str | Sequence[str]]\n        ] = {}\n\n        # Looking in the environment if the setting\n        # is set via a POETRY_* environment variable\n        if self._use_environment:\n            if setting_name == \"repositories\":\n                # repositories setting is special for now\n                repositories = self._get_environment_repositories()\n                if repositories:\n                    return repositories\n\n            build_config_settings_key = \"installer.build-config-settings\"\n            if setting_name == build_config_settings_key or setting_name.startswith(\n                f\"{build_config_settings_key}.\"\n            ):\n                build_config_settings = self._get_environment_build_config_settings()\n            else:\n                env = \"POETRY_\" + \"_\".join(k.upper().replace(\"-\", \"_\") for k in keys)\n                env_value = os.getenv(env)\n                if env_value is not None:\n                    return self.process(self._get_normalizer(setting_name)(env_value))\n\n        value = self._config\n\n        # merge installer build config settings from the environment\n        for package_name in build_config_settings:\n            value[\"installer\"][\"build-config-settings\"][package_name] = (\n                build_config_settings[package_name]\n            )\n\n        for key in keys:\n            if key not in value:\n                return self.process(default)\n\n            value = value[key]\n\n        if self._use_environment and isinstance(value, dict):\n            # this is a configuration table, it is likely that we missed env vars\n            # in order to capture them recurse, eg: virtualenvs.options\n            return {k: self.get(f\"{setting_name}.{k}\") for k in value}\n\n        return self.process(value)\n\n    def process(self, value: Any) -> Any:\n        if not isinstance(value, str):\n            return value\n\n        def resolve_from_config(match: re.Match[str]) -> Any:\n            key = match.group(1)\n            config_value = self.get(key)\n            if config_value:\n                return config_value\n\n            # The key doesn't exist in the config but might be resolved later,\n            # so we keep it as a format variable.\n            return f\"{{{key}}}\"\n\n        return re.sub(r\"{(.+?)}\", resolve_from_config, value)\n\n    @staticmethod\n    def _get_normalizer(name: str) -> Callable[[str], Any]:\n        if name in {\n            \"virtualenvs.create\",\n            \"virtualenvs.in-project\",\n            \"virtualenvs.options.always-copy\",\n            \"virtualenvs.options.no-pip\",\n            \"virtualenvs.options.system-site-packages\",\n            \"virtualenvs.use-poetry-python\",\n            \"installer.re-resolve\",\n            \"installer.parallel\",\n            \"solver.lazy-wheel\",\n            \"system-git-client\",\n            \"keyring.enabled\",\n        }:\n            return boolean_normalizer\n\n        if name == \"virtualenvs.path\":\n            return lambda val: str(Path(val))\n\n        if name in {\n            \"installer.max-workers\",\n            \"requests.max-retries\",\n        }:\n            return int_normalizer\n\n        if name in [\"installer.no-binary\", \"installer.only-binary\"]:\n            return PackageFilterPolicy.normalize\n\n        if name.startswith(\"installer.build-config-settings.\"):\n            return build_config_setting_normalizer\n\n        return lambda val: val\n\n    @classmethod\n    def create(cls, reload: bool = False) -> Config:\n        global _default_config\n\n        if _default_config is None or reload:\n            _default_config = cls()\n\n            # Load global config\n            config_file = TOMLFile(CONFIG_DIR / \"config.toml\")\n            if config_file.exists():\n                logger.debug(\"Loading configuration file %s\", config_file.path)\n                _default_config.merge(config_file.read())\n\n            _default_config.set_config_source(FileConfigSource(config_file))\n\n            # Load global auth config\n            auth_config_file = TOMLFile(CONFIG_DIR / \"auth.toml\")\n            if auth_config_file.exists():\n                logger.debug(\"Loading configuration file %s\", auth_config_file.path)\n                _default_config.merge(auth_config_file.read())\n\n            _default_config.set_auth_config_source(FileConfigSource(auth_config_file))\n\n        return _default_config",
    "source": "github_repo:python-poetry/poetry",
    "file": "src/poetry/config/config.py",
    "license": "MIT",
    "language": "python"
}