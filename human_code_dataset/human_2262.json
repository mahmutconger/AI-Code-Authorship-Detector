{
    "code": "class Application(BaseApplication):\n    def __init__(self) -> None:\n        super().__init__(\"poetry\", __version__)\n\n        self._poetry: Poetry | None = None\n        self._io: IO | None = None\n        self._disable_plugins = False\n        self._disable_cache = False\n        self._plugins_loaded = False\n        self._working_directory = Path.cwd()\n        self._project_directory: Path | None = None\n\n        dispatcher = EventDispatcher()\n        dispatcher.add_listener(COMMAND, self.register_command_loggers)\n        dispatcher.add_listener(COMMAND, self.configure_env)\n        dispatcher.add_listener(COMMAND, self.configure_installer_for_event)\n        self.set_event_dispatcher(dispatcher)\n\n        command_loader = CommandLoader({name: load_command(name) for name in COMMANDS})\n        self.set_command_loader(command_loader)\n\n    @property\n    def _default_definition(self) -> Definition:\n        from cleo.io.inputs.option import Option\n\n        definition = super()._default_definition\n\n        definition.add_option(\n            Option(\"--no-plugins\", flag=True, description=\"Disables plugins.\")\n        )\n\n        definition.add_option(\n            Option(\n                \"--no-cache\", flag=True, description=\"Disables Poetry source caches.\"\n            )\n        )\n\n        definition.add_option(\n            Option(\n                \"--project\",\n                \"-P\",\n                flag=False,\n                description=(\n                    \"Specify another path as the project root.\"\n                    \" All command-line arguments will be resolved relative to the current working directory.\"\n                ),\n            )\n        )\n\n        definition.add_option(\n            Option(\n                \"--directory\",\n                \"-C\",\n                flag=False,\n                description=(\n                    \"The working directory for the Poetry command (defaults to the\"\n                    \" current working directory). All command-line arguments will be\"\n                    \" resolved relative to the given directory.\"\n                ),\n            )\n        )\n\n        return definition\n\n    @property\n    def project_directory(self) -> Path:\n        return self._project_directory or self._working_directory\n\n    @property\n    def poetry(self) -> Poetry:\n        from poetry.factory import Factory\n\n        if self._poetry is not None:\n            return self._poetry\n\n        self._poetry = Factory().create_poetry(\n            cwd=self.project_directory,\n            io=self._io,\n            disable_plugins=self._disable_plugins,\n            disable_cache=self._disable_cache,\n        )\n\n        return self._poetry\n\n    @property\n    def command_loader(self) -> CommandLoader:\n        command_loader = self._command_loader\n        assert isinstance(command_loader, CommandLoader)\n        return command_loader\n\n    def reset_poetry(self) -> None:\n        self._poetry = None\n\n    def create_io(\n        self,\n        input: Input | None = None,\n        output: Output | None = None,\n        error_output: Output | None = None,\n    ) -> IO:\n        io = super().create_io(input, output, error_output)\n\n        # Set our own CLI styles\n        formatter = io.output.formatter\n        formatter.set_style(\"c1\", Style(\"cyan\"))\n        formatter.set_style(\"c2\", Style(\"default\", options=[\"bold\"]))\n        formatter.set_style(\"info\", Style(\"blue\"))\n        formatter.set_style(\"comment\", Style(\"green\"))\n        formatter.set_style(\"warning\", Style(\"yellow\"))\n        formatter.set_style(\"debug\", Style(\"default\", options=[\"dark\"]))\n        formatter.set_style(\"success\", Style(\"green\"))\n\n        # Dark variants\n        formatter.set_style(\"c1_dark\", Style(\"cyan\", options=[\"dark\"]))\n        formatter.set_style(\"c2_dark\", Style(\"default\", options=[\"bold\", \"dark\"]))\n        formatter.set_style(\"success_dark\", Style(\"green\", options=[\"dark\"]))\n\n        io.output.set_formatter(formatter)\n        io.error_output.set_formatter(formatter)\n\n        self._io = io\n\n        return io\n\n    def _run(self, io: IO) -> int:\n        # we do this here and not inside the _configure_io implementation in order\n        # to ensure the users are not exposed to a stack trace for providing invalid values to\n        # the options --directory or --project, configuring the options here allow cleo to trap and\n        # display the error cleanly unless the user uses verbose or debug\n        self._configure_global_options(io)\n\n        with directory(self._working_directory):\n            self._load_plugins(io)\n\n            exit_code: int = 1\n\n            try:\n                exit_code = super()._run(io)\n            except PoetryRuntimeError as e:\n                io.write_error_line(\"\")\n                e.write(io)\n                io.write_error_line(\"\")\n            except CleoCommandNotFoundError as e:\n                command = self._get_command_name(io)\n\n                if command is not None and (\n                    message := COMMAND_NOT_FOUND_MESSAGES.get(command)\n                ):\n                    io.write_error_line(\"\")\n                    io.write_error_line(COMMAND_NOT_FOUND_PREFIX_MESSAGE)\n                    io.write_error_line(message)\n                    return 1\n\n                if command is not None and command in self.get_namespaces():\n                    sub_commands = []\n\n                    for key in self._commands:\n                        if key.startswith(f\"{command} \"):\n                            sub_commands.append(key)\n\n                    io.write_error_line(\n                        f\"The requested command does not exist in the <c1>{command}</> namespace.\"\n                    )\n                    suggested_names = find_similar_names(command, sub_commands)\n                    self._error_write_command_suggestions(\n                        io, suggested_names, f\"#{command}\"\n                    )\n                    return 1\n\n                if command is not None:\n                    suggested_names = find_similar_names(\n                        command, list(self._commands.keys())\n                    )\n                    io.write_error_line(\n                        f\"The requested command <c1>{command}</> does not exist.\"\n                    )\n                    self._error_write_command_suggestions(io, suggested_names)\n                    return 1\n\n                raise e\n\n        return exit_code\n\n    def _error_write_command_suggestions(\n        self, io: IO, suggested_names: list[str], doc_tag: str | None = None\n    ) -> None:\n        if suggested_names:\n            suggestion_lines = [\n                f\"<c1>{name.replace(' ', '</> <b>', 1)}</>: {self._commands[name].description}\"\n                for name in suggested_names\n            ]\n            suggestions = \"\\n    \".join([\"\", *sorted(suggestion_lines)])\n            io.write_error_line(\n                f\"\\n<error>Did you mean one of these perhaps?</>{suggestions}\"\n            )\n\n        io.write_error_line(\n            \"\\n<b>Documentation: </>\"\n            f\"<info>https://python-poetry.org/docs/cli/{doc_tag or ''}</>\"\n        )\n\n    def _configure_global_options(self, io: IO) -> None:\n        \"\"\"\n        Configures global options for the application by setting up the relevant\n        directories, disabling plugins or cache, and managing the working and\n        project directories. This method ensures that all directories are valid\n        paths and handles the resolution of the project directory relative to the\n        working directory if necessary.\n\n        :param io: The IO instance whose input and options are being read.\n        :return: Nothing.\n        \"\"\"\n        self._disable_plugins = io.input.option(\"no-plugins\")\n        self._disable_cache = io.input.option(\"no-cache\")\n\n        # we use ensure_path for the directories to make sure these are valid paths\n        # this will raise an exception if the path is invalid\n        self._working_directory = ensure_path(\n            io.input.option(\"directory\") or Path.cwd(), is_directory=True\n        )\n\n        self._project_directory = io.input.option(\"project\")\n        if self._project_directory is not None:\n            self._project_directory = Path(self._project_directory)\n            self._project_directory = ensure_path(\n                self._project_directory\n                if self._project_directory.is_absolute()\n                else self._working_directory.joinpath(self._project_directory).resolve(\n                    strict=False\n                ),\n                is_directory=True,\n            )\n\n    def _sort_global_options(self, io: IO) -> None:\n        \"\"\"\n        Sorts global options of the provided IO instance according to the\n        definition of the available options, reordering and parsing arguments\n        to ensure consistency in input handling.\n\n        The function interprets the options and their corresponding values\n        using an argument parser, constructs a sorted list of tokens, and\n        recreates the input with the rearranged sequence while maintaining\n        compatibility with the initially provided input stream.\n\n        If using in conjunction with `_configure_run_command`, it is recommended that\n        it be called first in order to correctly handling cases like\n        `poetry run -V python -V`.\n\n        :param io: The IO instance whose input and options are being processed\n                   and reordered.\n        :return: Nothing.\n        \"\"\"\n        original_input = cast(\"ArgvInput\", io.input)\n        tokens: list[str] = original_input._tokens\n\n        parser = argparse.ArgumentParser(add_help=False)\n\n        for option in self.definition.options:\n            parser.add_argument(\n                f\"--{option.name}\",\n                *([f\"-{option.shortcut}\"] if option.shortcut else []),\n                action=\"store_true\" if option.is_flag() else \"store\",\n            )\n\n        args, remaining_args = parser.parse_known_args(tokens)\n\n        tokens = []\n        for option in self.definition.options:\n            key = option.name.replace(\"-\", \"_\")\n            value = getattr(args, key, None)\n\n            if value is not None:\n                if value:  # is truthy\n                    tokens.append(f\"--{option.name}\")\n\n                if option.accepts_value():\n                    tokens.append(str(value))\n\n        sorted_input = ArgvInput([self._name or \"\", *tokens, *remaining_args])\n\n        # this is required to ensure stdin is transferred\n        sorted_input.set_stream(original_input.stream)\n\n        # this is required as cleo internally checks for `io.input._interactive`\n        # when configuring io, and cleo's test applications overrides this attribute\n        # explicitly causing test setups to fail\n        sorted_input.interactive(io.input.is_interactive())\n\n        with suppress(CleoError):\n            sorted_input.bind(self.definition)\n\n        io.set_input(sorted_input)\n\n    def _configure_run_command(self, io: IO) -> None:\n        \"\"\"\n        Configures the input for the \"run\" command to properly handle cases where the user\n        executes commands such as \"poetry run -- <subcommand>\". This involves reorganizing\n        input tokens to ensure correct parsing and execution of the run command.\n        \"\"\"\n        with suppress(CleoError):\n            io.input.bind(self.definition)\n\n        command_name = io.input.first_argument\n\n        if command_name == \"run\":\n            original_input = cast(\"ArgvInput\", io.input)\n            tokens: list[str] = original_input._tokens\n\n            if \"--\" in tokens:\n                # this means the user has done the right thing and used \"poetry run -- echo hello\"\n                # in this case there is not much we need to do, we can skip the rest\n                return\n\n            # find the correct command index, in some cases this might not be first occurrence\n            # eg: poetry -C run run echo\n            command_index = tokens.index(command_name)\n\n            while command_index < (len(tokens) - 1):\n                try:\n                    # try parsing the tokens so far\n                    _ = ArgvInput(\n                        [self._name or \"\", *tokens[: command_index + 1]],\n                        definition=self.definition,\n                    )\n                    break\n                except CleoError:\n                    # parsing failed, try finding the next \"run\" token\n                    try:\n                        command_index += (\n                            tokens[command_index + 1 :].index(command_name) + 1\n                        )\n                    except ValueError:\n                        command_index = len(tokens)\n            else:\n                # looks like we reached the end of the road, let cleo deal with it\n                return\n\n            # fetch tokens after the \"run\" command\n            tokens_without_command = tokens[command_index + 1 :]\n\n            # we create a new input for parsing the subcommand pretending\n            # it is poetry command\n            without_command = ArgvInput(\n                [self._name or \"\", *tokens_without_command], None\n            )\n\n            with suppress(CleoError):\n                # we want to bind the definition here so that cleo knows what should be\n                # parsed, and how\n                without_command.bind(self.definition)\n\n            # the first argument here is the subcommand\n            subcommand = without_command.first_argument\n            subcommand_index = (\n                (tokens_without_command.index(subcommand) if subcommand else 0)\n                + command_index\n                + 1\n            )\n\n            # recreate the original input reordering in the following order\n            #   - all tokens before \"run\" command\n            #   - all tokens after \"run\" command but before the subcommand\n            #   - the \"run\" command token\n            #   - the \"--\" token to normalise the form\n            #   - all remaining tokens starting with the subcommand\n            run_input = ArgvInput(\n                [\n                    self._name or \"\",\n                    *tokens[:command_index],\n                    *tokens[command_index + 1 : subcommand_index],\n                    command_name,\n                    \"--\",\n                    *tokens[subcommand_index:],\n                ]\n            )\n            run_input.set_stream(original_input.stream)\n\n            with suppress(CleoError):\n                run_input.bind(self.definition)\n\n            # reset the input to our constructed form\n            io.set_input(run_input)\n\n    def _configure_io(self, io: IO) -> None:\n        self._configure_run_command(io)\n        self._sort_global_options(io)\n        super()._configure_io(io)\n\n    def register_command_loggers(\n        self, event: Event, event_name: str, _: EventDispatcher\n    ) -> None:\n        from poetry.console.logging.filters import POETRY_FILTER\n        from poetry.console.logging.io_formatter import IOFormatter\n        from poetry.console.logging.io_handler import IOHandler\n\n        assert isinstance(event, ConsoleCommandEvent)\n        command = event.command\n        if not isinstance(command, Command):\n            return\n\n        io = event.io\n\n        loggers = [\n            \"poetry.packages.locker\",\n            \"poetry.packages.package\",\n            \"poetry.utils.password_manager\",\n        ]\n\n        loggers += command.loggers\n\n        handler = IOHandler(io)\n        handler.setFormatter(IOFormatter())\n\n        level = logging.WARNING\n\n        if io.is_debug():\n            level = logging.DEBUG\n        elif io.is_very_verbose() or io.is_verbose():\n            level = logging.INFO\n\n        logging.basicConfig(level=level, handlers=[handler])\n\n        # only log third-party packages when very verbose\n        if not io.is_very_verbose():\n            handler.addFilter(POETRY_FILTER)\n\n        for name in loggers:\n            logger = logging.getLogger(name)\n\n            _level = level\n            # The builders loggers are special and we can actually\n            # start at the INFO level.\n            if (\n                logger.name.startswith(\"poetry.core.masonry.builders\")\n                and _level > logging.INFO\n            ):\n                _level = logging.INFO\n\n            logger.setLevel(_level)\n\n    def configure_env(self, event: Event, event_name: str, _: EventDispatcher) -> None:\n        from poetry.console.commands.env_command import EnvCommand\n        from poetry.console.commands.self.self_command import SelfCommand\n\n        assert isinstance(event, ConsoleCommandEvent)\n        command = event.command\n        if not isinstance(command, EnvCommand) or isinstance(command, SelfCommand):\n            return\n\n        if command._env is not None:\n            return\n\n        from poetry.utils.env import EnvManager\n\n        io = event.io\n        poetry = command.poetry\n\n        env_manager = EnvManager(poetry, io=io)\n        env = env_manager.create_venv()\n\n        if env.is_venv() and io.is_verbose():\n            io.write_error_line(f\"Using virtualenv: <comment>{env.path}</>\")\n\n        command.set_env(env)\n\n    @classmethod\n    def configure_installer_for_event(\n        cls, event: Event, event_name: str, _: EventDispatcher\n    ) -> None:\n        from poetry.console.commands.installer_command import InstallerCommand\n\n        assert isinstance(event, ConsoleCommandEvent)\n        command = event.command\n        if not isinstance(command, InstallerCommand):\n            return\n\n        # If the command already has an installer\n        # we skip this step\n        if command._installer is not None:\n            return\n\n        cls.configure_installer_for_command(command, event.io)\n\n    @staticmethod\n    def configure_installer_for_command(command: InstallerCommand, io: IO) -> None:\n        from poetry.installation.installer import Installer\n\n        poetry = command.poetry\n        installer = Installer(\n            io,\n            command.env,\n            poetry.package,\n            poetry.locker,\n            poetry.pool,\n            poetry.config,\n            disable_cache=poetry.disable_cache,\n        )\n        command.set_installer(installer)\n\n    def _load_plugins(self, io: IO) -> None:\n        if self._plugins_loaded:\n            return\n\n        self._disable_plugins = io.input.has_parameter_option(\"--no-plugins\")\n\n        if not self._disable_plugins:\n            from poetry.plugins.application_plugin import ApplicationPlugin\n            from poetry.plugins.plugin_manager import PluginManager\n\n            PluginManager.add_project_plugin_path(self.project_directory)\n            manager = PluginManager(ApplicationPlugin.group)\n            manager.load_plugins()\n            manager.activate(self)\n\n        self._plugins_loaded = True",
    "source": "github_repo:python-poetry/poetry",
    "file": "src/poetry/console/application.py",
    "license": "MIT",
    "language": "python"
}