{
    "code": "def tts(self, text, output_path, speaker, language='English', speed=1.0):\n        mark = self.language_marks.get(language.lower(), None)\n        assert mark is not None, f\"language {language} is not supported\"\n\n        texts = self.split_sentences_into_pieces(text, mark)\n\n        audio_list = []\n        for t in texts:\n            t = re.sub(r'([a-z])([A-Z])', r'\\1 \\2', t)\n            t = f'[{mark}]{t}[{mark}]'\n            stn_tst = self.get_text(t, self.hps, False)\n            device = self.device\n            speaker_id = self.hps.speakers[speaker]\n            with torch.no_grad():\n                x_tst = stn_tst.unsqueeze(0).to(device)\n                x_tst_lengths = torch.LongTensor([stn_tst.size(0)]).to(device)\n                sid = torch.LongTensor([speaker_id]).to(device)\n                audio = self.model.infer(x_tst, x_tst_lengths, sid=sid, noise_scale=0.667, noise_scale_w=0.6,\n                                    length_scale=1.0 / speed)[0][0, 0].data.cpu().float().numpy()\n            audio_list.append(audio)\n        audio = self.audio_numpy_concat(audio_list, sr=self.hps.data.sampling_rate, speed=speed)\n\n        if output_path is None:\n            return audio\n        else:\n            soundfile.write(output_path, audio, self.hps.data.sampling_rate)",
    "source": "github_repo:myshell-ai/OpenVoice",
    "file": "openvoice/api.py",
    "license": "MIT",
    "language": "python"
}