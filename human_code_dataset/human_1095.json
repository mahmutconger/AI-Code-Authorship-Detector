{
    "code": "class BrowserAgent(ToolCallAgent):\n    \"\"\"\n    A browser agent that uses the browser_use library to control a browser.\n\n    This agent can navigate web pages, interact with elements, fill forms,\n    extract content, and perform other browser-based actions to accomplish tasks.\n    \"\"\"\n\n    name: str = \"browser\"\n    description: str = \"A browser agent that can control a browser to accomplish tasks\"\n\n    system_prompt: str = SYSTEM_PROMPT\n    next_step_prompt: str = NEXT_STEP_PROMPT\n\n    max_observe: int = 10000\n    max_steps: int = 20\n\n    # Configure the available tools\n    available_tools: ToolCollection = Field(\n        default_factory=lambda: ToolCollection(BrowserUseTool(), Terminate())\n    )\n\n    # Use Auto for tool choice to allow both tool usage and free-form responses\n    tool_choices: ToolChoice = ToolChoice.AUTO\n    special_tool_names: list[str] = Field(default_factory=lambda: [Terminate().name])\n\n    browser_context_helper: Optional[BrowserContextHelper] = None\n\n    @model_validator(mode=\"after\")\n    def initialize_helper(self) -> \"BrowserAgent\":\n        self.browser_context_helper = BrowserContextHelper(self)\n        return self\n\n    async def think(self) -> bool:\n        \"\"\"Process current state and decide next actions using tools, with browser state info added\"\"\"\n        self.next_step_prompt = (\n            await self.browser_context_helper.format_next_step_prompt()\n        )\n        return await super().think()\n\n    async def cleanup(self):\n        \"\"\"Clean up browser agent resources by calling parent cleanup.\"\"\"\n        await self.browser_context_helper.cleanup_browser()",
    "source": "github_repo:FoundationAgents/OpenManus",
    "file": "app/agent/browser.py",
    "license": "MIT",
    "language": "python"
}