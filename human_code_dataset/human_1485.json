{
    "code": "def category(name: str, desc: str, hooks: list[type[hooks.Hook]]) -> None:\n    all_params = [\n        list(inspect.signature(hook.__init__, eval_str=True).parameters.values())[1:]\n        for hook in hooks\n    ]\n\n    # slightly overengineered, but this was fun to write.  ¯\\_(ツ)_/¯\n    imports = set()\n    types = set()\n    for params in all_params:\n        for param in params:\n            try:\n                imports.add(inspect.getmodule(param.annotation).__name__)\n                for t in typing.get_args(param.annotation):\n                    imports.add(inspect.getmodule(t).__name__)\n            except AttributeError:\n                raise ValueError(f\"Missing type annotation: {params}\")\n    imports.discard(\"builtins\")\n    if types:\n        print(f\"from typing import {', '.join(sorted(types))}\")\n    print(\"import logging\")\n    for imp in sorted(imports):\n        print(f\"import {imp}\")\n    print()\n\n    print(f\"class {name}Events:\")\n    print(f'    \"\"\"{desc}\"\"\"')\n\n    first = True\n    for hook, params in zip(hooks, all_params):\n        if first:\n            first = False\n        else:\n            print()\n        if hook.name in known:\n            raise RuntimeError(f\"Already documented: {hook}\")\n        known.add(hook.name)\n        doc = inspect.getdoc(hook)\n        print(f\"    @staticmethod\")\n        print(f\"    def {hook.name}({', '.join(str(p) for p in params)}):\")\n        print(textwrap.indent(f'\"\"\"\\n{doc}\\n\"\"\"', \"        \"))\n        if params:\n            print(\n                f'        logging.info(f\"{hook.name}: {\" \".join(\"{\" + p.name + \"=}\" for p in params)}\")'\n            )\n        else:\n            print(f'        logging.info(\"{hook.name}\")')\n    print(\"\")",
    "source": "github_repo:mitmproxy/mitmproxy",
    "file": "docs/scripts/api-events.py",
    "license": "MIT",
    "language": "python"
}