{
    "code": "class Animation(object):\n    def __init__(\n        self,\n        mobject: Mobject,\n        run_time: float = DEFAULT_ANIMATION_RUN_TIME,\n        # Tuple of times, between which the animation will run\n        time_span: tuple[float, float] | None = None,\n        # If 0, the animation is applied to all submobjects at the same time\n        # If 1, it is applied to each successively.\n        # If 0 < lag_ratio < 1, its applied to each with lagged start times\n        lag_ratio: float = DEFAULT_ANIMATION_LAG_RATIO,\n        rate_func: Callable[[float], float] = smooth,\n        name: str = \"\",\n        # Does this animation add or remove a mobject from the screen\n        remover: bool = False,\n        # What to enter into the update function upon completion\n        final_alpha_value: float = 1.0,\n        # If set to True, the mobject itself will have its internal updaters called,\n        # but the start or target mobjects would not be suspended. To completely suspend\n        # updating, call mobject.suspend_updating() before the animation\n        suspend_mobject_updating: bool = False,\n    ):\n        self._validate_input_type(mobject)\n        self.mobject = mobject\n        self.run_time = run_time\n        self.time_span = time_span\n        self.rate_func = rate_func\n        self.name = name or self.__class__.__name__ + str(self.mobject)\n        self.remover = remover\n        self.final_alpha_value = final_alpha_value\n        self.lag_ratio = lag_ratio\n        self.suspend_mobject_updating = suspend_mobject_updating\n\n    def _validate_input_type(self, mobject: Mobject) -> None:\n        if not isinstance(mobject, Mobject):\n            raise TypeError(\"Animation only works for Mobjects.\")\n\n    def __str__(self) -> str:\n        return self.name\n\n    def begin(self) -> None:\n        # This is called right as an animation is being\n        # played.  As much initialization as possible,\n        # especially any mobject copying, should live in\n        # this method\n        if self.time_span is not None:\n            start, end = self.time_span\n            self.run_time = max(end, self.run_time)\n        self.mobject.set_animating_status(True)\n        self.starting_mobject = self.create_starting_mobject()\n        if self.suspend_mobject_updating:\n            self.mobject_was_updating = not self.mobject.updating_suspended\n            self.mobject.suspend_updating()\n        self.families = list(self.get_all_families_zipped())\n        self.interpolate(0)\n\n    def finish(self) -> None:\n        self.interpolate(self.final_alpha_value)\n        self.mobject.set_animating_status(False)\n        if self.suspend_mobject_updating and self.mobject_was_updating:\n            self.mobject.resume_updating()\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        if self.is_remover():\n            scene.remove(self.mobject)\n\n    def create_starting_mobject(self) -> Mobject:\n        # Keep track of where the mobject starts\n        return self.mobject.copy()\n\n    def get_all_mobjects(self) -> tuple[Mobject, Mobject]:\n        \"\"\"\n        Ordering must match the ording of arguments to interpolate_submobject\n        \"\"\"\n        return self.mobject, self.starting_mobject\n\n    def get_all_families_zipped(self) -> zip[tuple[Mobject]]:\n        return zip(*[\n            mob.get_family()\n            for mob in self.get_all_mobjects()\n        ])\n\n    def update_mobjects(self, dt: float) -> None:\n        \"\"\"\n        Updates things like starting_mobject, and (for\n        Transforms) target_mobject.\n        \"\"\"\n        for mob in self.get_all_mobjects_to_update():\n            mob.update(dt)\n\n    def get_all_mobjects_to_update(self) -> list[Mobject]:\n        # The surrounding scene typically handles\n        # updating of self.mobject.\n        items = list(filter(\n            lambda m: m is not self.mobject,\n            self.get_all_mobjects()\n        ))\n        items = remove_list_redundancies(items)\n        return items\n\n    def copy(self):\n        return deepcopy(self)\n\n    def update_rate_info(\n        self,\n        run_time: float | None = None,\n        rate_func: Callable[[float], float] | None = None,\n        lag_ratio: float | None = None,\n    ):\n        self.run_time = run_time or self.run_time\n        self.rate_func = rate_func or self.rate_func\n        self.lag_ratio = lag_ratio or self.lag_ratio\n        return self\n\n    # Methods for interpolation, the mean of an Animation\n    def interpolate(self, alpha: float) -> None:\n        self.interpolate_mobject(alpha)\n\n    def update(self, alpha: float) -> None:\n        \"\"\"\n        This method shouldn't exist, but it's here to\n        keep many old scenes from breaking\n        \"\"\"\n        self.interpolate(alpha)\n\n    def time_spanned_alpha(self, alpha: float) -> float:\n        if self.time_span is not None:\n            start, end = self.time_span\n            return clip(alpha * self.run_time - start, 0, end - start) / (end - start)\n        return alpha\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        for i, mobs in enumerate(self.families):\n            sub_alpha = self.get_sub_alpha(self.time_spanned_alpha(alpha), i, len(self.families))\n            self.interpolate_submobject(*mobs, sub_alpha)\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float\n    ):\n        # Typically ipmlemented by subclass\n        pass\n\n    def get_sub_alpha(\n        self,\n        alpha: float,\n        index: int,\n        num_submobjects: int\n    ) -> float:\n        # TODO, make this more understanable, and/or combine\n        # its functionality with AnimationGroup's method\n        # build_animations_with_timings\n        lag_ratio = self.lag_ratio\n        full_length = (num_submobjects - 1) * lag_ratio + 1\n        value = alpha * full_length\n        lower = index * lag_ratio\n        raw_sub_alpha = clip((value - lower), 0, 1)\n        return self.rate_func(raw_sub_alpha)\n\n    # Getters and setters\n    def set_run_time(self, run_time: float):\n        self.run_time = run_time\n        return self\n\n    def get_run_time(self) -> float:\n        if self.time_span:\n            return max(self.run_time, self.time_span[1])\n        return self.run_time\n\n    def set_rate_func(self, rate_func: Callable[[float], float]):\n        self.rate_func = rate_func\n        return self\n\n    def get_rate_func(self) -> Callable[[float], float]:\n        return self.rate_func\n\n    def set_name(self, name: str):\n        self.name = name\n        return self\n\n    def is_remover(self) -> bool:\n        return self.remover",
    "source": "github_repo:3b1b/manim",
    "file": "manimlib/animation/animation.py",
    "license": "MIT",
    "language": "python"
}