{
    "code": "class EnterpriseActionTool(BaseTool):\n    \"\"\"A tool that executes a specific enterprise action.\"\"\"\n\n    enterprise_action_token: str = Field(\n        default=\"\", description=\"The enterprise action token\"\n    )\n    action_name: str = Field(default=\"\", description=\"The name of the action\")\n    action_schema: dict[str, Any] = Field(\n        default={}, description=\"The schema of the action\"\n    )\n    enterprise_api_base_url: str = Field(\n        default=ENTERPRISE_API_BASE_URL, description=\"The base API URL\"\n    )\n\n    def __init__(\n        self,\n        name: str,\n        description: str,\n        enterprise_action_token: str,\n        action_name: str,\n        action_schema: dict[str, Any],\n        enterprise_api_base_url: str | None = None,\n    ):\n        self._model_registry = {}  # type: ignore[var-annotated]\n        self._base_name = self._sanitize_name(name)\n\n        schema_props, required = self._extract_schema_info(action_schema)\n\n        # Define field definitions for the model\n        field_definitions = {}\n        for param_name, param_details in schema_props.items():\n            param_desc = param_details.get(\"description\", \"\")\n            is_required = param_name in required\n\n            try:\n                field_type = self._process_schema_type(\n                    param_details, self._sanitize_name(param_name).title()\n                )\n            except Exception:\n                field_type = str\n\n            # Create field definition based on requirement\n            field_definitions[param_name] = self._create_field_definition(\n                field_type, is_required, param_desc\n            )\n\n        # Create the model\n        if field_definitions:\n            try:\n                args_schema = create_model(  # type: ignore[call-overload]\n                    f\"{self._base_name}Schema\", **field_definitions\n                )\n            except Exception:\n                args_schema = create_model(\n                    f\"{self._base_name}Schema\",\n                    input_text=(str, Field(description=\"Input for the action\")),\n                )\n        else:\n            # Fallback for empty schema\n            args_schema = create_model(\n                f\"{self._base_name}Schema\",\n                input_text=(str, Field(description=\"Input for the action\")),\n            )\n\n        super().__init__(name=name, description=description, args_schema=args_schema)\n        self.enterprise_action_token = enterprise_action_token\n        self.action_name = action_name\n        self.action_schema = action_schema\n        self.enterprise_api_base_url = (\n            enterprise_api_base_url or get_enterprise_api_base_url()\n        )\n\n    def _sanitize_name(self, name: str) -> str:\n        \"\"\"Sanitize names to create proper Python class names.\"\"\"\n        sanitized = re.sub(r\"[^a-zA-Z0-9_]\", \"\", name)\n        parts = sanitized.split(\"_\")\n        return \"\".join(word.capitalize() for word in parts if word)\n\n    def _extract_schema_info(\n        self, action_schema: dict[str, Any]\n    ) -> tuple[dict[str, Any], list[str]]:\n        \"\"\"Extract schema properties and required fields from action schema.\"\"\"\n        schema_props = (\n            action_schema.get(\"function\", {})\n            .get(\"parameters\", {})\n            .get(\"properties\", {})\n        )\n        required = (\n            action_schema.get(\"function\", {}).get(\"parameters\", {}).get(\"required\", [])\n        )\n        return schema_props, required\n\n    def _process_schema_type(\n        self, schema: dict[str, Any], type_name: str\n    ) -> type[Any] | _SpecialForm:\n        \"\"\"Process a JSON schema and return appropriate Python type.\"\"\"\n        if \"anyOf\" in schema:\n            any_of_types = schema[\"anyOf\"]\n            is_nullable = any(t.get(\"type\") == \"null\" for t in any_of_types)\n            non_null_types = [t for t in any_of_types if t.get(\"type\") != \"null\"]\n\n            if non_null_types:\n                base_type = self._process_schema_type(non_null_types[0], type_name)\n                return Optional[base_type] if is_nullable else base_type  # noqa: UP045\n            return cast(type[Any], Optional[str])  # noqa: UP045\n\n        if \"oneOf\" in schema:\n            return self._process_schema_type(schema[\"oneOf\"][0], type_name)\n\n        if \"allOf\" in schema:\n            return self._process_schema_type(schema[\"allOf\"][0], type_name)\n\n        json_type = schema.get(\"type\", \"string\")\n\n        if \"enum\" in schema:\n            enum_values = schema[\"enum\"]\n            if not enum_values:\n                return self._map_json_type_to_python(json_type)\n            return Literal[tuple(enum_values)]  # type: ignore[return-value]\n\n        if json_type == \"array\":\n            items_schema = schema.get(\"items\", {\"type\": \"string\"})\n            item_type = self._process_schema_type(items_schema, f\"{type_name}Item\")\n            return list[item_type]  # type: ignore[valid-type]\n\n        if json_type == \"object\":\n            return self._create_nested_model(schema, type_name)\n\n        return self._map_json_type_to_python(json_type)\n\n    def _create_nested_model(\n        self, schema: dict[str, Any], model_name: str\n    ) -> type[Any]:\n        \"\"\"Create a nested Pydantic model for complex objects.\"\"\"\n        full_model_name = f\"{self._base_name}{model_name}\"\n\n        if full_model_name in self._model_registry:\n            return self._model_registry[full_model_name]\n\n        properties = schema.get(\"properties\", {})\n        required_fields = schema.get(\"required\", [])\n\n        if not properties:\n            return dict\n\n        field_definitions = {}\n        for prop_name, prop_schema in properties.items():\n            prop_desc = prop_schema.get(\"description\", \"\")\n            is_required = prop_name in required_fields\n\n            try:\n                prop_type = self._process_schema_type(\n                    prop_schema, f\"{model_name}{self._sanitize_name(prop_name).title()}\"\n                )\n            except Exception:\n                prop_type = str\n\n            field_definitions[prop_name] = self._create_field_definition(\n                prop_type,\n                is_required,\n                prop_desc,  # type: ignore[arg-type]\n            )\n\n        try:\n            nested_model = create_model(full_model_name, **field_definitions)  # type: ignore[call-overload]\n            self._model_registry[full_model_name] = nested_model\n            return nested_model\n        except Exception:\n            return dict\n\n    def _create_field_definition(\n        self, field_type: type[Any] | _SpecialForm, is_required: bool, description: str\n    ) -> tuple:\n        \"\"\"Create Pydantic field definition based on type and requirement.\"\"\"\n        if is_required:\n            return (field_type, Field(description=description))\n        if get_origin(field_type) is Union:\n            return (field_type, Field(default=None, description=description))\n        return (\n            Optional[field_type],  # noqa: UP045\n            Field(default=None, description=description),\n        )\n\n    def _map_json_type_to_python(self, json_type: str) -> type[Any]:\n        \"\"\"Map basic JSON schema types to Python types.\"\"\"\n        type_mapping = {\n            \"string\": str,\n            \"integer\": int,\n            \"number\": float,\n            \"boolean\": bool,\n            \"array\": list,\n            \"object\": dict,\n            \"null\": type(None),\n        }\n        return type_mapping.get(json_type, str)\n\n    def _get_required_nullable_fields(self) -> list[str]:\n        \"\"\"Get a list of required nullable fields from the action schema.\"\"\"\n        schema_props, required = self._extract_schema_info(self.action_schema)\n\n        required_nullable_fields = []\n        for param_name in required:\n            param_details = schema_props.get(param_name, {})\n            if self._is_nullable_type(param_details):\n                required_nullable_fields.append(param_name)\n\n        return required_nullable_fields\n\n    def _is_nullable_type(self, schema: dict[str, Any]) -> bool:\n        \"\"\"Check if a schema represents a nullable type.\"\"\"\n        if \"anyOf\" in schema:\n            return any(t.get(\"type\") == \"null\" for t in schema[\"anyOf\"])\n        return schema.get(\"type\") == \"null\"\n\n    def _run(self, **kwargs) -> str:\n        \"\"\"Execute the specific enterprise action with validated parameters.\"\"\"\n        try:\n            cleaned_kwargs = {}\n            for key, value in kwargs.items():\n                if value is not None:\n                    cleaned_kwargs[key] = value  # noqa: PERF403\n\n            required_nullable_fields = self._get_required_nullable_fields()\n\n            for field_name in required_nullable_fields:\n                if field_name not in cleaned_kwargs:\n                    cleaned_kwargs[field_name] = None\n\n            api_url = (\n                f\"{self.enterprise_api_base_url}/actions/{self.action_name}/execute\"\n            )\n            headers = {\n                \"Authorization\": f\"Bearer {self.enterprise_action_token}\",\n                \"Content-Type\": \"application/json\",\n            }\n            payload = cleaned_kwargs\n\n            response = requests.post(\n                url=api_url, headers=headers, json=payload, timeout=60\n            )\n\n            data = response.json()\n            if not response.ok:\n                error_message = data.get(\"error\", {}).get(\"message\", json.dumps(data))\n                return f\"API request failed: {error_message}\"\n\n            return json.dumps(data, indent=2)\n\n        except Exception as e:\n            return f\"Error executing action {self.action_name}: {e!s}\"",
    "source": "github_repo:crewAIInc/crewAI",
    "file": "lib/crewai-tools/src/crewai_tools/adapters/enterprise_adapter.py",
    "license": "MIT",
    "language": "python"
}