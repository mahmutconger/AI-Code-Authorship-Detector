{
    "code": "def main():\n    global NC, BY_PATH  # pylint: disable=global-statement\n    os.system(\"\")\n    print()\n\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"db\", help=\"database to work on\")\n    ap.add_argument(\"-h2\", action=\"store_true\", help=\"show examples\")\n    ap.add_argument(\"-src\", metavar=\"DB\", type=str, help=\"database to copy from\")\n\n    ap2 = ap.add_argument_group(\"informational / read-only stuff\")\n    ap2.add_argument(\"-v\", action=\"store_true\", help=\"verbose\")\n    ap2.add_argument(\"-ls\", action=\"store_true\", help=\"list summary for db\")\n    ap2.add_argument(\"-cmp\", action=\"store_true\", help=\"compare databases\")\n\n    ap2 = ap.add_argument_group(\"options which modify target db\")\n    ap2.add_argument(\"-copy\", metavar=\"TAG\", type=str, help=\"mtp tag to copy over\")\n    ap2.add_argument(\n        \"-rm-mtp-flag\",\n        action=\"store_true\",\n        help=\"when an mtp tag is copied over, also mark that file as done, so copyparty won't run any mtps on those files\",\n    )\n    ap2.add_argument(\"-vac\", action=\"store_true\", help=\"optimize DB\")\n\n    ap2 = ap.add_argument_group(\"behavior modifiers\")\n    ap2.add_argument(\n        \"-nc\",\n        action=\"store_true\",\n        help=\"no-clobber; don't replace/overwrite existing tags\",\n    )\n    ap2.add_argument(\n        \"-by-path\",\n        action=\"store_true\",\n        help=\"match files based on location rather than warks (content-hash), use this if the databases have different wark salts\",\n    )\n\n    ar = ap.parse_args()\n    if ar.h2:\n        examples()\n        return\n\n    NC = ar.nc\n    BY_PATH = ar.by_path\n\n    for v in [ar.db, ar.src]:\n        if v and not os.path.exists(v):\n            die(\"database must exist\")\n\n    db = sqlite3.connect(ar.db)\n    ds = sqlite3.connect(ar.src) if ar.src else None\n\n    # revert journals\n    for d, p in [[db, ar.db], [ds, ar.src]]:\n        if not d:\n            continue\n\n        pj = \"{}-journal\".format(p)\n        if not os.path.exists(pj):\n            continue\n\n        d.execute(\"create table foo (bar int)\")\n        d.execute(\"drop table foo\")\n\n    if ar.copy:\n        db.close()\n        shutil.copy2(ar.db, \"{}.bak.dbtool.{:x}\".format(ar.db, int(time.time())))\n        db = sqlite3.connect(ar.db)\n\n    for d, n in [[ds, \"src\"], [db, \"dst\"]]:\n        if not d:\n            continue\n\n        ver = read_ver(d)\n        if ver == \"corrupt\":\n            die(\"{} database appears to be corrupt, sorry\")\n\n        iver = int(ver)\n        if iver < DB_VER1 or iver > DB_VER2:\n            m = f\"{n} db is version {ver}, this tool only supports versions between {DB_VER1} and {DB_VER2}, please upgrade it with copyparty first\"\n            die(m)\n\n    if ar.ls:\n        ls(db)\n\n    if ar.cmp:\n        if not ds:\n            die(\"need src db to compare against\")\n\n        compare(\"src\", ds, \"dst\", db, ar.v)\n        compare(\"dst\", db, \"src\", ds, ar.v)\n\n    if ar.copy:\n        copy_mtp(ds, db, ar.copy, ar.rm_mtp_flag)",
    "source": "github_repo:9001/copyparty",
    "file": "bin/dbtool.py",
    "license": "MIT",
    "language": "python"
}