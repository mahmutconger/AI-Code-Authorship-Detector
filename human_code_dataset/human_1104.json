{
    "code": "class SandboxManus(ToolCallAgent):\n    \"\"\"A versatile general-purpose agent with support for both local and MCP tools.\"\"\"\n\n    name: str = \"SandboxManus\"\n    description: str = \"A versatile agent that can solve various tasks using multiple sandbox-tools including MCP-based tools\"\n\n    system_prompt: str = SYSTEM_PROMPT.format(directory=config.workspace_root)\n    next_step_prompt: str = NEXT_STEP_PROMPT\n\n    max_observe: int = 10000\n    max_steps: int = 20\n\n    # MCP clients for remote tool access\n    mcp_clients: MCPClients = Field(default_factory=MCPClients)\n\n    # Add general-purpose tools to the tool collection\n    available_tools: ToolCollection = Field(\n        default_factory=lambda: ToolCollection(\n            # PythonExecute(),\n            # BrowserUseTool(),\n            # StrReplaceEditor(),\n            AskHuman(),\n            Terminate(),\n        )\n    )\n\n    special_tool_names: list[str] = Field(default_factory=lambda: [Terminate().name])\n    browser_context_helper: Optional[BrowserContextHelper] = None\n\n    # Track connected MCP servers\n    connected_servers: Dict[str, str] = Field(\n        default_factory=dict\n    )  # server_id -> url/command\n    _initialized: bool = False\n    sandbox_link: Optional[dict[str, dict[str, str]]] = Field(default_factory=dict)\n\n    @model_validator(mode=\"after\")\n    def initialize_helper(self) -> \"SandboxManus\":\n        \"\"\"Initialize basic components synchronously.\"\"\"\n        self.browser_context_helper = BrowserContextHelper(self)\n        return self\n\n    @classmethod\n    async def create(cls, **kwargs) -> \"SandboxManus\":\n        \"\"\"Factory method to create and properly initialize a Manus instance.\"\"\"\n        instance = cls(**kwargs)\n        await instance.initialize_mcp_servers()\n        await instance.initialize_sandbox_tools()\n        instance._initialized = True\n        return instance\n\n    async def initialize_sandbox_tools(\n        self,\n        password: str = config.daytona.VNC_password,\n    ) -> None:\n        try:\n            # 创建新沙箱\n            if password:\n                sandbox = create_sandbox(password=password)\n                self.sandbox = sandbox\n            else:\n                raise ValueError(\"password must be provided\")\n            vnc_link = sandbox.get_preview_link(6080)\n            website_link = sandbox.get_preview_link(8080)\n            vnc_url = vnc_link.url if hasattr(vnc_link, \"url\") else str(vnc_link)\n            website_url = (\n                website_link.url if hasattr(website_link, \"url\") else str(website_link)\n            )\n\n            # Get the actual sandbox_id from the created sandbox\n            actual_sandbox_id = sandbox.id if hasattr(sandbox, \"id\") else \"new_sandbox\"\n            if not self.sandbox_link:\n                self.sandbox_link = {}\n            self.sandbox_link[actual_sandbox_id] = {\n                \"vnc\": vnc_url,\n                \"website\": website_url,\n            }\n            logger.info(f\"VNC URL: {vnc_url}\")\n            logger.info(f\"Website URL: {website_url}\")\n            SandboxToolsBase._urls_printed = True\n            sb_tools = [\n                SandboxBrowserTool(sandbox),\n                SandboxFilesTool(sandbox),\n                SandboxShellTool(sandbox),\n                SandboxVisionTool(sandbox),\n            ]\n            self.available_tools.add_tools(*sb_tools)\n\n        except Exception as e:\n            logger.error(f\"Error initializing sandbox tools: {e}\")\n            raise\n\n    async def initialize_mcp_servers(self) -> None:\n        \"\"\"Initialize connections to configured MCP servers.\"\"\"\n        for server_id, server_config in config.mcp_config.servers.items():\n            try:\n                if server_config.type == \"sse\":\n                    if server_config.url:\n                        await self.connect_mcp_server(server_config.url, server_id)\n                        logger.info(\n                            f\"Connected to MCP server {server_id} at {server_config.url}\"\n                        )\n                elif server_config.type == \"stdio\":\n                    if server_config.command:\n                        await self.connect_mcp_server(\n                            server_config.command,\n                            server_id,\n                            use_stdio=True,\n                            stdio_args=server_config.args,\n                        )\n                        logger.info(\n                            f\"Connected to MCP server {server_id} using command {server_config.command}\"\n                        )\n            except Exception as e:\n                logger.error(f\"Failed to connect to MCP server {server_id}: {e}\")\n\n    async def connect_mcp_server(\n        self,\n        server_url: str,\n        server_id: str = \"\",\n        use_stdio: bool = False,\n        stdio_args: List[str] = None,\n    ) -> None:\n        \"\"\"Connect to an MCP server and add its tools.\"\"\"\n        if use_stdio:\n            await self.mcp_clients.connect_stdio(\n                server_url, stdio_args or [], server_id\n            )\n            self.connected_servers[server_id or server_url] = server_url\n        else:\n            await self.mcp_clients.connect_sse(server_url, server_id)\n            self.connected_servers[server_id or server_url] = server_url\n\n        # Update available tools with only the new tools from this server\n        new_tools = [\n            tool for tool in self.mcp_clients.tools if tool.server_id == server_id\n        ]\n        self.available_tools.add_tools(*new_tools)\n\n    async def disconnect_mcp_server(self, server_id: str = \"\") -> None:\n        \"\"\"Disconnect from an MCP server and remove its tools.\"\"\"\n        await self.mcp_clients.disconnect(server_id)\n        if server_id:\n            self.connected_servers.pop(server_id, None)\n        else:\n            self.connected_servers.clear()\n\n        # Rebuild available tools without the disconnected server's tools\n        base_tools = [\n            tool\n            for tool in self.available_tools.tools\n            if not isinstance(tool, MCPClientTool)\n        ]\n        self.available_tools = ToolCollection(*base_tools)\n        self.available_tools.add_tools(*self.mcp_clients.tools)\n\n    async def delete_sandbox(self, sandbox_id: str) -> None:\n        \"\"\"Delete a sandbox by ID.\"\"\"\n        try:\n            await delete_sandbox(sandbox_id)\n            logger.info(f\"Sandbox {sandbox_id} deleted successfully\")\n            if sandbox_id in self.sandbox_link:\n                del self.sandbox_link[sandbox_id]\n        except Exception as e:\n            logger.error(f\"Error deleting sandbox {sandbox_id}: {e}\")\n            raise e\n\n    async def cleanup(self):\n        \"\"\"Clean up Manus agent resources.\"\"\"\n        if self.browser_context_helper:\n            await self.browser_context_helper.cleanup_browser()\n        # Disconnect from all MCP servers only if we were initialized\n        if self._initialized:\n            await self.disconnect_mcp_server()\n            await self.delete_sandbox(self.sandbox.id if self.sandbox else \"unknown\")\n            self._initialized = False\n\n    async def think(self) -> bool:\n        \"\"\"Process current state and decide next actions with appropriate context.\"\"\"\n        if not self._initialized:\n            await self.initialize_mcp_servers()\n            self._initialized = True\n\n        original_prompt = self.next_step_prompt\n        recent_messages = self.memory.messages[-3:] if self.memory.messages else []\n        browser_in_use = any(\n            tc.function.name == SandboxBrowserTool().name\n            for msg in recent_messages\n            if msg.tool_calls\n            for tc in msg.tool_calls\n        )\n\n        if browser_in_use:\n            self.next_step_prompt = (\n                await self.browser_context_helper.format_next_step_prompt()\n            )\n\n        result = await super().think()\n\n        # Restore original prompt\n        self.next_step_prompt = original_prompt\n\n        return result",
    "source": "github_repo:FoundationAgents/OpenManus",
    "file": "app/agent/sandbox_agent.py",
    "license": "MIT",
    "language": "python"
}