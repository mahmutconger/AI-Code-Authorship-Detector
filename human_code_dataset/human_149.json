{
    "code": "def run(\n    *,\n    host: str | None = typer.Option(None, help=\"Host to bind the server to.\", show_default=False),\n    workers: int | None = typer.Option(None, help=\"Number of worker processes.\", show_default=False),\n    worker_timeout: int | None = typer.Option(None, help=\"Worker timeout in seconds.\", show_default=False),\n    port: int | None = typer.Option(None, help=\"Port to listen on.\", show_default=False),\n    components_path: Path | None = typer.Option(\n        Path(__file__).parent / \"components\",\n        help=\"Path to the directory containing custom components.\",\n        show_default=False,\n    ),\n    # .env file param\n    env_file: Path | None = typer.Option(\n        None,\n        help=\"Path to the .env file containing environment variables.\",\n        show_default=False,\n    ),\n    log_level: str | None = typer.Option(\n        None,\n        help=\"Logging level. One of: [debug, info, warning, error, critical]. Defaults to info.\",\n        show_default=False,\n    ),\n    log_file: Path | None = typer.Option(None, help=\"Path to the log file.\", show_default=False),\n    log_rotation: str | None = typer.Option(None, help=\"Log rotation(Time/Size).\", show_default=False),\n    cache: str | None = typer.Option(  # noqa: ARG001\n        None,\n        help=\"Type of cache to use. (InMemoryCache, SQLiteCache)\",\n        show_default=False,\n    ),\n    dev: bool | None = typer.Option(None, help=\"Run in development mode (may contain bugs)\", show_default=False),  # noqa: ARG001\n    frontend_path: str | None = typer.Option(\n        None,\n        help=\"Path to the frontend directory containing build files. This is for development purposes only.\",\n        show_default=False,\n    ),\n    open_browser: bool | None = typer.Option(\n        None,\n        help=\"Open the browser after starting the server.\",\n        show_default=False,\n    ),\n    remove_api_keys: bool | None = typer.Option(  # noqa: ARG001\n        None,\n        help=\"Remove API keys from the projects saved in the database.\",\n        show_default=False,\n    ),\n    backend_only: bool | None = typer.Option(\n        None,\n        help=\"Run only the backend server without the frontend.\",\n        show_default=False,\n    ),\n    store: bool | None = typer.Option(  # noqa: ARG001\n        None,\n        help=\"Enables the store features.\",\n        show_default=False,\n    ),\n    auto_saving: bool | None = typer.Option(  # noqa: ARG001\n        None,\n        help=\"Defines if the auto save is enabled.\",\n        show_default=False,\n    ),\n    auto_saving_interval: int | None = typer.Option(  # noqa: ARG001\n        None,\n        help=\"Defines the debounce time for the auto save.\",\n        show_default=False,\n    ),\n    health_check_max_retries: bool | None = typer.Option(  # noqa: ARG001\n        None,\n        help=\"Defines the number of retries for the health check.\",\n        show_default=False,\n    ),\n    max_file_size_upload: int | None = typer.Option(  # noqa: ARG001\n        None,\n        help=\"Defines the maximum file size for the upload in MB.\",\n        show_default=False,\n    ),\n    webhook_polling_interval: int | None = typer.Option(  # noqa: ARG001\n        None,\n        help=\"Defines the polling interval for the webhook.\",\n        show_default=False,\n    ),\n    ssl_cert_file_path: str | None = typer.Option(\n        None, help=\"Defines the SSL certificate file path.\", show_default=False\n    ),\n    ssl_key_file_path: str | None = typer.Option(None, help=\"Defines the SSL key file path.\", show_default=False),\n) -> None:\n    \"\"\"Run Langflow.\"\"\"\n    if env_file:\n        if is_settings_service_initialized():\n            err = (\n                \"Settings service is already initialized. This indicates potential race conditions \"\n                \"with settings initialization. Ensure the settings service is not created during \"\n                \"module loading.\"\n            )\n            # i.e. ensures the env file is loaded before the settings service is initialized\n            raise ValueError(err)\n        load_dotenv(env_file, override=True)\n\n    # Set and normalize log level, with precedence: cli > env > default\n    log_level = (log_level or os.environ.get(\"LANGFLOW_LOG_LEVEL\") or \"info\").lower()\n    os.environ[\"LANGFLOW_LOG_LEVEL\"] = log_level\n\n    configure(log_level=log_level, log_file=log_file, log_rotation=log_rotation)\n\n    # Create progress indicator (show verbose timing if log level is DEBUG)\n    verbose = log_level == \"debug\"\n    progress = create_langflow_progress(verbose=verbose)\n\n    # Step 0: Initializing Langflow\n    with progress.step(0):\n        logger.debug(f\"Loading config from file: '{env_file}'\" if env_file else \"No env_file provided.\")\n        set_var_for_macos_issue()\n        settings_service = get_settings_service()\n\n    # Step 1: Checking Environment\n    with progress.step(1):\n        for key, value in os.environ.items():\n            new_key = key.replace(\"LANGFLOW_\", \"\")\n            if hasattr(settings_service.auth_settings, new_key):\n                setattr(settings_service.auth_settings, new_key, value)\n\n        frame = inspect.currentframe()\n        valid_args: list = []\n        values: dict = {}\n        if frame is not None:\n            arguments, _, _, values = inspect.getargvalues(frame)\n            valid_args = [arg for arg in arguments if values[arg] is not None]\n\n        for arg in valid_args:\n            if arg == \"components_path\":\n                settings_service.settings.update_settings(components_path=components_path)\n            elif hasattr(settings_service.settings, arg):\n                settings_service.set(arg, values[arg])\n            elif hasattr(settings_service.auth_settings, arg):\n                settings_service.auth_settings.set(arg, values[arg])\n            logger.debug(f\"Loading config from cli parameter '{arg}': '{values[arg]}'\")\n\n        # Get final values from settings\n        host = settings_service.settings.host\n        port = settings_service.settings.port\n        workers = settings_service.settings.workers\n        worker_timeout = settings_service.settings.worker_timeout\n        log_level = settings_service.settings.log_level\n        frontend_path = settings_service.settings.frontend_path\n        backend_only = settings_service.settings.backend_only\n        ssl_cert_file_path = (\n            settings_service.settings.ssl_cert_file if ssl_cert_file_path is None else ssl_cert_file_path\n        )\n        ssl_key_file_path = settings_service.settings.ssl_key_file if ssl_key_file_path is None else ssl_key_file_path\n\n        # create path object if frontend_path is provided\n        static_files_dir: Path | None = Path(frontend_path) if frontend_path else None\n\n    # Step 2: Starting Core Services\n    with progress.step(2):\n        app = setup_app(static_files_dir=static_files_dir, backend_only=bool(backend_only))\n\n    # Step 3: Connecting Database (this happens inside setup_app via dependencies)\n    with progress.step(3):\n        # check if port is being used\n        if is_port_in_use(port, host):\n            port = get_free_port(port)\n\n        # Store the runtime-detected port in settings (temporary until strict port enforcement)\n        get_settings_service().settings.runtime_port = port\n\n        protocol = \"https\" if ssl_cert_file_path and ssl_key_file_path else \"http\"\n\n    # Step 4: Loading Components (placeholder for components loading)\n    with progress.step(4):\n        pass  # Components are loaded during app startup\n\n    # Step 5: Adding Starter Projects (placeholder for starter projects)\n    if get_settings_service().settings.create_starter_projects:\n        with progress.step(5):\n            pass  # Starter projects are added during app startup\n\n    # Step 6: Launching Langflow\n    if platform.system() == \"Windows\":\n        with progress.step(6):\n            import uvicorn\n\n            # Print summary and banner before starting the server, since uvicorn is a blocking call.\n            # We _may_ be able to subprocess, but with window's spawn behavior, we'd have to move all\n            # non-picklable code to the subprocess.\n            progress.print_summary()\n            print_banner(str(host), int(port or 7860), protocol)\n\n        # Blocking call, so must be outside of the progress step\n        uvicorn.run(\n            app,\n            host=host,\n            port=port,\n            log_level=log_level,\n            reload=False,\n            workers=get_number_of_workers(workers),\n            loop=\"asyncio\",\n        )\n    else:\n        with progress.step(6):\n            # Use Gunicorn with LangflowUvicornWorker for non-Windows systems\n            from langflow.server import LangflowApplication\n\n            options = {\n                \"bind\": f\"{host}:{port}\",\n                \"workers\": get_number_of_workers(workers),\n                \"timeout\": worker_timeout,\n                \"certfile\": ssl_cert_file_path,\n                \"keyfile\": ssl_key_file_path,\n                \"log_level\": log_level.lower() if log_level is not None else \"info\",\n            }\n            server = LangflowApplication(app, options)\n\n            # Start the webapp process\n            process_manager.webapp_process = Process(target=server.run)\n            process_manager.webapp_process.start()\n\n            wait_for_server_ready(host, port, protocol)\n\n        # Print summary and banner after server is ready\n        progress.print_summary()\n        print_banner(str(host), int(port or 7860), protocol)\n\n        # Handle browser opening\n        if open_browser and not backend_only:\n            click.launch(f\"{protocol}://{host}:{port}\")\n\n        try:\n            process_manager.webapp_process.join()\n        except KeyboardInterrupt:\n            # SIGINT should be handled by the signal handler, but leaving here for safety\n            logger.warning(\"KeyboardInterrupt caught in main thread\")\n        finally:\n            process_manager.shutdown()",
    "source": "github_repo:langflow-ai/langflow",
    "file": "src/backend/base/langflow/__main__.py",
    "license": "MIT",
    "language": "python"
}