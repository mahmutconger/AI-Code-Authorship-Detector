{
    "code": "class Gate(nn.Module):\n    \"\"\"\n    Gating mechanism for routing inputs in a mixture-of-experts (MoE) model.\n\n    Attributes:\n        dim (int): Dimensionality of input features.\n        topk (int): Number of top experts activated for each input.\n        n_groups (int): Number of groups for routing.\n        topk_groups (int): Number of groups to route inputs to.\n        score_func (str): Scoring function ('softmax' or 'sigmoid').\n        route_scale (float): Scaling factor for routing weights.\n        weight (torch.nn.Parameter): Learnable weights for the gate.\n        bias (Optional[torch.nn.Parameter]): Optional bias term for the gate.\n    \"\"\"\n    def __init__(self, args: ModelArgs):\n        \"\"\"\n        Initializes the Gate module.\n\n        Args:\n            args (ModelArgs): Model arguments containing gating parameters.\n        \"\"\"\n        super().__init__()\n        self.dim = args.dim\n        self.topk = args.n_activated_experts\n        self.n_groups = args.n_expert_groups\n        self.topk_groups = args.n_limited_groups\n        self.score_func = args.score_func\n        self.route_scale = args.route_scale\n        self.weight = nn.Parameter(torch.empty(args.n_routed_experts, args.dim))\n        self.bias = nn.Parameter(torch.empty(args.n_routed_experts, dtype=torch.float32)) if self.dim == 7168 else None\n\n    def forward(self, x: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Forward pass for the gating mechanism.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            Tuple[torch.Tensor, torch.Tensor]: Routing weights and selected expert indices.\n        \"\"\"\n        scores = linear(x, self.weight)\n        if self.score_func == \"softmax\":\n            scores = scores.softmax(dim=-1, dtype=torch.float32)\n        else:\n            scores = scores.sigmoid()\n        original_scores = scores\n        if self.bias is not None:\n            scores = scores + self.bias\n        if self.n_groups > 1:\n            scores = scores.view(x.size(0), self.n_groups, -1)\n            if self.bias is None:\n                group_scores = scores.amax(dim=-1)\n            else:\n                group_scores = scores.topk(2, dim=-1)[0].sum(dim=-1)\n            indices = group_scores.topk(self.topk_groups, dim=-1)[1]\n            mask = scores.new_ones(x.size(0), self.n_groups, dtype=bool).scatter_(1, indices, False)\n            scores = scores.masked_fill_(mask.unsqueeze(-1), float(\"-inf\")).flatten(1)\n        indices = torch.topk(scores, self.topk, dim=-1)[1]\n        weights = original_scores.gather(1, indices)\n        if self.score_func == \"sigmoid\":\n            weights /= weights.sum(dim=-1, keepdim=True)\n        weights *= self.route_scale\n        return weights.type_as(x), indices",
    "source": "github_repo:deepseek-ai/DeepSeek-V3",
    "file": "inference/model.py",
    "license": "MIT",
    "language": "python"
}