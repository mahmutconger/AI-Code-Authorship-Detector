{
    "code": "def _convert(\n        self, *, file_stream: BinaryIO, stream_info_guesses: List[StreamInfo], **kwargs\n    ) -> DocumentConverterResult:\n        res: Union[None, DocumentConverterResult] = None\n\n        # Keep track of which converters throw exceptions\n        failed_attempts: List[FailedConversionAttempt] = []\n\n        # Create a copy of the page_converters list, sorted by priority.\n        # We do this with each call to _convert because the priority of converters may change between calls.\n        # The sort is guaranteed to be stable, so converters with the same priority will remain in the same order.\n        sorted_registrations = sorted(self._converters, key=lambda x: x.priority)\n\n        # Remember the initial stream position so that we can return to it\n        cur_pos = file_stream.tell()\n\n        for stream_info in stream_info_guesses + [StreamInfo()]:\n            for converter_registration in sorted_registrations:\n                converter = converter_registration.converter\n                # Sanity check -- make sure the cur_pos is still the same\n                assert (\n                    cur_pos == file_stream.tell()\n                ), \"File stream position should NOT change between guess iterations\"\n\n                _kwargs = {k: v for k, v in kwargs.items()}\n\n                # Copy any additional global options\n                if \"llm_client\" not in _kwargs and self._llm_client is not None:\n                    _kwargs[\"llm_client\"] = self._llm_client\n\n                if \"llm_model\" not in _kwargs and self._llm_model is not None:\n                    _kwargs[\"llm_model\"] = self._llm_model\n\n                if \"llm_prompt\" not in _kwargs and self._llm_prompt is not None:\n                    _kwargs[\"llm_prompt\"] = self._llm_prompt\n\n                if \"style_map\" not in _kwargs and self._style_map is not None:\n                    _kwargs[\"style_map\"] = self._style_map\n\n                if \"exiftool_path\" not in _kwargs and self._exiftool_path is not None:\n                    _kwargs[\"exiftool_path\"] = self._exiftool_path\n\n                # Add the list of converters for nested processing\n                _kwargs[\"_parent_converters\"] = self._converters\n\n                # Add legaxy kwargs\n                if stream_info is not None:\n                    if stream_info.extension is not None:\n                        _kwargs[\"file_extension\"] = stream_info.extension\n\n                    if stream_info.url is not None:\n                        _kwargs[\"url\"] = stream_info.url\n\n                # Check if the converter will accept the file, and if so, try to convert it\n                _accepts = False\n                try:\n                    _accepts = converter.accepts(file_stream, stream_info, **_kwargs)\n                except NotImplementedError:\n                    pass\n\n                # accept() should not have changed the file stream position\n                assert (\n                    cur_pos == file_stream.tell()\n                ), f\"{type(converter).__name__}.accept() should NOT change the file_stream position\"\n\n                # Attempt the conversion\n                if _accepts:\n                    try:\n                        res = converter.convert(file_stream, stream_info, **_kwargs)\n                    except Exception:\n                        failed_attempts.append(\n                            FailedConversionAttempt(\n                                converter=converter, exc_info=sys.exc_info()\n                            )\n                        )\n                    finally:\n                        file_stream.seek(cur_pos)\n\n                if res is not None:\n                    # Normalize the content\n                    res.text_content = \"\\n\".join(\n                        [line.rstrip() for line in re.split(r\"\\r?\\n\", res.text_content)]\n                    )\n                    res.text_content = re.sub(r\"\\n{3,}\", \"\\n\\n\", res.text_content)\n                    return res\n\n        # If we got this far without success, report any exceptions\n        if len(failed_attempts) > 0:\n            raise FileConversionException(attempts=failed_attempts)\n\n        # Nothing can handle it!\n        raise UnsupportedFormatException(\n            \"Could not convert stream to Markdown. No converter attempted a conversion, suggesting that the filetype is simply not supported.\"\n        )",
    "source": "github_repo:microsoft/markitdown",
    "file": "packages/markitdown/src/markitdown/_markitdown.py",
    "license": "MIT",
    "language": "python"
}