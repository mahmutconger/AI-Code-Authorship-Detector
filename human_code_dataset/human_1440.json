{
    "code": "class Edge:\n    \"\"\"Edge represents an edge between two nodes.\"\"\"\n\n    _default_edge_attrs = {\n        \"fontcolor\": \"#2D3436\",\n        \"fontname\": \"Sans-Serif\",\n        \"fontsize\": \"13\",\n    }\n\n    def __init__(\n        self,\n        node: \"Node\" = None,\n        forward: bool = False,\n        reverse: bool = False,\n        label: str = \"\",\n        color: str = \"\",\n        style: str = \"\",\n        **attrs: Dict,\n    ):\n        \"\"\"Edge represents an edge between two nodes.\n\n        :param node: Parent node.\n        :param forward: Points forward.\n        :param reverse: Points backward.\n        :param label: Edge label.\n        :param color: Edge color.\n        :param style: Edge style.\n        :param attrs: Other edge attributes\n        \"\"\"\n        if node is not None:\n            assert isinstance(node, Node)\n\n        self.node = node\n        self.forward = forward\n        self.reverse = reverse\n\n        self._attrs = {}\n\n        # Set attributes.\n        for k, v in self._default_edge_attrs.items():\n            self._attrs[k] = v\n\n        if label:\n            # Graphviz complaining about using label for edges, so replace it with xlabel.\n            # Update: xlabel option causes the misaligned label position:\n            # https://github.com/mingrammer/diagrams/issues/83\n            self._attrs[\"label\"] = label\n        if color:\n            self._attrs[\"color\"] = color\n        if style:\n            self._attrs[\"style\"] = style\n        self._attrs.update(attrs)\n\n    def __sub__(self, other: Union[\"Node\", \"Edge\", List[\"Node\"]]):\n        \"\"\"Implement Self - Node or Edge and Self - [Nodes]\"\"\"\n        return self.connect(other)\n\n    def __rsub__(self, other: Union[List[\"Node\"],\n                 List[\"Edge\"]]) -> List[\"Edge\"]:\n        \"\"\"Called for [Nodes] or [Edges] - Self because list don't have __sub__ operators.\"\"\"\n        return self.append(other)\n\n    def __rshift__(self, other: Union[\"Node\", \"Edge\", List[\"Node\"]]):\n        \"\"\"Implements Self >> Node or Edge and Self >> [Nodes].\"\"\"\n        self.forward = True\n        return self.connect(other)\n\n    def __lshift__(self, other: Union[\"Node\", \"Edge\", List[\"Node\"]]):\n        \"\"\"Implements Self << Node or Edge and Self << [Nodes].\"\"\"\n        self.reverse = True\n        return self.connect(other)\n\n    def __rrshift__(self,\n                    other: Union[List[\"Node\"],\n                                 List[\"Edge\"]]) -> List[\"Edge\"]:\n        \"\"\"Called for [Nodes] or [Edges] >> Self because list of Edges don't have __rshift__ operators.\"\"\"\n        return self.append(other, forward=True)\n\n    def __rlshift__(self,\n                    other: Union[List[\"Node\"],\n                                 List[\"Edge\"]]) -> List[\"Edge\"]:\n        \"\"\"Called for [Nodes] or [Edges] << Self because list of Edges don't have __lshift__ operators.\"\"\"\n        return self.append(other, reverse=True)\n\n    def append(self,\n               other: Union[List[\"Node\"],\n                            List[\"Edge\"]],\n               forward=None,\n               reverse=None) -> List[\"Edge\"]:\n        result = []\n        for o in other:\n            if isinstance(o, Edge):\n                o.forward = forward if forward else o.forward\n                o.reverse = reverse if reverse else o.reverse\n                self._attrs = o.attrs.copy()\n                result.append(o)\n            else:\n                result.append(\n                    Edge(\n                        o,\n                        forward=forward,\n                        reverse=reverse,\n                        **self._attrs))\n        return result\n\n    def connect(self, other: Union[\"Node\", \"Edge\", List[\"Node\"]]):\n        if isinstance(other, list):\n            for node in other:\n                self.node.connect(node, self)\n            return other\n        elif isinstance(other, Edge):\n            self._attrs = other._attrs.copy()\n            return self\n        else:\n            if self.node is not None:\n                return self.node.connect(other, self)\n            else:\n                self.node = other\n                return self\n\n    @property\n    def attrs(self) -> Dict:\n        if self.forward and self.reverse:\n            direction = \"both\"\n        elif self.forward:\n            direction = \"forward\"\n        elif self.reverse:\n            direction = \"back\"\n        else:\n            direction = \"none\"\n        return {**self._attrs, \"dir\": direction}",
    "source": "github_repo:mingrammer/diagrams",
    "file": "diagrams/__init__.py",
    "license": "MIT",
    "language": "python"
}