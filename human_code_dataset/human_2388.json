{
    "code": "class AudioAPI:\n    def __init__(self) -> None:\n        self.gui_config = GUIConfig()\n        self.config = None  # Initialize Config object as None\n        self.flag_vc = False\n        self.function = \"vc\"\n        self.delay_time = 0\n        self.rvc = None  # Initialize RVC object as None\n        self.inp_q = None\n        self.opt_q = None\n        self.n_cpu = min(cpu_count(), 8)\n\n    def initialize_queues(self):\n        self.inp_q = Queue()\n        self.opt_q = Queue()\n        for _ in range(self.n_cpu):\n            p = Harvest(self.inp_q, self.opt_q)\n            p.daemon = True\n            p.start()\n\n    def load(self):\n        input_devices, output_devices, _, _ = self.get_devices()\n        try:\n            with open(\"configs/config.json\", \"r\", encoding='utf-8') as j:\n                data = json.load(j)\n                if data[\"sg_input_device\"] not in input_devices:\n                    data[\"sg_input_device\"] = input_devices[sd.default.device[0]]\n                if data[\"sg_output_device\"] not in output_devices:\n                    data[\"sg_output_device\"] = output_devices[sd.default.device[1]]\n        except Exception as e:\n            logger.error(f\"Failed to load configuration: {e}\")\n            with open(\"configs/config.json\", \"w\", encoding='utf-8') as j:\n                data = {\n                    \"pth_path\": \"\",\n                    \"index_path\": \"\",\n                    \"sg_input_device\": input_devices[sd.default.device[0]],\n                    \"sg_output_device\": output_devices[sd.default.device[1]],\n                    \"threhold\": -60,\n                    \"pitch\": 0,\n                    \"formant\": 0.0,\n                    \"index_rate\": 0,\n                    \"rms_mix_rate\": 0,\n                    \"block_time\": 0.25,\n                    \"crossfade_length\": 0.05,\n                    \"extra_time\": 2.5,\n                    \"n_cpu\": 4,\n                    \"f0method\": \"fcpe\",\n                    \"use_jit\": False,\n                    \"use_pv\": False,\n                }\n                json.dump(data, j, ensure_ascii=False)\n        return data\n\n    def set_values(self, values):\n        logger.info(f\"Setting values: {values}\")\n        if not values.pth_path.strip():\n            raise HTTPException(status_code=400, detail=\"Please select a .pth file\")\n        if not values.index_path.strip():\n            raise HTTPException(status_code=400, detail=\"Please select an index file\")\n        self.set_devices(values.sg_input_device, values.sg_output_device)\n        self.config.use_jit = False\n        self.gui_config.pth_path = values.pth_path\n        self.gui_config.index_path = values.index_path\n        self.gui_config.threhold = values.threhold\n        self.gui_config.pitch = values.pitch\n        self.gui_config.formant = values.formant\n        self.gui_config.block_time = values.block_time\n        self.gui_config.crossfade_time = values.crossfade_length\n        self.gui_config.extra_time = values.extra_time\n        self.gui_config.I_noise_reduce = values.I_noise_reduce\n        self.gui_config.O_noise_reduce = values.O_noise_reduce\n        self.gui_config.rms_mix_rate = values.rms_mix_rate\n        self.gui_config.index_rate = values.index_rate\n        self.gui_config.n_cpu = values.n_cpu\n        self.gui_config.use_pv = values.use_pv\n        self.gui_config.f0method = values.f0method\n        return True\n\n    def start_vc(self):\n        torch.cuda.empty_cache()\n        self.flag_vc = True\n        self.rvc = rvc_for_realtime.RVC(\n            self.gui_config.pitch,\n            self.gui_config.pth_path,\n            self.gui_config.index_path,\n            self.gui_config.index_rate,\n            self.gui_config.n_cpu,\n            self.inp_q,\n            self.opt_q,\n            self.config,\n            self.rvc if self.rvc else None,\n        )\n        self.gui_config.samplerate = (\n            self.rvc.tgt_sr\n            if self.gui_config.sr_type == \"sr_model\"\n            else self.get_device_samplerate()\n        )\n        self.zc = self.gui_config.samplerate // 100\n        self.block_frame = (\n            int(\n                np.round(\n                    self.gui_config.block_time\n                    * self.gui_config.samplerate\n                    / self.zc\n                )\n            )\n            * self.zc\n        )\n        self.block_frame_16k = 160 * self.block_frame // self.zc\n        self.crossfade_frame = (\n            int(\n                np.round(\n                    self.gui_config.crossfade_time\n                    * self.gui_config.samplerate\n                    / self.zc\n                )\n            )\n            * self.zc\n        )\n        self.sola_buffer_frame = min(self.crossfade_frame, 4 * self.zc)\n        self.sola_search_frame = self.zc\n        self.extra_frame = (\n            int(\n                np.round(\n                    self.gui_config.extra_time\n                    * self.gui_config.samplerate\n                    / self.zc\n                )\n            )\n            * self.zc\n        )\n        self.input_wav = torch.zeros(\n            self.extra_frame\n            + self.crossfade_frame\n            + self.sola_search_frame\n            + self.block_frame,\n            device=self.config.device,\n            dtype=torch.float32,\n        )\n        self.input_wav_denoise = self.input_wav.clone()\n        self.input_wav_res = torch.zeros(\n            160 * self.input_wav.shape[0] // self.zc,\n            device=self.config.device,\n            dtype=torch.float32,\n        )\n        self.rms_buffer = np.zeros(4 * self.zc, dtype=\"float32\")\n        self.sola_buffer = torch.zeros(\n            self.sola_buffer_frame, device=self.config.device, dtype=torch.float32\n        )\n        self.nr_buffer = self.sola_buffer.clone()\n        self.output_buffer = self.input_wav.clone()\n        self.skip_head = self.extra_frame // self.zc\n        self.return_length = (\n            self.block_frame + self.sola_buffer_frame + self.sola_search_frame\n        ) // self.zc\n        self.fade_in_window = (\n            torch.sin(\n                0.5\n                * np.pi\n                * torch.linspace(\n                    0.0,\n                    1.0,\n                    steps=self.sola_buffer_frame,\n                    device=self.config.device,\n                    dtype=torch.float32,\n                )\n            )\n            ** 2\n        )\n        self.fade_out_window = 1 - self.fade_in_window\n        self.resampler = tat.Resample(\n            orig_freq=self.gui_config.samplerate,\n            new_freq=16000,\n            dtype=torch.float32,\n        ).to(self.config.device)\n        if self.rvc.tgt_sr != self.gui_config.samplerate:\n            self.resampler2 = tat.Resample(\n                orig_freq=self.rvc.tgt_sr,\n                new_freq=self.gui_config.samplerate,\n                dtype=torch.float32,\n            ).to(self.config.device)\n        else:\n            self.resampler2 = None\n        self.tg = TorchGate(\n            sr=self.gui_config.samplerate, n_fft=4 * self.zc, prop_decrease=0.9\n        ).to(self.config.device)\n        thread_vc = threading.Thread(target=self.soundinput)\n        thread_vc.start()\n\n    def soundinput(self):\n        channels = 1 if sys.platform == \"darwin\" else 2\n        with sd.Stream(\n            channels=channels,\n            callback=self.audio_callback,\n            blocksize=self.block_frame,\n            samplerate=self.gui_config.samplerate,\n            dtype=\"float32\",\n        ) as stream:\n            global stream_latency\n            stream_latency = stream.latency[-1]\n            while self.flag_vc:\n                time.sleep(self.gui_config.block_time)\n                logger.info(\"Audio block passed.\")\n        logger.info(\"Ending VC\")\n\n    def audio_callback(self, indata: np.ndarray, outdata: np.ndarray, frames, times, status):\n        start_time = time.perf_counter()\n        indata = librosa.to_mono(indata.T)\n        if self.gui_config.threhold > -60:\n            indata = np.append(self.rms_buffer, indata)\n            rms = librosa.feature.rms(y=indata, frame_length=4 * self.zc, hop_length=self.zc)[:, 2:]\n            self.rms_buffer[:] = indata[-4 * self.zc :]\n            indata = indata[2 * self.zc - self.zc // 2 :]\n            db_threhold = (\n                librosa.amplitude_to_db(rms, ref=1.0)[0] < self.gui_config.threhold\n            )\n            for i in range(db_threhold.shape[0]):\n                if db_threhold[i]:\n                    indata[i * self.zc : (i + 1) * self.zc] = 0\n            indata = indata[self.zc // 2 :]\n        self.input_wav[: -self.block_frame] = self.input_wav[self.block_frame :].clone()\n        self.input_wav[-indata.shape[0] :] = torch.from_numpy(indata).to(self.config.device)\n        self.input_wav_res[: -self.block_frame_16k] = self.input_wav_res[self.block_frame_16k :].clone()\n        # input noise reduction and resampling\n        if self.gui_config.I_noise_reduce:\n            self.input_wav_denoise[: -self.block_frame] = self.input_wav_denoise[self.block_frame :].clone()\n            input_wav = self.input_wav[-self.sola_buffer_frame - self.block_frame :]\n            input_wav = self.tg(input_wav.unsqueeze(0), self.input_wav.unsqueeze(0)).squeeze(0)\n            input_wav[: self.sola_buffer_frame] *= self.fade_in_window\n            input_wav[: self.sola_buffer_frame] += self.nr_buffer * self.fade_out_window\n            self.input_wav_denoise[-self.block_frame :] = input_wav[: self.block_frame]\n            self.nr_buffer[:] = input_wav[self.block_frame :]\n            self.input_wav_res[-self.block_frame_16k - 160 :] = self.resampler(\n                self.input_wav_denoise[-self.block_frame - 2 * self.zc :]\n            )[160:]\n        else:\n            self.input_wav_res[-160 * (indata.shape[0] // self.zc + 1) :] = (\n                self.resampler(self.input_wav[-indata.shape[0] - 2 * self.zc :])[160:]\n            )\n        # infer\n        if self.function == \"vc\":\n            infer_wav = self.rvc.infer(\n                self.input_wav_res,\n                self.block_frame_16k,\n                self.skip_head,\n                self.return_length,\n                self.gui_config.f0method,\n            )\n            if self.resampler2 is not None:\n                infer_wav = self.resampler2(infer_wav)\n        elif self.gui_config.I_noise_reduce:\n            infer_wav = self.input_wav_denoise[self.extra_frame :].clone()\n        else:\n            infer_wav = self.input_wav[self.extra_frame :].clone()\n        # output noise reduction\n        if self.gui_config.O_noise_reduce and self.function == \"vc\":\n            self.output_buffer[: -self.block_frame] = self.output_buffer[self.block_frame :].clone()\n            self.output_buffer[-self.block_frame :] = infer_wav[-self.block_frame :]\n            infer_wav = self.tg(infer_wav.unsqueeze(0), self.output_buffer.unsqueeze(0)).squeeze(0)\n        # volume envelop mixing\n        if self.gui_config.rms_mix_rate < 1 and self.function == \"vc\":\n            if self.gui_config.I_noise_reduce:\n                input_wav = self.input_wav_denoise[self.extra_frame :]\n            else:\n                input_wav = self.input_wav[self.extra_frame :]\n            rms1 = librosa.feature.rms(\n                y=input_wav[: infer_wav.shape[0]].cpu().numpy(),\n                frame_length=4 * self.zc,\n                hop_length=self.zc,\n            )\n            rms1 = torch.from_numpy(rms1).to(self.config.device)\n            rms1 = F.interpolate(\n                rms1.unsqueeze(0),\n                size=infer_wav.shape[0] + 1,\n                mode=\"linear\",\n                align_corners=True,\n            )[0, 0, :-1]\n            rms2 = librosa.feature.rms(\n                y=infer_wav[:].cpu().numpy(),\n                frame_length=4 * self.zc,\n                hop_length=self.zc,\n            )\n            rms2 = torch.from_numpy(rms2).to(self.config.device)\n            rms2 = F.interpolate(\n                rms2.unsqueeze(0),\n                size=infer_wav.shape[0] + 1,\n                mode=\"linear\",\n                align_corners=True,\n            )[0, 0, :-1]\n            rms2 = torch.max(rms2, torch.zeros_like(rms2) + 1e-3)\n            infer_wav *= torch.pow(\n                rms1 / rms2, torch.tensor(1 - self.gui_config.rms_mix_rate)\n            )\n        # SOLA algorithm from https://github.com/yxlllc/DDSP-SVC\n        conv_input = infer_wav[None, None, : self.sola_buffer_frame + self.sola_search_frame]\n        cor_nom = F.conv1d(conv_input, self.sola_buffer[None, None, :])\n        cor_den = torch.sqrt(\n            F.conv1d(\n                conv_input**2,\n                torch.ones(1, 1, self.sola_buffer_frame, device=self.config.device),\n            )\n            + 1e-8\n        )\n        if sys.platform == \"darwin\":\n            _, sola_offset = torch.max(cor_nom[0, 0] / cor_den[0, 0])\n            sola_offset = sola_offset.item()\n        else:\n            sola_offset = torch.argmax(cor_nom[0, 0] / cor_den[0, 0])\n        logger.info(f\"sola_offset = {sola_offset}\")\n        infer_wav = infer_wav[sola_offset:]\n        if \"privateuseone\" in str(self.config.device) or not self.gui_config.use_pv:\n            infer_wav[: self.sola_buffer_frame] *= self.fade_in_window\n            infer_wav[: self.sola_buffer_frame] += self.sola_buffer * self.fade_out_window\n        else:\n            infer_wav[: self.sola_buffer_frame] = phase_vocoder(\n                self.sola_buffer,\n                infer_wav[: self.sola_buffer_frame],\n                self.fade_out_window,\n                self.fade_in_window,\n            )\n        self.sola_buffer[:] = infer_wav[\n            self.block_frame : self.block_frame + self.sola_buffer_frame\n        ]\n        if sys.platform == \"darwin\":\n            outdata[:] = infer_wav[: self.block_frame].cpu().numpy()[:, np.newaxis]\n        else:\n            outdata[:] = infer_wav[: self.block_frame].repeat(2, 1).t().cpu().numpy()\n        total_time = time.perf_counter() - start_time\n        logger.info(f\"Infer time: {total_time:.2f}\")\n\n    def get_devices(self, update: bool = True):\n        if update:\n            sd._terminate()\n            sd._initialize()\n        devices = sd.query_devices()\n        hostapis = sd.query_hostapis()\n        for hostapi in hostapis:\n            for device_idx in hostapi[\"devices\"]:\n                devices[device_idx][\"hostapi_name\"] = hostapi[\"name\"]\n        input_devices = [\n            f\"{d['name']} ({d['hostapi_name']})\"\n            for d in devices\n            if d[\"max_input_channels\"] > 0\n        ]\n        output_devices = [\n            f\"{d['name']} ({d['hostapi_name']})\"\n            for d in devices\n            if d[\"max_output_channels\"] > 0\n        ]\n        input_devices_indices = [\n            d[\"index\"] if \"index\" in d else d[\"name\"]\n            for d in devices\n            if d[\"max_input_channels\"] > 0\n        ]\n        output_devices_indices = [\n            d[\"index\"] if \"index\" in d else d[\"name\"]\n            for d in devices\n            if d[\"max_output_channels\"] > 0\n        ]\n        return (\n            input_devices,\n            output_devices,\n            input_devices_indices,\n            output_devices_indices,\n        )\n\n    def set_devices(self, input_device, output_device):\n        (\n            input_devices,\n            output_devices,\n            input_device_indices,\n            output_device_indices,\n        ) = self.get_devices()\n        logger.debug(f\"Available input devices: {input_devices}\")\n        logger.debug(f\"Available output devices: {output_devices}\")\n        logger.debug(f\"Selected input device: {input_device}\")\n        logger.debug(f\"Selected output device: {output_device}\")\n\n        if input_device not in input_devices:\n            logger.error(f\"Input device '{input_device}' is not in the list of available devices\")\n            raise HTTPException(status_code=400, detail=f\"Input device '{input_device}' is not available\")\n        \n        if output_device not in output_devices:\n            logger.error(f\"Output device '{output_device}' is not in the list of available devices\")\n            raise HTTPException(status_code=400, detail=f\"Output device '{output_device}' is not available\")\n\n        sd.default.device[0] = input_device_indices[input_devices.index(input_device)]\n        sd.default.device[1] = output_device_indices[output_devices.index(output_device)]\n        logger.info(f\"Input device set to {sd.default.device[0]}: {input_device}\")\n        logger.info(f\"Output device set to {sd.default.device[1]}: {output_device}\")",
    "source": "github_repo:RVC-Project/Retrieval-based-Voice-Conversion-WebUI",
    "file": "api_240604.py",
    "license": "MIT",
    "language": "python"
}