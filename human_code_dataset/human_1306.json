{
    "code": "class DoclingParseV2PageBackend(PdfPageBackend):\n    def __init__(\n        self, parser: pdf_parser_v2, document_hash: str, page_no: int, page_obj: PdfPage\n    ):\n        self._ppage = page_obj\n        parsed_page = parser.parse_pdf_from_key_on_page(document_hash, page_no)\n\n        self.valid = \"pages\" in parsed_page and len(parsed_page[\"pages\"]) == 1\n        if self.valid:\n            self._dpage = parsed_page[\"pages\"][0]\n        else:\n            _log.info(\n                f\"An error occurred when loading page {page_no} of document {document_hash}.\"\n            )\n\n    def is_valid(self) -> bool:\n        return self.valid\n\n    def _compute_text_cells(self) -> List[TextCell]:\n        \"\"\"Compute text cells from docling-parse v2 data.\"\"\"\n        cells: List[TextCell] = []\n        cell_counter = 0\n\n        if not self.valid:\n            return cells\n\n        page_size = self.get_size()\n\n        parser_width = self._dpage[\"sanitized\"][\"dimension\"][\"width\"]\n        parser_height = self._dpage[\"sanitized\"][\"dimension\"][\"height\"]\n\n        cells_data = self._dpage[\"sanitized\"][\"cells\"][\"data\"]\n        cells_header = self._dpage[\"sanitized\"][\"cells\"][\"header\"]\n\n        for i, cell_data in enumerate(cells_data):\n            x0 = cell_data[cells_header.index(\"x0\")]\n            y0 = cell_data[cells_header.index(\"y0\")]\n            x1 = cell_data[cells_header.index(\"x1\")]\n            y1 = cell_data[cells_header.index(\"y1\")]\n\n            if x1 < x0:\n                x0, x1 = x1, x0\n            if y1 < y0:\n                y0, y1 = y1, y0\n\n            text_piece = cell_data[cells_header.index(\"text\")]\n            cells.append(\n                TextCell(\n                    index=cell_counter,\n                    text=text_piece,\n                    orig=text_piece,\n                    from_ocr=False,\n                    rect=BoundingRectangle.from_bounding_box(\n                        BoundingBox(\n                            l=x0 * page_size.width / parser_width,\n                            b=y0 * page_size.height / parser_height,\n                            r=x1 * page_size.width / parser_width,\n                            t=y1 * page_size.height / parser_height,\n                            coord_origin=CoordOrigin.BOTTOMLEFT,\n                        )\n                    ).to_top_left_origin(page_size.height),\n                )\n            )\n            cell_counter += 1\n\n        return cells\n\n    def get_text_in_rect(self, bbox: BoundingBox) -> str:\n        if not self.valid:\n            return \"\"\n        # Find intersecting cells on the page\n        text_piece = \"\"\n        page_size = self.get_size()\n\n        parser_width = self._dpage[\"sanitized\"][\"dimension\"][\"width\"]\n        parser_height = self._dpage[\"sanitized\"][\"dimension\"][\"height\"]\n\n        scale = (\n            1  # FIX - Replace with param in get_text_in_rect across backends (optional)\n        )\n\n        cells_data = self._dpage[\"sanitized\"][\"cells\"][\"data\"]\n        cells_header = self._dpage[\"sanitized\"][\"cells\"][\"header\"]\n\n        for i, cell_data in enumerate(cells_data):\n            x0 = cell_data[cells_header.index(\"x0\")]\n            y0 = cell_data[cells_header.index(\"y0\")]\n            x1 = cell_data[cells_header.index(\"x1\")]\n            y1 = cell_data[cells_header.index(\"y1\")]\n\n            cell_bbox = BoundingBox(\n                l=x0 * scale * page_size.width / parser_width,\n                b=y0 * scale * page_size.height / parser_height,\n                r=x1 * scale * page_size.width / parser_width,\n                t=y1 * scale * page_size.height / parser_height,\n                coord_origin=CoordOrigin.BOTTOMLEFT,\n            ).to_top_left_origin(page_height=page_size.height * scale)\n\n            overlap_frac = cell_bbox.intersection_over_self(bbox)\n\n            if overlap_frac > 0.5:\n                if len(text_piece) > 0:\n                    text_piece += \" \"\n                text_piece += cell_data[cells_header.index(\"text\")]\n\n        return text_piece\n\n    def get_segmented_page(self) -> Optional[SegmentedPdfPage]:\n        if not self.valid:\n            return None\n\n        text_cells = self._compute_text_cells()\n\n        # Get the PDF page geometry from pypdfium2\n        dimension = get_pdf_page_geometry(self._ppage)\n\n        # Create SegmentedPdfPage\n        return SegmentedPdfPage(\n            dimension=dimension,\n            textline_cells=text_cells,\n            char_cells=[],\n            word_cells=[],\n            has_textlines=len(text_cells) > 0,\n            has_words=False,\n            has_chars=False,\n        )\n\n    def get_text_cells(self) -> Iterable[TextCell]:\n        return self._compute_text_cells()\n\n    def get_bitmap_rects(self, scale: float = 1) -> Iterable[BoundingBox]:\n        AREA_THRESHOLD = 0  # 32 * 32\n\n        images = self._dpage[\"sanitized\"][\"images\"][\"data\"]\n        images_header = self._dpage[\"sanitized\"][\"images\"][\"header\"]\n\n        for row in images:\n            x0 = row[images_header.index(\"x0\")]\n            y0 = row[images_header.index(\"y0\")]\n            x1 = row[images_header.index(\"x1\")]\n            y1 = row[images_header.index(\"y1\")]\n\n            cropbox = BoundingBox.from_tuple(\n                (x0, y0, x1, y1), origin=CoordOrigin.BOTTOMLEFT\n            ).to_top_left_origin(self.get_size().height)\n\n            if cropbox.area() > AREA_THRESHOLD:\n                cropbox = cropbox.scaled(scale=scale)\n\n                yield cropbox\n\n    def get_page_image(\n        self, scale: float = 1, cropbox: Optional[BoundingBox] = None\n    ) -> Image.Image:\n        page_size = self.get_size()\n\n        if not cropbox:\n            cropbox = BoundingBox(\n                l=0,\n                r=page_size.width,\n                t=0,\n                b=page_size.height,\n                coord_origin=CoordOrigin.TOPLEFT,\n            )\n            padbox = BoundingBox(\n                l=0, r=0, t=0, b=0, coord_origin=CoordOrigin.BOTTOMLEFT\n            )\n        else:\n            padbox = cropbox.to_bottom_left_origin(page_size.height).model_copy()\n            padbox.r = page_size.width - padbox.r\n            padbox.t = page_size.height - padbox.t\n\n        with pypdfium2_lock:\n            image = (\n                self._ppage.render(\n                    scale=scale * 1.5,\n                    rotation=0,  # no additional rotation\n                    crop=padbox.as_tuple(),\n                )\n                .to_pil()\n                .resize(\n                    size=(round(cropbox.width * scale), round(cropbox.height * scale))\n                )\n            )  # We resize the image from 1.5x the given scale to make it sharper.\n\n        return image\n\n    def get_size(self) -> Size:\n        with pypdfium2_lock:\n            return Size(width=self._ppage.get_width(), height=self._ppage.get_height())\n\n    def unload(self):\n        self._ppage = None\n        self._dpage = None",
    "source": "github_repo:docling-project/docling",
    "file": "docling/backend/docling_parse_v2_backend.py",
    "license": "MIT",
    "language": "python"
}