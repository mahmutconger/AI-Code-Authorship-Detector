{
    "code": "\"\"\"Script to update Langflow starter projects with the latest component versions.\"\"\"\n\nimport asyncio\nimport os\n\nimport langflow.main  # noqa: F401\nfrom langflow.initial_setup.setup import (\n    get_project_data,\n    load_starter_projects,\n    update_edges_with_latest_component_versions,\n    update_project_file,\n    update_projects_components_with_latest_component_versions,\n)\nfrom langflow.services.utils import initialize_services\nfrom lfx.interface.components import get_and_cache_all_types_dict\nfrom lfx.services.deps import get_settings_service\n\n\nasync def main():\n    \"\"\"Updates the starter projects with the latest component versions.\n\n    Copies the code from langflow/initial_setup/setup.py. Doesn't use the\n    create_or_update_starter_projects function directly to avoid sql interactions.\n    \"\"\"\n    await initialize_services(fix_migration=False)\n    all_types_dict = await get_and_cache_all_types_dict(get_settings_service())\n\n    starter_projects = await load_starter_projects()\n    for project_path, project in starter_projects:\n        _, _, _, _, project_data, _, _, _, _ = get_project_data(project)\n        do_update_starter_projects = os.environ.get(\"LANGFLOW_UPDATE_STARTER_PROJECTS\", \"true\").lower() == \"true\"\n        if do_update_starter_projects:\n            updated_project_data = update_projects_components_with_latest_component_versions(\n                project_data.copy(), all_types_dict\n            )\n            updated_project_data = update_edges_with_latest_component_versions(updated_project_data)\n            if updated_project_data != project_data:\n                project_data = updated_project_data\n                await update_project_file(project_path, project, updated_project_data)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())",
    "source": "github_repo:langflow-ai/langflow",
    "file": "scripts/ci/update_starter_projects.py",
    "license": "MIT",
    "language": "python"
}