{
    "code": "def request(self, method, url, hooks=None, *args, **kwargs):\n        \"\"\"Request URL.\n\n        This extends the FuturesSession request method to calculate a response\n        time metric to each request.\n\n        It is taken (almost) directly from the following Stack Overflow answer:\n        https://github.com/ross/requests-futures#working-in-the-background\n\n        Keyword Arguments:\n        self                   -- This object.\n        method                 -- String containing method desired for request.\n        url                    -- String containing URL for request.\n        hooks                  -- Dictionary containing hooks to execute after\n                                  request finishes.\n        args                   -- Arguments.\n        kwargs                 -- Keyword arguments.\n\n        Return Value:\n        Request object.\n        \"\"\"\n        # Record the start time for the request.\n        if hooks is None:\n            hooks = {}\n        start = monotonic()\n\n        def response_time(resp, *args, **kwargs):\n            \"\"\"Response Time Hook.\n\n            Keyword Arguments:\n            resp                   -- Response object.\n            args                   -- Arguments.\n            kwargs                 -- Keyword arguments.\n\n            Return Value:\n            Nothing.\n            \"\"\"\n            resp.elapsed = monotonic() - start\n\n            return\n\n        # Install hook to execute when response completes.\n        # Make sure that the time measurement hook is first, so we will not\n        # track any later hook's execution time.\n        try:\n            if isinstance(hooks[\"response\"], list):\n                hooks[\"response\"].insert(0, response_time)\n            elif isinstance(hooks[\"response\"], tuple):\n                # Convert tuple to list and insert time measurement hook first.\n                hooks[\"response\"] = list(hooks[\"response\"])\n                hooks[\"response\"].insert(0, response_time)\n            else:\n                # Must have previously contained a single hook function,\n                # so convert to list.\n                hooks[\"response\"] = [response_time, hooks[\"response\"]]\n        except KeyError:\n            # No response hook was already defined, so install it ourselves.\n            hooks[\"response\"] = [response_time]\n\n        return super(SherlockFuturesSession, self).request(\n            method, url, hooks=hooks, *args, **kwargs\n        )",
    "source": "github_repo:sherlock-project/sherlock",
    "file": "sherlock_project/sherlock.py",
    "license": "MIT",
    "language": "python"
}