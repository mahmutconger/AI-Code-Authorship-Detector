{
    "code": "class AudioAPI:\n    def __init__(self) -> None:\n        self.gui_config = GUIConfig()\n        self.config = None  # Initialize Config object as None\n        self.flag_vc = False\n        self.function = \"vc\"\n        self.delay_time = 0\n        self.rvc = None  # Initialize RVC object as None\n\n    def load(self):\n        input_devices, output_devices, _, _ = self.get_devices()\n        try:\n            with open(\"configs/config.json\", \"r\", encoding='utf-8') as j:\n                data = json.load(j)\n                data[\"rmvpe\"] = True  # Ensure rmvpe is the only f0method\n                if data[\"sg_input_device\"] not in input_devices:\n                    data[\"sg_input_device\"] = input_devices[sd.default.device[0]]\n                if data[\"sg_output_device\"] not in output_devices:\n                    data[\"sg_output_device\"] = output_devices[sd.default.device[1]]\n        except Exception as e:\n            logger.error(f\"Failed to load configuration: {e}\")\n            with open(\"configs/config.json\", \"w\", encoding='utf-8') as j:\n                data = {\n                    \"pth_path\": \" \",\n                    \"index_path\": \" \",\n                    \"sg_input_device\": input_devices[sd.default.device[0]],\n                    \"sg_output_device\": output_devices[sd.default.device[1]],\n                    \"threhold\": \"-60\",\n                    \"pitch\": \"0\",\n                    \"index_rate\": \"0\",\n                    \"rms_mix_rate\": \"0\",\n                    \"block_time\": \"0.25\",\n                    \"crossfade_length\": \"0.05\",\n                    \"extra_time\": \"2.5\",\n                    \"f0method\": \"rmvpe\",\n                    \"use_jit\": False,\n                }\n                data[\"rmvpe\"] = True  # Ensure rmvpe is the only f0method\n                json.dump(data, j, ensure_ascii=False)\n        return data\n\n    def set_values(self, values):\n        logger.info(f\"Setting values: {values}\")\n        if not values.pth_path.strip():\n            raise HTTPException(status_code=400, detail=\"Please select a .pth file\")\n        if not values.index_path.strip():\n            raise HTTPException(status_code=400, detail=\"Please select an index file\")\n        self.set_devices(values.sg_input_device, values.sg_output_device)\n        self.config.use_jit = False\n        self.gui_config.pth_path = values.pth_path\n        self.gui_config.index_path = values.index_path\n        self.gui_config.threhold = values.threhold\n        self.gui_config.pitch = values.pitch\n        self.gui_config.block_time = values.block_time\n        self.gui_config.crossfade_time = values.crossfade_length\n        self.gui_config.extra_time = values.extra_time\n        self.gui_config.I_noise_reduce = values.I_noise_reduce\n        self.gui_config.O_noise_reduce = values.O_noise_reduce\n        self.gui_config.rms_mix_rate = values.rms_mix_rate\n        self.gui_config.index_rate = values.index_rate\n        self.gui_config.n_cpu = values.n_cpu\n        self.gui_config.f0method = \"rmvpe\"\n        return True\n\n    def start_vc(self):\n        torch.cuda.empty_cache()\n        self.flag_vc = True\n        self.rvc = rvc_for_realtime.RVC(\n            self.gui_config.pitch,\n            self.gui_config.pth_path,\n            self.gui_config.index_path,\n            self.gui_config.index_rate,\n            0,\n            0,\n            0,\n            self.config,\n            self.rvc if self.rvc else None,\n        )\n        self.gui_config.samplerate = self.rvc.tgt_sr\n        self.zc = self.rvc.tgt_sr // 100\n        self.block_frame = (\n            int(\n                np.round(\n                    self.gui_config.block_time\n                    * self.gui_config.samplerate\n                    / self.zc\n                )\n            )\n            * self.zc\n        )\n        self.block_frame_16k = 160 * self.block_frame // self.zc\n        self.crossfade_frame = (\n            int(\n                np.round(\n                    self.gui_config.crossfade_time\n                    * self.gui_config.samplerate\n                    / self.zc\n                )\n            )\n            * self.zc\n        )\n        self.sola_search_frame = self.zc\n        self.extra_frame = (\n            int(\n                np.round(\n                    self.gui_config.extra_time\n                    * self.gui_config.samplerate\n                    / self.zc\n                )\n            )\n            * self.zc\n        )\n        self.input_wav = torch.zeros(\n            self.extra_frame + self.crossfade_frame + self.sola_search_frame + self.block_frame,\n            device=self.config.device,\n            dtype=torch.float32,\n        )\n        self.input_wav_res = torch.zeros(\n            160 * self.input_wav.shape[0] // self.zc,\n            device=self.config.device,\n            dtype=torch.float32,\n        )\n        self.pitch = np.zeros(self.input_wav.shape[0] // self.zc, dtype=\"int32\")\n        self.pitchf = np.zeros(self.input_wav.shape[0] // self.zc, dtype=\"float64\")\n        self.sola_buffer = torch.zeros(self.crossfade_frame, device=self.config.device, dtype=torch.float32)\n        self.nr_buffer = self.sola_buffer.clone()\n        self.output_buffer = self.input_wav.clone()\n        self.res_buffer = torch.zeros(2 * self.zc, device=self.config.device, dtype=torch.float32)\n        self.valid_rate = 1 - (self.extra_frame - 1) / self.input_wav.shape[0]\n        self.fade_in_window = (\n            torch.sin(0.5 * np.pi * torch.linspace(0.0, 1.0, steps=self.crossfade_frame, device=self.config.device, dtype=torch.float32)) ** 2\n        )\n        self.fade_out_window = 1 - self.fade_in_window\n        self.resampler = tat.Resample(\n            orig_freq=self.gui_config.samplerate,\n            new_freq=16000,\n            dtype=torch.float32,\n        ).to(self.config.device)\n        self.tg = TorchGate(\n            sr=self.gui_config.samplerate, n_fft=4 * self.zc, prop_decrease=0.9\n        ).to(self.config.device)\n        thread_vc = threading.Thread(target=self.soundinput)\n        thread_vc.start()\n\n    def soundinput(self):\n        channels = 1 if sys.platform == \"darwin\" else 2\n        with sd.Stream(\n            channels=channels,\n            callback=self.audio_callback,\n            blocksize=self.block_frame,\n            samplerate=self.gui_config.samplerate,\n            dtype=\"float32\",\n        ) as stream:\n            global stream_latency\n            stream_latency = stream.latency[-1]\n            while self.flag_vc:\n                time.sleep(self.gui_config.block_time)\n                logger.info(\"Audio block passed.\")\n        logger.info(\"Ending VC\")\n\n    def audio_callback(self, indata: np.ndarray, outdata: np.ndarray, frames, times, status):\n        start_time = time.perf_counter()\n        indata = librosa.to_mono(indata.T)\n        if self.gui_config.threhold > -60:\n            rms = librosa.feature.rms(y=indata, frame_length=4 * self.zc, hop_length=self.zc)\n            db_threhold = (librosa.amplitude_to_db(rms, ref=1.0)[0] < self.gui_config.threhold)\n            for i in range(db_threhold.shape[0]):\n                if db_threhold[i]:\n                    indata[i * self.zc : (i + 1) * self.zc] = 0\n        self.input_wav[: -self.block_frame] = self.input_wav[self.block_frame :].clone()\n        self.input_wav[-self.block_frame :] = torch.from_numpy(indata).to(self.config.device)\n        self.input_wav_res[: -self.block_frame_16k] = self.input_wav_res[self.block_frame_16k :].clone()\n        if self.gui_config.I_noise_reduce and self.function == \"vc\":\n            input_wav = self.input_wav[-self.crossfade_frame - self.block_frame - 2 * self.zc :]\n            input_wav = self.tg(input_wav.unsqueeze(0), self.input_wav.unsqueeze(0))[0, 2 * self.zc :]\n            input_wav[: self.crossfade_frame] *= self.fade_in_window\n            input_wav[: self.crossfade_frame] += self.nr_buffer * self.fade_out_window\n            self.nr_buffer[:] = input_wav[-self.crossfade_frame :]\n            input_wav = torch.cat((self.res_buffer[:], input_wav[: self.block_frame]))\n            self.res_buffer[:] = input_wav[-2 * self.zc :]\n            self.input_wav_res[-self.block_frame_16k - 160 :] = self.resampler(input_wav)[160:]\n        else:\n            self.input_wav_res[-self.block_frame_16k - 160 :] = self.resampler(self.input_wav[-self.block_frame - 2 * self.zc :])[160:]\n        if self.function == \"vc\":\n            f0_extractor_frame = self.block_frame_16k + 800\n            if self.gui_config.f0method == \"rmvpe\":\n                f0_extractor_frame = (5120 * ((f0_extractor_frame - 1) // 5120 + 1) - 160)\n            infer_wav = self.rvc.infer(\n                self.input_wav_res,\n                self.input_wav_res[-f0_extractor_frame:].cpu().numpy(),\n                self.block_frame_16k,\n                self.valid_rate,\n                self.pitch,\n                self.pitchf,\n                self.gui_config.f0method,\n            )\n            infer_wav = infer_wav[-self.crossfade_frame - self.sola_search_frame - self.block_frame :]\n        else:\n            infer_wav = self.input_wav[-self.crossfade_frame - self.sola_search_frame - self.block_frame :].clone()\n        if (self.gui_config.O_noise_reduce and self.function == \"vc\") or (self.gui_config.I_noise_reduce and self.function == \"im\"):\n            self.output_buffer[: -self.block_frame] = self.output_buffer[self.block_frame :].clone()\n            self.output_buffer[-self.block_frame :] = infer_wav[-self.block_frame :]\n            infer_wav = self.tg(infer_wav.unsqueeze(0), self.output_buffer.unsqueeze(0)).squeeze(0)\n        if self.gui_config.rms_mix_rate < 1 and self.function == \"vc\":\n            rms1 = librosa.feature.rms(y=self.input_wav_res[-160 * infer_wav.shape[0] // self.zc :].cpu().numpy(), frame_length=640, hop_length=160)\n            rms1 = torch.from_numpy(rms1).to(self.config.device)\n            rms1 = F.interpolate(rms1.unsqueeze(0), size=infer_wav.shape[0] + 1, mode=\"linear\", align_corners=True)[0, 0, :-1]\n            rms2 = librosa.feature.rms(y=infer_wav[:].cpu().numpy(), frame_length=4 * self.zc, hop_length=self.zc)\n            rms2 = torch.from_numpy(rms2).to(self.config.device)\n            rms2 = F.interpolate(rms2.unsqueeze(0), size=infer_wav.shape[0] + 1, mode=\"linear\", align_corners=True)[0, 0, :-1]\n            rms2 = torch.max(rms2, torch.zeros_like(rms2) + 1e-3)\n            infer_wav *= torch.pow(rms1 / rms2, torch.tensor(1 - self.gui_config.rms_mix_rate))\n        conv_input = infer_wav[None, None, : self.crossfade_frame + self.sola_search_frame]\n        cor_nom = F.conv1d(conv_input, self.sola_buffer[None, None, :])\n        cor_den = torch.sqrt(F.conv1d(conv_input**2, torch.ones(1, 1, self.crossfade_frame, device=self.config.device)) + 1e-8)\n        if sys.platform == \"darwin\":\n            _, sola_offset = torch.max(cor_nom[0, 0] / cor_den[0, 0])\n            sola_offset = sola_offset.item()\n        else:\n            sola_offset = torch.argmax(cor_nom[0, 0] / cor_den[0, 0])\n        logger.info(f\"sola_offset = {sola_offset}\")\n        infer_wav = infer_wav[sola_offset : sola_offset + self.block_frame + self.crossfade_frame]\n        infer_wav[: self.crossfade_frame] *= self.fade_in_window\n        infer_wav[: self.crossfade_frame] += self.sola_buffer * self.fade_out_window\n        self.sola_buffer[:] = infer_wav[-self.crossfade_frame :]\n        if sys.platform == \"darwin\":\n            outdata[:] = infer_wav[: -self.crossfade_frame].cpu().numpy()[:, np.newaxis]\n        else:\n            outdata[:] = infer_wav[: -self.crossfade_frame].repeat(2, 1).t().cpu().numpy()\n        total_time = time.perf_counter() - start_time\n        logger.info(f\"Infer time: {total_time:.2f}\")\n\n    def get_devices(self, update: bool = True):\n        if update:\n            sd._terminate()\n            sd._initialize()\n        devices = sd.query_devices()\n        hostapis = sd.query_hostapis()\n        for hostapi in hostapis:\n            for device_idx in hostapi[\"devices\"]:\n                devices[device_idx][\"hostapi_name\"] = hostapi[\"name\"]\n        input_devices = [\n            f\"{d['name']} ({d['hostapi_name']})\"\n            for d in devices\n            if d[\"max_input_channels\"] > 0\n        ]\n        output_devices = [\n            f\"{d['name']} ({d['hostapi_name']})\"\n            for d in devices\n            if d[\"max_output_channels\"] > 0\n        ]\n        input_devices_indices = [\n            d[\"index\"] if \"index\" in d else d[\"name\"]\n            for d in devices\n            if d[\"max_input_channels\"] > 0\n        ]\n        output_devices_indices = [\n            d[\"index\"] if \"index\" in d else d[\"name\"]\n            for d in devices\n            if d[\"max_output_channels\"] > 0\n        ]\n        return (\n            input_devices,\n            output_devices,\n            input_devices_indices,\n            output_devices_indices,\n        )\n\n    def set_devices(self, input_device, output_device):\n        (\n            input_devices,\n            output_devices,\n            input_device_indices,\n            output_device_indices,\n        ) = self.get_devices()\n        logger.debug(f\"Available input devices: {input_devices}\")\n        logger.debug(f\"Available output devices: {output_devices}\")\n        logger.debug(f\"Selected input device: {input_device}\")\n        logger.debug(f\"Selected output device: {output_device}\")\n\n        if input_device not in input_devices:\n            logger.error(f\"Input device '{input_device}' is not in the list of available devices\")\n            raise HTTPException(status_code=400, detail=f\"Input device '{input_device}' is not available\")\n        \n        if output_device not in output_devices:\n            logger.error(f\"Output device '{output_device}' is not in the list of available devices\")\n            raise HTTPException(status_code=400, detail=f\"Output device '{output_device}' is not available\")\n\n        sd.default.device[0] = input_device_indices[input_devices.index(input_device)]\n        sd.default.device[1] = output_device_indices[output_devices.index(output_device)]\n        logger.info(f\"Input device set to {sd.default.device[0]}: {input_device}\")\n        logger.info(f\"Output device set to {sd.default.device[1]}: {output_device}\")",
    "source": "github_repo:RVC-Project/Retrieval-based-Voice-Conversion-WebUI",
    "file": "api_231006.py",
    "license": "MIT",
    "language": "python"
}