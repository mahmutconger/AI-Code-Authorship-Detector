{
    "code": "class CsvDocumentBackend(DeclarativeDocumentBackend):\n    content: StringIO\n\n    def __init__(self, in_doc: \"InputDocument\", path_or_stream: Union[BytesIO, Path]):\n        super().__init__(in_doc, path_or_stream)\n\n        # Load content\n        try:\n            if isinstance(self.path_or_stream, BytesIO):\n                self.content = StringIO(self.path_or_stream.getvalue().decode(\"utf-8\"))\n            elif isinstance(self.path_or_stream, Path):\n                self.content = StringIO(self.path_or_stream.read_text(\"utf-8\"))\n            self.valid = True\n        except Exception as e:\n            raise RuntimeError(\n                f\"CsvDocumentBackend could not load document with hash {self.document_hash}\"\n            ) from e\n        return\n\n    def is_valid(self) -> bool:\n        return self.valid\n\n    @classmethod\n    def supports_pagination(cls) -> bool:\n        return False\n\n    def unload(self):\n        if isinstance(self.path_or_stream, BytesIO):\n            self.path_or_stream.close()\n        self.path_or_stream = None\n\n    @classmethod\n    def supported_formats(cls) -> Set[InputFormat]:\n        return {InputFormat.CSV}\n\n    def convert(self) -> DoclingDocument:\n        \"\"\"\n        Parses the CSV data into a structured document model.\n        \"\"\"\n\n        # Detect CSV dialect\n        head = self.content.readline()\n        dialect = csv.Sniffer().sniff(head, \",;\\t|:\")\n        _log.info(f'Parsing CSV with delimiter: \"{dialect.delimiter}\"')\n        if dialect.delimiter not in {\",\", \";\", \"\\t\", \"|\", \":\"}:\n            raise RuntimeError(\n                f\"Cannot convert csv with unknown delimiter {dialect.delimiter}.\"\n            )\n\n        # Parce CSV\n        self.content.seek(0)\n        result = csv.reader(self.content, dialect=dialect, strict=True)\n        self.csv_data = list(result)\n        _log.info(f\"Detected {len(self.csv_data)} lines\")\n\n        # Ensure uniform column length\n        expected_length = len(self.csv_data[0])\n        is_uniform = all(len(row) == expected_length for row in self.csv_data)\n        if not is_uniform:\n            warnings.warn(\n                f\"Inconsistent column lengths detected in CSV data. \"\n                f\"Expected {expected_length} columns, but found rows with varying lengths. \"\n                f\"Ensure all rows have the same number of columns.\"\n            )\n\n        # Parse the CSV into a structured document model\n        origin = DocumentOrigin(\n            filename=self.file.name or \"file.csv\",\n            mimetype=\"text/csv\",\n            binary_hash=self.document_hash,\n        )\n\n        doc = DoclingDocument(name=self.file.stem or \"file.csv\", origin=origin)\n\n        if self.is_valid():\n            # Convert CSV data to table\n            if self.csv_data:\n                num_rows = len(self.csv_data)\n                num_cols = max(len(row) for row in self.csv_data)\n\n                table_data = TableData(\n                    num_rows=num_rows,\n                    num_cols=num_cols,\n                    table_cells=[],\n                )\n\n                # Convert each cell to TableCell\n                for row_idx, row in enumerate(self.csv_data):\n                    for col_idx, cell_value in enumerate(row):\n                        cell = TableCell(\n                            text=str(cell_value),\n                            row_span=1,  # CSV doesn't support merged cells\n                            col_span=1,\n                            start_row_offset_idx=row_idx,\n                            end_row_offset_idx=row_idx + 1,\n                            start_col_offset_idx=col_idx,\n                            end_col_offset_idx=col_idx + 1,\n                            column_header=row_idx == 0,  # First row as header\n                            row_header=False,\n                        )\n                        table_data.table_cells.append(cell)\n\n                doc.add_table(data=table_data)\n        else:\n            raise RuntimeError(\n                f\"Cannot convert doc with {self.document_hash} because the backend failed to init.\"\n            )\n\n        return doc",
    "source": "github_repo:docling-project/docling",
    "file": "docling/backend/csv_backend.py",
    "license": "MIT",
    "language": "python"
}