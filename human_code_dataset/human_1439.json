{
    "code": "class Node:\n    \"\"\"Node represents a node for a specific backend service.\"\"\"\n\n    _provider = None\n    _type = None\n\n    _icon_dir = None\n    _icon = None\n\n    _height = 1.9\n\n    def __init__(self, label: str = \"\", *, nodeid: str = None, **attrs: Dict):\n        \"\"\"Node represents a system component.\n\n        :param label: Node label.\n        \"\"\"\n        # Generates an ID for identifying a node, unless specified\n        self._id = nodeid or self._rand_id()\n        self.label = label\n\n        # Node must be belong to a diagrams.\n        self._diagram = getdiagram()\n        if self._diagram is None:\n            raise EnvironmentError(\"Global diagrams context not set up\")\n\n        if self._diagram.autolabel:\n            prefix = self.__class__.__name__\n            if self.label:\n                self.label = prefix + \"\\n\" + self.label\n            else:\n                self.label = prefix\n\n        # fmt: off\n        # If a node has an icon, increase the height slightly to avoid\n        # that label being spanned between icon image and white space.\n        # Increase the height by the number of new lines included in the label.\n        padding = 0.4 * (self.label.count('\\n'))\n        self._attrs = {\n            \"shape\": \"none\",\n            \"height\": str(self._height + padding),\n            \"image\": self._load_icon(),\n        } if self._icon else {}\n\n        # fmt: on\n        self._attrs.update(attrs)\n\n        self._cluster = getcluster()\n\n        # If a node is in the cluster context, add it to cluster.\n        if self._cluster:\n            self._cluster.node(self._id, self.label, **self._attrs)\n        else:\n            self._diagram.node(self._id, self.label, **self._attrs)\n\n    def __repr__(self):\n        _name = self.__class__.__name__\n        return f\"<{self._provider}.{self._type}.{_name}>\"\n\n    def __sub__(self, other: Union[\"Node\", List[\"Node\"], \"Edge\"]):\n        \"\"\"Implement Self - Node, Self - [Nodes] and Self - Edge.\"\"\"\n        if isinstance(other, list):\n            for node in other:\n                self.connect(node, Edge(self))\n            return other\n        elif isinstance(other, Node):\n            return self.connect(other, Edge(self))\n        else:\n            other.node = self\n            return other\n\n    def __rsub__(self, other: Union[List[\"Node\"], List[\"Edge\"]]):\n        \"\"\"Called for [Nodes] and [Edges] - Self because list don't have __sub__ operators.\"\"\"\n        for o in other:\n            if isinstance(o, Edge):\n                o.connect(self)\n            else:\n                o.connect(self, Edge(self))\n        return self\n\n    def __rshift__(self, other: Union[\"Node\", List[\"Node\"], \"Edge\"]):\n        \"\"\"Implements Self >> Node, Self >> [Nodes] and Self Edge.\"\"\"\n        if isinstance(other, list):\n            for node in other:\n                self.connect(node, Edge(self, forward=True))\n            return other\n        elif isinstance(other, Node):\n            return self.connect(other, Edge(self, forward=True))\n        else:\n            other.forward = True\n            other.node = self\n            return other\n\n    def __lshift__(self, other: Union[\"Node\", List[\"Node\"], \"Edge\"]):\n        \"\"\"Implements Self << Node, Self << [Nodes] and Self << Edge.\"\"\"\n        if isinstance(other, list):\n            for node in other:\n                self.connect(node, Edge(self, reverse=True))\n            return other\n        elif isinstance(other, Node):\n            return self.connect(other, Edge(self, reverse=True))\n        else:\n            other.reverse = True\n            return other.connect(self)\n\n    def __rrshift__(self, other: Union[List[\"Node\"], List[\"Edge\"]]):\n        \"\"\"Called for [Nodes] and [Edges] >> Self because list don't have __rshift__ operators.\"\"\"\n        for o in other:\n            if isinstance(o, Edge):\n                o.forward = True\n                o.connect(self)\n            else:\n                o.connect(self, Edge(self, forward=True))\n        return self\n\n    def __rlshift__(self, other: Union[List[\"Node\"], List[\"Edge\"]]):\n        \"\"\"Called for [Nodes] << Self because list of Nodes don't have __lshift__ operators.\"\"\"\n        for o in other:\n            if isinstance(o, Edge):\n                o.reverse = True\n                o.connect(self)\n            else:\n                o.connect(self, Edge(self, reverse=True))\n        return self\n\n    @property\n    def nodeid(self):\n        return self._id\n\n    # TODO: option for adding flow description to the connection edge\n    def connect(self, node: \"Node\", edge: \"Edge\"):\n        \"\"\"Connect to other node.\n\n        :param node: Other node instance.\n        :param edge: Type of the edge.\n        :return: Connected node.\n        \"\"\"\n        if not isinstance(node, Node):\n            ValueError(f\"{node} is not a valid Node\")\n        if not isinstance(edge, Edge):\n            ValueError(f\"{edge} is not a valid Edge\")\n        # An edge must be added on the global diagrams, not a cluster.\n        self._diagram.connect(self, node, edge)\n        return node\n\n    @staticmethod\n    def _rand_id():\n        return uuid.uuid4().hex\n\n    def _load_icon(self):\n        basedir = Path(os.path.abspath(os.path.dirname(__file__)))\n        return os.path.join(basedir.parent, self._icon_dir, self._icon)",
    "source": "github_repo:mingrammer/diagrams",
    "file": "diagrams/__init__.py",
    "license": "MIT",
    "language": "python"
}