{
    "code": "class ToolCallAgent(ReActAgent):\n    \"\"\"Base agent class for handling tool/function calls with enhanced abstraction\"\"\"\n\n    name: str = \"toolcall\"\n    description: str = \"an agent that can execute tool calls.\"\n\n    system_prompt: str = SYSTEM_PROMPT\n    next_step_prompt: str = NEXT_STEP_PROMPT\n\n    available_tools: ToolCollection = ToolCollection(\n        CreateChatCompletion(), Terminate()\n    )\n    tool_choices: TOOL_CHOICE_TYPE = ToolChoice.AUTO  # type: ignore\n    special_tool_names: List[str] = Field(default_factory=lambda: [Terminate().name])\n\n    tool_calls: List[ToolCall] = Field(default_factory=list)\n    _current_base64_image: Optional[str] = None\n\n    max_steps: int = 30\n    max_observe: Optional[Union[int, bool]] = None\n\n    async def think(self) -> bool:\n        \"\"\"Process current state and decide next actions using tools\"\"\"\n        if self.next_step_prompt:\n            user_msg = Message.user_message(self.next_step_prompt)\n            self.messages += [user_msg]\n\n        try:\n            # Get response with tool options\n            response = await self.llm.ask_tool(\n                messages=self.messages,\n                system_msgs=(\n                    [Message.system_message(self.system_prompt)]\n                    if self.system_prompt\n                    else None\n                ),\n                tools=self.available_tools.to_params(),\n                tool_choice=self.tool_choices,\n            )\n        except ValueError:\n            raise\n        except Exception as e:\n            # Check if this is a RetryError containing TokenLimitExceeded\n            if hasattr(e, \"__cause__\") and isinstance(e.__cause__, TokenLimitExceeded):\n                token_limit_error = e.__cause__\n                logger.error(\n                    f\"ðŸš¨ Token limit error (from RetryError): {token_limit_error}\"\n                )\n                self.memory.add_message(\n                    Message.assistant_message(\n                        f\"Maximum token limit reached, cannot continue execution: {str(token_limit_error)}\"\n                    )\n                )\n                self.state = AgentState.FINISHED\n                return False\n            raise\n\n        self.tool_calls = tool_calls = (\n            response.tool_calls if response and response.tool_calls else []\n        )\n        content = response.content if response and response.content else \"\"\n\n        # Log response info\n        logger.info(f\"âœ¨ {self.name}'s thoughts: {content}\")\n        logger.info(\n            f\"ðŸ› ï¸ {self.name} selected {len(tool_calls) if tool_calls else 0} tools to use\"\n        )\n        if tool_calls:\n            logger.info(\n                f\"ðŸ§° Tools being prepared: {[call.function.name for call in tool_calls]}\"\n            )\n            logger.info(f\"ðŸ”§ Tool arguments: {tool_calls[0].function.arguments}\")\n\n        try:\n            if response is None:\n                raise RuntimeError(\"No response received from the LLM\")\n\n            # Handle different tool_choices modes\n            if self.tool_choices == ToolChoice.NONE:\n                if tool_calls:\n                    logger.warning(\n                        f\"ðŸ¤” Hmm, {self.name} tried to use tools when they weren't available!\"\n                    )\n                if content:\n                    self.memory.add_message(Message.assistant_message(content))\n                    return True\n                return False\n\n            # Create and add assistant message\n            assistant_msg = (\n                Message.from_tool_calls(content=content, tool_calls=self.tool_calls)\n                if self.tool_calls\n                else Message.assistant_message(content)\n            )\n            self.memory.add_message(assistant_msg)\n\n            if self.tool_choices == ToolChoice.REQUIRED and not self.tool_calls:\n                return True  # Will be handled in act()\n\n            # For 'auto' mode, continue with content if no commands but content exists\n            if self.tool_choices == ToolChoice.AUTO and not self.tool_calls:\n                return bool(content)\n\n            return bool(self.tool_calls)\n        except Exception as e:\n            logger.error(f\"ðŸš¨ Oops! The {self.name}'s thinking process hit a snag: {e}\")\n            self.memory.add_message(\n                Message.assistant_message(\n                    f\"Error encountered while processing: {str(e)}\"\n                )\n            )\n            return False\n\n    async def act(self) -> str:\n        \"\"\"Execute tool calls and handle their results\"\"\"\n        if not self.tool_calls:\n            if self.tool_choices == ToolChoice.REQUIRED:\n                raise ValueError(TOOL_CALL_REQUIRED)\n\n            # Return last message content if no tool calls\n            return self.messages[-1].content or \"No content or commands to execute\"\n\n        results = []\n        for command in self.tool_calls:\n            # Reset base64_image for each tool call\n            self._current_base64_image = None\n\n            result = await self.execute_tool(command)\n\n            if self.max_observe:\n                result = result[: self.max_observe]\n\n            logger.info(\n                f\"ðŸŽ¯ Tool '{command.function.name}' completed its mission! Result: {result}\"\n            )\n\n            # Add tool response to memory\n            tool_msg = Message.tool_message(\n                content=result,\n                tool_call_id=command.id,\n                name=command.function.name,\n                base64_image=self._current_base64_image,\n            )\n            self.memory.add_message(tool_msg)\n            results.append(result)\n\n        return \"\\n\\n\".join(results)\n\n    async def execute_tool(self, command: ToolCall) -> str:\n        \"\"\"Execute a single tool call with robust error handling\"\"\"\n        if not command or not command.function or not command.function.name:\n            return \"Error: Invalid command format\"\n\n        name = command.function.name\n        if name not in self.available_tools.tool_map:\n            return f\"Error: Unknown tool '{name}'\"\n\n        try:\n            # Parse arguments\n            args = json.loads(command.function.arguments or \"{}\")\n\n            # Execute the tool\n            logger.info(f\"ðŸ”§ Activating tool: '{name}'...\")\n            result = await self.available_tools.execute(name=name, tool_input=args)\n\n            # Handle special tools\n            await self._handle_special_tool(name=name, result=result)\n\n            # Check if result is a ToolResult with base64_image\n            if hasattr(result, \"base64_image\") and result.base64_image:\n                # Store the base64_image for later use in tool_message\n                self._current_base64_image = result.base64_image\n\n            # Format result for display (standard case)\n            observation = (\n                f\"Observed output of cmd `{name}` executed:\\n{str(result)}\"\n                if result\n                else f\"Cmd `{name}` completed with no output\"\n            )\n\n            return observation\n        except json.JSONDecodeError:\n            error_msg = f\"Error parsing arguments for {name}: Invalid JSON format\"\n            logger.error(\n                f\"ðŸ“ Oops! The arguments for '{name}' don't make sense - invalid JSON, arguments:{command.function.arguments}\"\n            )\n            return f\"Error: {error_msg}\"\n        except Exception as e:\n            error_msg = f\"âš ï¸ Tool '{name}' encountered a problem: {str(e)}\"\n            logger.exception(error_msg)\n            return f\"Error: {error_msg}\"\n\n    async def _handle_special_tool(self, name: str, result: Any, **kwargs):\n        \"\"\"Handle special tool execution and state changes\"\"\"\n        if not self._is_special_tool(name):\n            return\n\n        if self._should_finish_execution(name=name, result=result, **kwargs):\n            # Set agent state to finished\n            logger.info(f\"ðŸ Special tool '{name}' has completed the task!\")\n            self.state = AgentState.FINISHED\n\n    @staticmethod\n    def _should_finish_execution(**kwargs) -> bool:\n        \"\"\"Determine if tool execution should finish the agent\"\"\"\n        return True\n\n    def _is_special_tool(self, name: str) -> bool:\n        \"\"\"Check if tool name is in special tools list\"\"\"\n        return name.lower() in [n.lower() for n in self.special_tool_names]\n\n    async def cleanup(self):\n        \"\"\"Clean up resources used by the agent's tools.\"\"\"\n        logger.info(f\"ðŸ§¹ Cleaning up resources for agent '{self.name}'...\")\n        for tool_name, tool_instance in self.available_tools.tool_map.items():\n            if hasattr(tool_instance, \"cleanup\") and asyncio.iscoroutinefunction(\n                tool_instance.cleanup\n            ):\n                try:\n                    logger.debug(f\"ðŸ§¼ Cleaning up tool: {tool_name}\")\n                    await tool_instance.cleanup()\n                except Exception as e:\n                    logger.error(\n                        f\"ðŸš¨ Error cleaning up tool '{tool_name}': {e}\", exc_info=True\n                    )\n        logger.info(f\"âœ¨ Cleanup complete for agent '{self.name}'.\")\n\n    async def run(self, request: Optional[str] = None) -> str:\n        \"\"\"Run the agent with cleanup when done.\"\"\"\n        try:\n            return await super().run(request)\n        finally:\n            await self.cleanup()",
    "source": "github_repo:FoundationAgents/OpenManus",
    "file": "app/agent/toolcall.py",
    "license": "MIT",
    "language": "python"
}