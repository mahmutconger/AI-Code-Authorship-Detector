{
    "code": "class TexTransformExample(Scene):\n    def construct(self):\n        # Tex to color map\n        t2c = {\n            \"A\": BLUE,\n            \"B\": TEAL,\n            \"C\": GREEN,\n        }\n        # Configuration to pass along to each Tex mobject\n        kw = dict(font_size=72, t2c=t2c)\n        lines = VGroup(\n            Tex(\"A^2 + B^2 = C^2\", **kw),\n            Tex(\"A^2 = C^2 - B^2\", **kw),\n            Tex(\"A^2 = (C + B)(C - B)\", **kw),\n            Tex(R\"A = \\sqrt{(C + B)(C - B)}\", **kw),\n        )\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n\n        self.add(lines[0])\n        # The animation TransformMatchingStrings will line up parts\n        # of the source and target which have matching substring strings.\n        # Here, giving it a little path_arc makes each part rotate into\n        # their final positions, which feels appropriate for the idea of\n        # rearranging an equation\n        self.play(\n            TransformMatchingStrings(\n                lines[0].copy(), lines[1],\n                # matched_keys specifies which substring should\n                # line up. If it's not specified, the animation\n                # will align the longest matching substrings.\n                # In this case, the substring \"^2 = C^2\" would\n                # trip it up\n                matched_keys=[\"A^2\", \"B^2\", \"C^2\"],\n                # When you want a substring from the source\n                # to go to a non-equal substring from the target,\n                # use the key map.\n                key_map={\"+\": \"-\"},\n                path_arc=90 * DEG,\n            ),\n        )\n        self.wait()\n        self.play(TransformMatchingStrings(\n            lines[1].copy(), lines[2],\n            matched_keys=[\"A^2\"]\n        ))\n        self.wait()\n        self.play(\n            TransformMatchingStrings(\n                lines[2].copy(), lines[3],\n                key_map={\"2\": R\"\\sqrt\"},\n                path_arc=-30 * DEG,\n            ),\n        )\n        self.wait(2)\n        self.play(LaggedStartMap(FadeOut, lines, shift=2 * RIGHT))\n\n        # TransformMatchingShapes will try to line up all pieces of a\n        # source mobject with those of a target, regardless of the\n        # what Mobject type they are.\n        source = Text(\"the morse code\", height=1)\n        target = Text(\"here come dots\", height=1)\n        saved_source = source.copy()\n\n        self.play(Write(source))\n        self.wait()\n        kw = dict(run_time=3, path_arc=PI / 2)\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, saved_source, **kw))\n        self.wait()",
    "source": "github_repo:3b1b/manim",
    "file": "example_scenes.py",
    "license": "MIT",
    "language": "python"
}