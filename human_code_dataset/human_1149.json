{
    "code": "def merge_json_files(existing_path: Path, new_content: dict, verbose: bool = False) -> dict:\n    \"\"\"Merge new JSON content into existing JSON file.\n\n    Performs a deep merge where:\n    - New keys are added\n    - Existing keys are preserved unless overwritten by new content\n    - Nested dictionaries are merged recursively\n    - Lists and other values are replaced (not merged)\n\n    Args:\n        existing_path: Path to existing JSON file\n        new_content: New JSON content to merge in\n        verbose: Whether to print merge details\n\n    Returns:\n        Merged JSON content as dict\n    \"\"\"\n    try:\n        with open(existing_path, 'r', encoding='utf-8') as f:\n            existing_content = json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        # If file doesn't exist or is invalid, just use new content\n        return new_content\n\n    def deep_merge(base: dict, update: dict) -> dict:\n        \"\"\"Recursively merge update dict into base dict.\"\"\"\n        result = base.copy()\n        for key, value in update.items():\n            if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n                # Recursively merge nested dictionaries\n                result[key] = deep_merge(result[key], value)\n            else:\n                # Add new key or replace existing value\n                result[key] = value\n        return result\n\n    merged = deep_merge(existing_content, new_content)\n\n    if verbose:\n        console.print(f\"[cyan]Merged JSON file:[/cyan] {existing_path.name}\")\n\n    return merged",
    "source": "github_repo:github/spec-kit",
    "file": "src/specify_cli/__init__.py",
    "license": "MIT",
    "language": "python"
}