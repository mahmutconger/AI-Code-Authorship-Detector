{
    "code": "def build_component_index():\n    \"\"\"Build the component index by scanning all modules in lfx.components.\n\n    Returns:\n        A dictionary containing version, entries, and sha256 hash\n    \"\"\"\n    print(\"Building component index...\")\n\n    # Use the existing import_langflow_components function\n    try:\n        import asyncio\n\n        from lfx.interface.components import import_langflow_components\n\n        # Run the async function\n        components_result = asyncio.run(import_langflow_components())\n        modules_dict = components_result.get(\"components\", {})\n        components_count = sum(len(v) for v in modules_dict.values())\n        print(f\"Discovered {components_count} components across {len(modules_dict)} categories\")\n\n        # Convert modules_dict to entries format and sort for determinism\n        # Sort by category name (top_level) to ensure consistent ordering\n        entries = []\n        for category_name in sorted(modules_dict.keys()):\n            # Sort components within each category by component name\n            components_dict = modules_dict[category_name]\n            sorted_components = {comp_name: components_dict[comp_name] for comp_name in sorted(components_dict.keys())}\n            entries.append([category_name, sorted_components])\n\n    except (ImportError, AttributeError) as e:\n        print(f\"Failed to import components: {e}\", file=sys.stderr)\n        return None\n\n    # Build the index structure\n    index = {\n        \"version\": _get_langflow_version(),\n        \"metadata\": {\n            \"num_modules\": len(modules_dict),\n            \"num_components\": components_count,\n        },\n        \"entries\": entries,\n    }\n\n    # Normalize the entire structure for deterministic output\n    index = _normalize_for_determinism(index)\n\n    # Calculate hash for integrity verification\n    # Note: We calculate hash without the sha256 field itself\n    # orjson.dumps returns bytes and handles Enums automatically\n    # OPT_SORT_KEYS ensures consistent key ordering in the final JSON\n    payload = orjson.dumps(index, option=orjson.OPT_SORT_KEYS)\n    index[\"sha256\"] = hashlib.sha256(payload).hexdigest()\n\n    return index",
    "source": "github_repo:langflow-ai/langflow",
    "file": "scripts/build_component_index.py",
    "license": "MIT",
    "language": "python"
}