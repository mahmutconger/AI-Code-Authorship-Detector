{
    "code": "def forward(self, x: torch.Tensor, start_pos: int, freqs_cis: torch.Tensor, mask: Optional[torch.Tensor]):\n        \"\"\"\n        Forward pass for the Multi-Head Latent Attention (MLA) Layer.\n\n        Args:\n            x (torch.Tensor): Input tensor of shape (batch_size, seq_len, dim).\n            start_pos (int): Starting position in the sequence for caching.\n            freqs_cis (torch.Tensor): Precomputed complex exponential values for rotary embeddings.\n            mask (Optional[torch.Tensor]): Mask tensor to exclude certain positions from attention.\n\n        Returns:\n            torch.Tensor: Output tensor with the same shape as the input.\n        \"\"\"\n        bsz, seqlen, _ = x.size()\n        end_pos = start_pos + seqlen\n        if self.q_lora_rank == 0:\n            q = self.wq(x)\n        else:\n            q = self.wq_b(self.q_norm(self.wq_a(x)))\n        q = q.view(bsz, seqlen, self.n_local_heads, self.qk_head_dim)\n        q_nope, q_pe = torch.split(q, [self.qk_nope_head_dim, self.qk_rope_head_dim], dim=-1)\n        q_pe = apply_rotary_emb(q_pe, freqs_cis)\n        kv = self.wkv_a(x)\n        kv, k_pe = torch.split(kv, [self.kv_lora_rank, self.qk_rope_head_dim], dim=-1)\n        k_pe = apply_rotary_emb(k_pe.unsqueeze(2), freqs_cis)\n        if attn_impl == \"naive\":\n            q = torch.cat([q_nope, q_pe], dim=-1)\n            kv = self.wkv_b(self.kv_norm(kv))\n            kv = kv.view(bsz, seqlen, self.n_local_heads, self.qk_nope_head_dim + self.v_head_dim)\n            k_nope, v = torch.split(kv, [self.qk_nope_head_dim, self.v_head_dim], dim=-1)\n            k = torch.cat([k_nope, k_pe.expand(-1, -1, self.n_local_heads, -1)], dim=-1)\n            self.k_cache[:bsz, start_pos:end_pos] = k\n            self.v_cache[:bsz, start_pos:end_pos] = v\n            scores = torch.einsum(\"bshd,bthd->bsht\", q, self.k_cache[:bsz, :end_pos]) * self.softmax_scale\n        else:\n            wkv_b = self.wkv_b.weight if self.wkv_b.scale is None else weight_dequant(self.wkv_b.weight, self.wkv_b.scale, block_size) \n            wkv_b = wkv_b.view(self.n_local_heads, -1, self.kv_lora_rank)\n            q_nope = torch.einsum(\"bshd,hdc->bshc\", q_nope, wkv_b[:, :self.qk_nope_head_dim])\n            self.kv_cache[:bsz, start_pos:end_pos] = self.kv_norm(kv)\n            self.pe_cache[:bsz, start_pos:end_pos] = k_pe.squeeze(2)\n            scores = (torch.einsum(\"bshc,btc->bsht\", q_nope, self.kv_cache[:bsz, :end_pos]) +\n                      torch.einsum(\"bshr,btr->bsht\", q_pe, self.pe_cache[:bsz, :end_pos])) * self.softmax_scale\n        if mask is not None:\n            scores += mask.unsqueeze(1)\n        scores = scores.softmax(dim=-1, dtype=torch.float32).type_as(x)\n        if attn_impl == \"naive\":\n            x = torch.einsum(\"bsht,bthd->bshd\", scores, self.v_cache[:bsz, :end_pos])\n        else:\n            x = torch.einsum(\"bsht,btc->bshc\", scores, self.kv_cache[:bsz, :end_pos])\n            x = torch.einsum(\"bshc,hdc->bshd\", x, wkv_b[:, -self.v_head_dim:])\n        x = self.wo(x.flatten(2))\n        return x",
    "source": "github_repo:deepseek-ai/DeepSeek-V3",
    "file": "inference/model.py",
    "license": "MIT",
    "language": "python"
}