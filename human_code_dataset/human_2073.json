{
    "code": "def initialize(self, dictionary=None):\n        if dictionary:\n            abs_path = _get_abs_path(dictionary)\n            if self.dictionary == abs_path and self.initialized:\n                return\n            else:\n                self.dictionary = abs_path\n                self.initialized = False\n        else:\n            abs_path = self.dictionary\n\n        with self.lock:\n            try:\n                with DICT_WRITING[abs_path]:\n                    pass\n            except KeyError:\n                pass\n            if self.initialized:\n                return\n\n            default_logger.debug(\"Building prefix dict from %s ...\" % (abs_path or 'the default dictionary'))\n            t1 = time.time()\n            if self.cache_file:\n                cache_file = self.cache_file\n            # default dictionary\n            elif abs_path == DEFAULT_DICT:\n                cache_file = \"jieba.cache\"\n            # custom dictionary\n            else:\n                cache_file = \"jieba.u%s.cache\" % md5(\n                    abs_path.encode('utf-8', 'replace')).hexdigest()\n            cache_file = os.path.join(\n                self.tmp_dir or tempfile.gettempdir(), cache_file)\n            # prevent absolute path in self.cache_file\n            tmpdir = os.path.dirname(cache_file)\n\n            load_from_cache_fail = True\n            if os.path.isfile(cache_file) and (abs_path == DEFAULT_DICT or\n                                               os.path.getmtime(cache_file) > os.path.getmtime(abs_path)):\n                default_logger.debug(\n                    \"Loading model from cache %s\" % cache_file)\n                try:\n                    with open(cache_file, 'rb') as cf:\n                        self.FREQ, self.total = marshal.load(cf)\n                    load_from_cache_fail = False\n                except Exception:\n                    load_from_cache_fail = True\n\n            if load_from_cache_fail:\n                wlock = DICT_WRITING.get(abs_path, threading.RLock())\n                DICT_WRITING[abs_path] = wlock\n                with wlock:\n                    self.FREQ, self.total = self.gen_pfdict(self.get_dict_file())\n                    default_logger.debug(\n                        \"Dumping model to file cache %s\" % cache_file)\n                    try:\n                        # prevent moving across different filesystems\n                        fd, fpath = tempfile.mkstemp(dir=tmpdir)\n                        with os.fdopen(fd, 'wb') as temp_cache_file:\n                            marshal.dump(\n                                (self.FREQ, self.total), temp_cache_file)\n                        _replace_file(fpath, cache_file)\n                    except Exception:\n                        default_logger.exception(\"Dump cache file failed.\")\n\n                try:\n                    del DICT_WRITING[abs_path]\n                except KeyError:\n                    pass\n\n            self.initialized = True\n            default_logger.debug(\n                \"Loading model cost %.3f seconds.\" % (time.time() - t1))\n            default_logger.debug(\"Prefix dict has been built successfully.\")",
    "source": "github_repo:fxsjy/jieba",
    "file": "jieba/__init__.py",
    "license": "MIT",
    "language": "python"
}