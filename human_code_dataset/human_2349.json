{
    "code": "def set_scalers(self, df):\n        \"\"\"Calibrates scalers using the data supplied.\n\n        Args:\n          df: Data to use to calibrate scalers.\n        \"\"\"\n        print(\"Setting scalers with training data...\")\n\n        column_definitions = self.get_column_definition()\n        id_column = utils.get_single_col_by_input_type(InputTypes.ID, column_definitions)\n        target_column = utils.get_single_col_by_input_type(InputTypes.TARGET, column_definitions)\n\n        # Extract identifiers in case required\n        self.identifiers = list(df[id_column].unique())\n\n        # Format real scalers\n        real_inputs = utils.extract_cols_from_data_type(\n            DataTypes.REAL_VALUED, column_definitions, {InputTypes.ID, InputTypes.TIME}\n        )\n\n        data = df[real_inputs].values\n        self._real_scalers = sklearn.preprocessing.StandardScaler().fit(data)\n        self._target_scaler = sklearn.preprocessing.StandardScaler().fit(\n            df[[target_column]].values\n        )  # used for predictions\n\n        # Format categorical scalers\n        categorical_inputs = utils.extract_cols_from_data_type(\n            DataTypes.CATEGORICAL, column_definitions, {InputTypes.ID, InputTypes.TIME}\n        )\n\n        categorical_scalers = {}\n        num_classes = []\n        for col in categorical_inputs:\n            # Set all to str so that we don't have mixed integer/string columns\n            srs = df[col].apply(str)\n            categorical_scalers[col] = sklearn.preprocessing.LabelEncoder().fit(srs.values)\n            num_classes.append(srs.nunique())\n\n        # Set categorical scaler outputs\n        self._cat_scalers = categorical_scalers\n        self._num_classes_per_cat_input = num_classes",
    "source": "github_repo:microsoft/qlib",
    "file": "examples/benchmarks/TFT/data_formatters/qlib_Alpha158.py",
    "license": "MIT",
    "language": "python"
}