{
    "code": "def download_single_file(index):\n    \"\"\" Downloads a single file index, with some backoff \"\"\"\n\n    # Construct the local filepath for this file and skip if it already exists\n    filename = index_to_filename(index)\n    filepath = os.path.join(DATA_DIR, filename)\n    if os.path.exists(filepath):\n        print(f\"Skipping {filepath} (already exists)\")\n        return True\n\n    # Construct the remote URL for this file\n    url = f\"{BASE_URL}/{filename}\"\n    print(f\"Downloading {filename}...\")\n\n    # Download with retries\n    max_attempts = 5\n    for attempt in range(1, max_attempts + 1):\n        try:\n            response = requests.get(url, stream=True, timeout=30)\n            response.raise_for_status()\n            # Write to temporary file first\n            temp_path = filepath + f\".tmp\"\n            with open(temp_path, 'wb') as f:\n                for chunk in response.iter_content(chunk_size=1024 * 1024):  # 1MB chunks\n                    if chunk:\n                        f.write(chunk)\n            # Move temp file to final location\n            os.rename(temp_path, filepath)\n            print(f\"Successfully downloaded {filename}\")\n            return True\n\n        except (requests.RequestException, IOError) as e:\n            print(f\"Attempt {attempt}/{max_attempts} failed for {filename}: {e}\")\n            # Clean up any partial files\n            for path in [filepath + f\".tmp\", filepath]:\n                if os.path.exists(path):\n                    try:\n                        os.remove(path)\n                    except:\n                        pass\n            # Try a few times with exponential backoff: 2^attempt seconds\n            if attempt < max_attempts:\n                wait_time = 2 ** attempt\n                print(f\"Waiting {wait_time} seconds before retry...\")\n                time.sleep(wait_time)\n            else:\n                print(f\"Failed to download {filename} after {max_attempts} attempts\")\n                return False\n\n    return False",
    "source": "github_repo:karpathy/nanochat",
    "file": "nanochat/dataset.py",
    "license": "MIT",
    "language": "python"
}