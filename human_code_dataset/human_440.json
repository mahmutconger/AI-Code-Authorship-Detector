{
    "code": "def convert_response(\n        self,\n        response: requests.Response,\n        *,\n        stream_info: Optional[StreamInfo] = None,\n        file_extension: Optional[str] = None,  # Deprecated -- use stream_info\n        url: Optional[str] = None,  # Deprecated -- use stream_info\n        **kwargs: Any,\n    ) -> DocumentConverterResult:\n        # If there is a content-type header, get the mimetype and charset (if present)\n        mimetype: Optional[str] = None\n        charset: Optional[str] = None\n\n        if \"content-type\" in response.headers:\n            parts = response.headers[\"content-type\"].split(\";\")\n            mimetype = parts.pop(0).strip()\n            for part in parts:\n                if part.strip().startswith(\"charset=\"):\n                    _charset = part.split(\"=\")[1].strip()\n                    if len(_charset) > 0:\n                        charset = _charset\n\n        # If there is a content-disposition header, get the filename and possibly the extension\n        filename: Optional[str] = None\n        extension: Optional[str] = None\n        if \"content-disposition\" in response.headers:\n            m = re.search(r\"filename=([^;]+)\", response.headers[\"content-disposition\"])\n            if m:\n                filename = m.group(1).strip(\"\\\"'\")\n                _, _extension = os.path.splitext(filename)\n                if len(_extension) > 0:\n                    extension = _extension\n\n        # If there is still no filename, try to read it from the url\n        if filename is None:\n            parsed_url = urlparse(response.url)\n            _, _extension = os.path.splitext(parsed_url.path)\n            if len(_extension) > 0:  # Looks like this might be a file!\n                filename = os.path.basename(parsed_url.path)\n                extension = _extension\n\n        # Create an initial guess from all this information\n        base_guess = StreamInfo(\n            mimetype=mimetype,\n            charset=charset,\n            filename=filename,\n            extension=extension,\n            url=response.url,\n        )\n\n        # Update with any additional info from the arguments\n        if stream_info is not None:\n            base_guess = base_guess.copy_and_update(stream_info)\n        if file_extension is not None:\n            # Deprecated -- use stream_info\n            base_guess = base_guess.copy_and_update(extension=file_extension)\n        if url is not None:\n            # Deprecated -- use stream_info\n            base_guess = base_guess.copy_and_update(url=url)\n\n        # Read into BytesIO\n        buffer = io.BytesIO()\n        for chunk in response.iter_content(chunk_size=512):\n            buffer.write(chunk)\n        buffer.seek(0)\n\n        # Convert\n        guesses = self._get_stream_info_guesses(\n            file_stream=buffer, base_guess=base_guess\n        )\n        return self._convert(file_stream=buffer, stream_info_guesses=guesses, **kwargs)",
    "source": "github_repo:microsoft/markitdown",
    "file": "packages/markitdown/src/markitdown/_markitdown.py",
    "license": "MIT",
    "language": "python"
}