{
    "code": "class GenericDataFormatter(abc.ABC):\n    \"\"\"Abstract base class for all data formatters.\n\n    User can implement the abstract methods below to perform dataset-specific\n    manipulations.\n\n    \"\"\"\n\n    @abc.abstractmethod\n    def set_scalers(self, df):\n        \"\"\"Calibrates scalers using the data supplied.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def transform_inputs(self, df):\n        \"\"\"Performs feature transformation.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def format_predictions(self, df):\n        \"\"\"Reverts any normalisation to give predictions in original scale.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def split_data(self, df):\n        \"\"\"Performs the default train, validation and test splits.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    @abc.abstractmethod\n    def _column_definition(self):\n        \"\"\"Defines order, input type and data type of each column.\"\"\"\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def get_fixed_params(self):\n        \"\"\"Defines the fixed parameters used by the model for training.\n\n        Requires the following keys:\n          'total_time_steps': Defines the total number of time steps used by TFT\n          'num_encoder_steps': Determines length of LSTM encoder (i.e. history)\n          'num_epochs': Maximum number of epochs for training\n          'early_stopping_patience': Early stopping param for keras\n          'multiprocessing_workers': # of cpus for data processing\n\n\n        Returns:\n          A dictionary of fixed parameters, e.g.:\n\n          fixed_params = {\n              'total_time_steps': 252 + 5,\n              'num_encoder_steps': 252,\n              'num_epochs': 100,\n              'early_stopping_patience': 5,\n              'multiprocessing_workers': 5,\n          }\n        \"\"\"\n        raise NotImplementedError\n\n    # Shared functions across data-formatters\n    @property\n    def num_classes_per_cat_input(self):\n        \"\"\"Returns number of categories per relevant input.\n\n        This is seqeuently required for keras embedding layers.\n        \"\"\"\n        return self._num_classes_per_cat_input\n\n    def get_num_samples_for_calibration(self):\n        \"\"\"Gets the default number of training and validation samples.\n\n        Use to sub-sample the data for network calibration and a value of -1 uses\n        all available samples.\n\n        Returns:\n          Tuple of (training samples, validation samples)\n        \"\"\"\n        return -1, -1\n\n    def get_column_definition(self):\n        \"\"\"Returns formatted column definition in order expected by the TFT.\"\"\"\n\n        column_definition = self._column_definition\n\n        # Sanity checks first.\n        # Ensure only one ID and time column exist\n        def _check_single_column(input_type):\n            length = len([tup for tup in column_definition if tup[2] == input_type])\n\n            if length != 1:\n                raise ValueError(\"Illegal number of inputs ({}) of type {}\".format(length, input_type))\n\n        _check_single_column(InputTypes.ID)\n        _check_single_column(InputTypes.TIME)\n\n        identifier = [tup for tup in column_definition if tup[2] == InputTypes.ID]\n        time = [tup for tup in column_definition if tup[2] == InputTypes.TIME]\n        real_inputs = [\n            tup\n            for tup in column_definition\n            if tup[1] == DataTypes.REAL_VALUED and tup[2] not in {InputTypes.ID, InputTypes.TIME}\n        ]\n        categorical_inputs = [\n            tup\n            for tup in column_definition\n            if tup[1] == DataTypes.CATEGORICAL and tup[2] not in {InputTypes.ID, InputTypes.TIME}\n        ]\n\n        return identifier + time + real_inputs + categorical_inputs\n\n    def _get_input_columns(self):\n        \"\"\"Returns names of all input columns.\"\"\"\n        return [tup[0] for tup in self.get_column_definition() if tup[2] not in {InputTypes.ID, InputTypes.TIME}]\n\n    def _get_tft_input_indices(self):\n        \"\"\"Returns the relevant indexes and input sizes required by TFT.\"\"\"\n\n        # Functions\n        def _extract_tuples_from_data_type(data_type, defn):\n            return [tup for tup in defn if tup[1] == data_type and tup[2] not in {InputTypes.ID, InputTypes.TIME}]\n\n        def _get_locations(input_types, defn):\n            return [i for i, tup in enumerate(defn) if tup[2] in input_types]\n\n        # Start extraction\n        column_definition = [\n            tup for tup in self.get_column_definition() if tup[2] not in {InputTypes.ID, InputTypes.TIME}\n        ]\n\n        categorical_inputs = _extract_tuples_from_data_type(DataTypes.CATEGORICAL, column_definition)\n        real_inputs = _extract_tuples_from_data_type(DataTypes.REAL_VALUED, column_definition)\n\n        locations = {\n            \"input_size\": len(self._get_input_columns()),\n            \"output_size\": len(_get_locations({InputTypes.TARGET}, column_definition)),\n            \"category_counts\": self.num_classes_per_cat_input,\n            \"input_obs_loc\": _get_locations({InputTypes.TARGET}, column_definition),\n            \"static_input_loc\": _get_locations({InputTypes.STATIC_INPUT}, column_definition),\n            \"known_regular_inputs\": _get_locations({InputTypes.STATIC_INPUT, InputTypes.KNOWN_INPUT}, real_inputs),\n            \"known_categorical_inputs\": _get_locations(\n                {InputTypes.STATIC_INPUT, InputTypes.KNOWN_INPUT}, categorical_inputs\n            ),\n        }\n\n        return locations\n\n    def get_experiment_params(self):\n        \"\"\"Returns fixed model parameters for experiments.\"\"\"\n\n        required_keys = [\n            \"total_time_steps\",\n            \"num_encoder_steps\",\n            \"num_epochs\",\n            \"early_stopping_patience\",\n            \"multiprocessing_workers\",\n        ]\n\n        fixed_params = self.get_fixed_params()\n\n        for k in required_keys:\n            if k not in fixed_params:\n                raise ValueError(\"Field {}\".format(k) + \" missing from fixed parameter definitions!\")\n\n        fixed_params[\"column_definition\"] = self.get_column_definition()\n\n        fixed_params.update(self._get_tft_input_indices())\n\n        return fixed_params",
    "source": "github_repo:microsoft/qlib",
    "file": "examples/benchmarks/TFT/data_formatters/base.py",
    "license": "MIT",
    "language": "python"
}