{
    "code": "class BaseAgent(BaseModel, ABC):\n    \"\"\"Abstract base class for managing agent state and execution.\n\n    Provides foundational functionality for state transitions, memory management,\n    and a step-based execution loop. Subclasses must implement the `step` method.\n    \"\"\"\n\n    # Core attributes\n    name: str = Field(..., description=\"Unique name of the agent\")\n    description: Optional[str] = Field(None, description=\"Optional agent description\")\n\n    # Prompts\n    system_prompt: Optional[str] = Field(\n        None, description=\"System-level instruction prompt\"\n    )\n    next_step_prompt: Optional[str] = Field(\n        None, description=\"Prompt for determining next action\"\n    )\n\n    # Dependencies\n    llm: LLM = Field(default_factory=LLM, description=\"Language model instance\")\n    memory: Memory = Field(default_factory=Memory, description=\"Agent's memory store\")\n    state: AgentState = Field(\n        default=AgentState.IDLE, description=\"Current agent state\"\n    )\n\n    # Execution control\n    max_steps: int = Field(default=10, description=\"Maximum steps before termination\")\n    current_step: int = Field(default=0, description=\"Current step in execution\")\n\n    duplicate_threshold: int = 2\n\n    class Config:\n        arbitrary_types_allowed = True\n        extra = \"allow\"  # Allow extra fields for flexibility in subclasses\n\n    @model_validator(mode=\"after\")\n    def initialize_agent(self) -> \"BaseAgent\":\n        \"\"\"Initialize agent with default settings if not provided.\"\"\"\n        if self.llm is None or not isinstance(self.llm, LLM):\n            self.llm = LLM(config_name=self.name.lower())\n        if not isinstance(self.memory, Memory):\n            self.memory = Memory()\n        return self\n\n    @asynccontextmanager\n    async def state_context(self, new_state: AgentState):\n        \"\"\"Context manager for safe agent state transitions.\n\n        Args:\n            new_state: The state to transition to during the context.\n\n        Yields:\n            None: Allows execution within the new state.\n\n        Raises:\n            ValueError: If the new_state is invalid.\n        \"\"\"\n        if not isinstance(new_state, AgentState):\n            raise ValueError(f\"Invalid state: {new_state}\")\n\n        previous_state = self.state\n        self.state = new_state\n        try:\n            yield\n        except Exception as e:\n            self.state = AgentState.ERROR  # Transition to ERROR on failure\n            raise e\n        finally:\n            self.state = previous_state  # Revert to previous state\n\n    def update_memory(\n        self,\n        role: ROLE_TYPE,  # type: ignore\n        content: str,\n        base64_image: Optional[str] = None,\n        **kwargs,\n    ) -> None:\n        \"\"\"Add a message to the agent's memory.\n\n        Args:\n            role: The role of the message sender (user, system, assistant, tool).\n            content: The message content.\n            base64_image: Optional base64 encoded image.\n            **kwargs: Additional arguments (e.g., tool_call_id for tool messages).\n\n        Raises:\n            ValueError: If the role is unsupported.\n        \"\"\"\n        message_map = {\n            \"user\": Message.user_message,\n            \"system\": Message.system_message,\n            \"assistant\": Message.assistant_message,\n            \"tool\": lambda content, **kw: Message.tool_message(content, **kw),\n        }\n\n        if role not in message_map:\n            raise ValueError(f\"Unsupported message role: {role}\")\n\n        # Create message with appropriate parameters based on role\n        kwargs = {\"base64_image\": base64_image, **(kwargs if role == \"tool\" else {})}\n        self.memory.add_message(message_map[role](content, **kwargs))\n\n    async def run(self, request: Optional[str] = None) -> str:\n        \"\"\"Execute the agent's main loop asynchronously.\n\n        Args:\n            request: Optional initial user request to process.\n\n        Returns:\n            A string summarizing the execution results.\n\n        Raises:\n            RuntimeError: If the agent is not in IDLE state at start.\n        \"\"\"\n        if self.state != AgentState.IDLE:\n            raise RuntimeError(f\"Cannot run agent from state: {self.state}\")\n\n        if request:\n            self.update_memory(\"user\", request)\n\n        results: List[str] = []\n        async with self.state_context(AgentState.RUNNING):\n            while (\n                self.current_step < self.max_steps and self.state != AgentState.FINISHED\n            ):\n                self.current_step += 1\n                logger.info(f\"Executing step {self.current_step}/{self.max_steps}\")\n                step_result = await self.step()\n\n                # Check for stuck state\n                if self.is_stuck():\n                    self.handle_stuck_state()\n\n                results.append(f\"Step {self.current_step}: {step_result}\")\n\n            if self.current_step >= self.max_steps:\n                self.current_step = 0\n                self.state = AgentState.IDLE\n                results.append(f\"Terminated: Reached max steps ({self.max_steps})\")\n        await SANDBOX_CLIENT.cleanup()\n        return \"\\n\".join(results) if results else \"No steps executed\"\n\n    @abstractmethod\n    async def step(self) -> str:\n        \"\"\"Execute a single step in the agent's workflow.\n\n        Must be implemented by subclasses to define specific behavior.\n        \"\"\"\n\n    def handle_stuck_state(self):\n        \"\"\"Handle stuck state by adding a prompt to change strategy\"\"\"\n        stuck_prompt = \"\\\n        Observed duplicate responses. Consider new strategies and avoid repeating ineffective paths already attempted.\"\n        self.next_step_prompt = f\"{stuck_prompt}\\n{self.next_step_prompt}\"\n        logger.warning(f\"Agent detected stuck state. Added prompt: {stuck_prompt}\")\n\n    def is_stuck(self) -> bool:\n        \"\"\"Check if the agent is stuck in a loop by detecting duplicate content\"\"\"\n        if len(self.memory.messages) < 2:\n            return False\n\n        last_message = self.memory.messages[-1]\n        if not last_message.content:\n            return False\n\n        # Count identical content occurrences\n        duplicate_count = sum(\n            1\n            for msg in reversed(self.memory.messages[:-1])\n            if msg.role == \"assistant\" and msg.content == last_message.content\n        )\n\n        return duplicate_count >= self.duplicate_threshold\n\n    @property\n    def messages(self) -> List[Message]:\n        \"\"\"Retrieve a list of messages from the agent's memory.\"\"\"\n        return self.memory.messages\n\n    @messages.setter\n    def messages(self, value: List[Message]):\n        \"\"\"Set the list of messages in the agent's memory.\"\"\"\n        self.memory.messages = value",
    "source": "github_repo:FoundationAgents/OpenManus",
    "file": "app/agent/base.py",
    "license": "MIT",
    "language": "python"
}