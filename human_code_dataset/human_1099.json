{
    "code": "class Manus(ToolCallAgent):\n    \"\"\"A versatile general-purpose agent with support for both local and MCP tools.\"\"\"\n\n    name: str = \"Manus\"\n    description: str = \"A versatile agent that can solve various tasks using multiple tools including MCP-based tools\"\n\n    system_prompt: str = SYSTEM_PROMPT.format(directory=config.workspace_root)\n    next_step_prompt: str = NEXT_STEP_PROMPT\n\n    max_observe: int = 10000\n    max_steps: int = 20\n\n    # MCP clients for remote tool access\n    mcp_clients: MCPClients = Field(default_factory=MCPClients)\n\n    # Add general-purpose tools to the tool collection\n    available_tools: ToolCollection = Field(\n        default_factory=lambda: ToolCollection(\n            PythonExecute(),\n            BrowserUseTool(),\n            StrReplaceEditor(),\n            AskHuman(),\n            Terminate(),\n        )\n    )\n\n    special_tool_names: list[str] = Field(default_factory=lambda: [Terminate().name])\n    browser_context_helper: Optional[BrowserContextHelper] = None\n\n    # Track connected MCP servers\n    connected_servers: Dict[str, str] = Field(\n        default_factory=dict\n    )  # server_id -> url/command\n    _initialized: bool = False\n\n    @model_validator(mode=\"after\")\n    def initialize_helper(self) -> \"Manus\":\n        \"\"\"Initialize basic components synchronously.\"\"\"\n        self.browser_context_helper = BrowserContextHelper(self)\n        return self\n\n    @classmethod\n    async def create(cls, **kwargs) -> \"Manus\":\n        \"\"\"Factory method to create and properly initialize a Manus instance.\"\"\"\n        instance = cls(**kwargs)\n        await instance.initialize_mcp_servers()\n        instance._initialized = True\n        return instance\n\n    async def initialize_mcp_servers(self) -> None:\n        \"\"\"Initialize connections to configured MCP servers.\"\"\"\n        for server_id, server_config in config.mcp_config.servers.items():\n            try:\n                if server_config.type == \"sse\":\n                    if server_config.url:\n                        await self.connect_mcp_server(server_config.url, server_id)\n                        logger.info(\n                            f\"Connected to MCP server {server_id} at {server_config.url}\"\n                        )\n                elif server_config.type == \"stdio\":\n                    if server_config.command:\n                        await self.connect_mcp_server(\n                            server_config.command,\n                            server_id,\n                            use_stdio=True,\n                            stdio_args=server_config.args,\n                        )\n                        logger.info(\n                            f\"Connected to MCP server {server_id} using command {server_config.command}\"\n                        )\n            except Exception as e:\n                logger.error(f\"Failed to connect to MCP server {server_id}: {e}\")\n\n    async def connect_mcp_server(\n        self,\n        server_url: str,\n        server_id: str = \"\",\n        use_stdio: bool = False,\n        stdio_args: List[str] = None,\n    ) -> None:\n        \"\"\"Connect to an MCP server and add its tools.\"\"\"\n        if use_stdio:\n            await self.mcp_clients.connect_stdio(\n                server_url, stdio_args or [], server_id\n            )\n            self.connected_servers[server_id or server_url] = server_url\n        else:\n            await self.mcp_clients.connect_sse(server_url, server_id)\n            self.connected_servers[server_id or server_url] = server_url\n\n        # Update available tools with only the new tools from this server\n        new_tools = [\n            tool for tool in self.mcp_clients.tools if tool.server_id == server_id\n        ]\n        self.available_tools.add_tools(*new_tools)\n\n    async def disconnect_mcp_server(self, server_id: str = \"\") -> None:\n        \"\"\"Disconnect from an MCP server and remove its tools.\"\"\"\n        await self.mcp_clients.disconnect(server_id)\n        if server_id:\n            self.connected_servers.pop(server_id, None)\n        else:\n            self.connected_servers.clear()\n\n        # Rebuild available tools without the disconnected server's tools\n        base_tools = [\n            tool\n            for tool in self.available_tools.tools\n            if not isinstance(tool, MCPClientTool)\n        ]\n        self.available_tools = ToolCollection(*base_tools)\n        self.available_tools.add_tools(*self.mcp_clients.tools)\n\n    async def cleanup(self):\n        \"\"\"Clean up Manus agent resources.\"\"\"\n        if self.browser_context_helper:\n            await self.browser_context_helper.cleanup_browser()\n        # Disconnect from all MCP servers only if we were initialized\n        if self._initialized:\n            await self.disconnect_mcp_server()\n            self._initialized = False\n\n    async def think(self) -> bool:\n        \"\"\"Process current state and decide next actions with appropriate context.\"\"\"\n        if not self._initialized:\n            await self.initialize_mcp_servers()\n            self._initialized = True\n\n        original_prompt = self.next_step_prompt\n        recent_messages = self.memory.messages[-3:] if self.memory.messages else []\n        browser_in_use = any(\n            tc.function.name == BrowserUseTool().name\n            for msg in recent_messages\n            if msg.tool_calls\n            for tc in msg.tool_calls\n        )\n\n        if browser_in_use:\n            self.next_step_prompt = (\n                await self.browser_context_helper.format_next_step_prompt()\n            )\n\n        result = await super().think()\n\n        # Restore original prompt\n        self.next_step_prompt = original_prompt\n\n        return result",
    "source": "github_repo:FoundationAgents/OpenManus",
    "file": "app/agent/manus.py",
    "license": "MIT",
    "language": "python"
}