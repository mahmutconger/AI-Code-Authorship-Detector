{
    "code": "def init_from_ckpt(self, path, ignore_keys=list(), only_model=False):\n        sd = torch.load(path, map_location=\"cpu\")\n        if \"state_dict\" in list(sd.keys()):\n            sd = sd[\"state_dict\"]\n        keys = list(sd.keys())\n        for k in keys:\n            for ik in ignore_keys:\n                if k.startswith(ik):\n                    print(\"Deleting key {} from state_dict.\".format(k))\n                    del sd[k]\n        if self.make_it_fit:\n            n_params = len([name for name, _ in\n                            itertools.chain(self.named_parameters(),\n                                            self.named_buffers())])\n            for name, param in tqdm(\n                    itertools.chain(self.named_parameters(),\n                                    self.named_buffers()),\n                    desc=\"Fitting old weights to new weights\",\n                    total=n_params\n            ):\n                if not name in sd:\n                    continue\n                old_shape = sd[name].shape\n                new_shape = param.shape\n                assert len(old_shape) == len(new_shape)\n                if len(new_shape) > 2:\n                    # we only modify first two axes\n                    assert new_shape[2:] == old_shape[2:]\n                # assumes first axis corresponds to output dim\n                if not new_shape == old_shape:\n                    new_param = param.clone()\n                    old_param = sd[name]\n                    if len(new_shape) == 1:\n                        for i in range(new_param.shape[0]):\n                            new_param[i] = old_param[i % old_shape[0]]\n                    elif len(new_shape) >= 2:\n                        for i in range(new_param.shape[0]):\n                            for j in range(new_param.shape[1]):\n                                new_param[i, j] = old_param[i % old_shape[0], j % old_shape[1]]\n\n                        n_used_old = torch.ones(old_shape[1])\n                        for j in range(new_param.shape[1]):\n                            n_used_old[j % old_shape[1]] += 1\n                        n_used_new = torch.zeros(new_shape[1])\n                        for j in range(new_param.shape[1]):\n                            n_used_new[j] = n_used_old[j % old_shape[1]]\n\n                        n_used_new = n_used_new[None, :]\n                        while len(n_used_new.shape) < len(new_shape):\n                            n_used_new = n_used_new.unsqueeze(-1)\n                        new_param /= n_used_new\n\n                    sd[name] = new_param\n\n        missing, unexpected = self.load_state_dict(sd, strict=False) if not only_model else self.model.load_state_dict(\n            sd, strict=False)\n        print(f\"Restored from {path} with {len(missing)} missing and {len(unexpected)} unexpected keys\")\n        if len(missing) > 0:\n            print(f\"Missing Keys:\\n {missing}\")\n        if len(unexpected) > 0:\n            print(f\"\\nUnexpected Keys:\\n {unexpected}\")",
    "source": "github_repo:Stability-AI/stablediffusion",
    "file": "ldm/models/diffusion/ddpm.py",
    "license": "MIT",
    "language": "python"
}