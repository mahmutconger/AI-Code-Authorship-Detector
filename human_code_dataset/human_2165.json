{
    "code": "def parser():\n    \"\"\"\n    parser: parses the tokens of the list 'tokens'\n    \"\"\"\n\n    global tokens\n    global eax, ebx, ecx, edx\n\n    assert len(tokens) > 0, \"no tokens\"\n\n    pointer = 0  # pointer for tokens\n    token = Token(\"\", \"\")\n    tmpToken = Token(\"\", \"\")\n\n    while pointer < len(tokens):\n        token = tokens[pointer]\n\n        if token.token == \"mov\":  # mov commando\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found argument!\")\n                return\n\n            # TODO use token.t for this stuff\n            if token.t == \"register\":\n                tmpToken = token\n\n                # it must follow a value / string / register / variable\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    token = tokens[pointer]\n                else:\n                    print(\"Error: Not found argument!\")\n                    return\n\n                # converts the token into float, if token contains only digits.\n                # TODO response of float\n                if token.t == \"identifier\":  # for variables\n                    # check of exists of variable\n                    if token.token in variables:\n                        token.token = variables[token.token]\n                    else:\n                        print(f\"Error: Undefined variable {token.token}\")\n                        return\n\n                elif token.t == \"string\":\n                    token.token = str(token.token)\n\n                elif isinstance(token.token, float):\n                    pass\n                elif token.token.isdigit():\n                    token.token = float(token.token)\n                elif token.token[0] == \"-\" and token.token[1:].isdigit():\n                    token.token = float(token.token[1:])\n                    token.token *= -1\n                elif token.t == \"register\":  # loads out of register\n                    match token.token:\n                        case \"eax\":\n                            token.token = eax\n                        case \"ebx\":\n                            token.token = ebx\n                        case \"ecx\":\n                            token.token = ecx\n                        case \"edx\":\n                            token.token = edx\n\n                match tmpToken.token:\n                    case \"eax\":\n                        eax = token.token\n                    case \"ebx\":\n                        ebx = token.token\n                    case \"ecx\":\n                        ecx = token.token\n                    case \"edx\":\n                        edx = token.token\n\n            else:\n                print(\"Error: No found register!\")\n                return\n\n        elif token.token == \"add\":  # add commando\n            pointer += 1\n            token = tokens[pointer]\n\n            if token.t == \"register\":\n                tmpToken = token\n\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    token = tokens[pointer]\n                else:\n                    print(\"Error: Not found number!\")\n                    return\n\n                # converts the token into float, if token contains only digits.\n                if token.t == \"register\":\n                    # for the case that token is register\n                    match token.token:\n                        case \"eax\":\n                            token.token = eax\n                        case \"ebx\":\n                            token.token = ebx\n                        case \"ecx\":\n                            token.token = ecx\n                        case \"edx\":\n                            token.token = edx\n\n                elif token.token.isdigit():\n                    token.token = float(token.token)\n                elif token.token[0] == \"-\" and token.token[1:].isdigit():\n                    token.token = float(token.token[1:])\n                    token.token *= -1\n                else:\n                    print(\"Error: \", token, \" is not a number!\")\n                    return\n\n                match tmpToken.token:\n                    case \"eax\":\n                        eax += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if eax == 0:\n                            zeroFlag = True\n\n                    case \"ebx\":\n                        ebx += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if ebx == 0:\n                            zeroFlag = True\n\n                    case \"ecx\":\n                        ecx += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if ecx == 0:\n                            zeroFlag = True\n\n                    case \"edx\":\n                        edx += token.token\n\n                        # update zero flag\n                        zeroFlag = False\n                        if edx == 0:\n                            zeroFlag = True\n\n            else:\n                print(\"Error: Not found register!\")\n                return\n\n        elif token.token == \"sub\":  # sub commando\n            pointer += 1\n            token = tokens[pointer]\n\n            if token.t == \"register\":\n                tmpToken = token\n\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    token = tokens[pointer]\n                else:\n                    print(\"Error: Not found number!\")\n                    return\n\n                # converts the token into float, if token contains only digits.\n                if token.t == \"register\":\n                    # for the case that token is register\n                    if token.token == \"eax\":\n                        token.token = eax\n                    elif token.token == \"ebx\":\n                        token.token = ebx\n                    elif token.token == \"ecx\":\n                        token.token = ecx\n                    elif token.token == \"edx\":\n                        token.token = edx\n\n                elif isinstance(token.token, float):\n                    pass\n                elif token.token.isdigit():\n                    token.token = float(token.token)\n                elif token.token[0] == \"-\" and token.token[1:].isdigit():\n                    token.token = float(token.token[1:])\n                    token.token *= -1\n                else:\n                    print(\"Error: \", token.token, \" is not a number!\")\n                    return\n\n                if tmpToken.token == \"eax\":\n                    eax -= token.token\n\n                    # updated zero flag\n                    if eax == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n                elif tmpToken.token == \"ebx\":\n                    ebx -= token.token\n\n                    # update zero flag\n                    if ebx == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n                elif tmpToken.token == \"ecx\":\n                    ecx -= token.token\n\n                    # update zero flag\n                    if ecx == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n                elif tmpToken.token == \"edx\":\n                    edx -= token.token\n\n                    # update zero flag\n                    if edx == 0:\n                        zeroFlag = True\n                    else:\n                        zeroFlag = False\n\n            else:\n                print(\"Error: No found register!\")\n                return\n\n        elif token.token == \"int\":  # int commando\n            tmpToken = token\n\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found argument!\")\n                return\n\n            if token.token == \"0x80\":  # system interrupt 0x80\n                if eax == 1:  # exit program\n                    if ebx == 0:\n                        print(\"END PROGRAM\")\n                        return\n                    else:\n                        print(\"END PROGRAM WITH ERRORS\")\n                        return\n\n                elif eax == 3:\n                    ecx = float(input(\">> \"))\n\n                elif eax == 4:  # output information\n                    print(ecx)\n\n        elif token.token == \"push\":  # push commando\n            tmpToken = token\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found register!\")\n                return\n\n            # pushing register on the stack\n            stack.append(token.token)\n\n        elif token.token == \"pop\":  # pop commando\n            tmpToken = token\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found register!\")\n                return\n\n            # pop register from stack\n            match token.token:\n                case \"eax\":\n                    if len(stack) == 0:\n                        print(\"Error: Stack Underflow\")\n                        return\n                    eax = stack.pop()\n                case \"ebx\":\n                    ebx = stack.pop()\n                case \"ecx\":\n                    ecx = stack.pop()\n                case \"edx\":\n                    edx = stack.pop()\n\n        elif token.t == \"label\":  # capture label\n            jumps[token.token] = pointer\n\n        elif token.token == \"jmp\":  # capture jmp command\n            # it must follow a label\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found label!\")\n                return\n\n            if token.t == \"label\":\n                pointer = jumps[token.token]\n\n            else:\n                print(\"Error: expected a label!\")\n\n        elif token.token == \"cmp\":\n            # TODO\n\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]\n            else:\n                print(\"Error: Not found argument!\")\n                return\n\n            if token.t == \"register\":\n                # it must follow a register\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    tmpToken = tokens[pointer]  # next register\n                else:\n                    print(\"Error: Not found register!\")\n                    return\n\n                # actual comparing\n                zeroFlag = setZeroFlag(token.token, tmpToken.token)\n\n        elif token.token == \"je\":\n            # it must follow a label\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found argument\")\n                return\n\n            # check of label\n            if token.t == \"label\":\n                # actual jump\n                if zeroFlag:\n                    pointer = jumps[token.token]\n\n            else:\n                print(\"Error: Not found label\")\n                return\n\n        elif token.t == \"identifier\":\n            # check whether identifier is in variables-table\n            if token.token not in variables:\n                # it must follow a command\n                if pointer + 1 < len(tokens):\n                    pointer += 1\n                    tmpToken = tokens[pointer]  # next register\n                else:\n                    print(\"Error: Not found argument\")\n                    return\n\n                if tmpToken.t == \"command\" and tmpToken.token == \"db\":\n                    # it must follow a value (string)\n                    if pointer + 1 < len(tokens):\n                        pointer += 1\n                        tmpToken = tokens[pointer]  # next register\n                    else:\n                        print(\"Error: Not found argument\")\n                        return\n\n                    if tmpToken.t == \"value\" or tmpToken.t == \"string\":\n                        if tmpToken.t == \"value\":\n                            variables[token.token] = float(tmpToken.token)\n                        elif tmpToken.t == \"string\":\n                            variables[token.token] = tmpToken.token\n\n                else:\n                    print(\"Error: Not found db-keyword\")\n                    return\n\n        elif token.token == \"call\":  # catch the call-command\n            # it must follow a subprogram label\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found subprogram label\")\n                return\n\n            if token.t == \"subprogram\":\n                if token.token in jumps:\n                    # save the current pointer\n                    returnStack.append(pointer)  # eventuell pointer + 1\n                    # jump to the subprogram\n                    pointer = jumps[token.token]\n\n                else:  # error case\n                    print(\"Error: Unknown subprogram!\")\n                    return\n\n            else:  # error case\n                print(\"Error: Not found subprogram\")\n                return\n\n        elif token.token == \"ret\":  # catch the ret-command\n            if len(returnStack) >= 1:\n                pointer = returnStack.pop()\n\n            else:  # error case\n                print(\"Error: No return address on stack\")\n                return\n\n        elif token.t == \"subprogram\":\n            pass\n\n        elif token.token == \"mul\":  # catch mul-command\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found argument\")\n                return\n\n            if token.t == \"register\":\n                if token.token == \"eax\":\n                    eax *= eax\n\n                elif token.token == \"ebx\":\n                    eax *= ebx\n\n                elif token.token == \"ecx\":\n                    eax *= ecx\n\n                elif token.token == \"edx\":\n                    eax *= edx\n\n            else:\n                print(\"Error: Not found register\")\n                return\n\n        elif token.token == \"div\":\n            # it must follow a register\n            if pointer + 1 < len(tokens):\n                pointer += 1\n                token = tokens[pointer]  # next register\n            else:\n                print(\"Error: Not found argument\")\n                return\n\n            if token.t == \"register\":\n                match token.token:\n                    case \"eax\":\n                        eax /= eax\n\n                    case \"ebx\":\n                        if ebx == 0:\n                            print(\"Error: Division by Zero\")\n                            return\n                        eax /= ebx\n\n                    case \"ecx\":\n                        eax /= ecx\n\n                    case \"edx\":\n                        eax /= edx\n\n            else:\n                print(\"Error: Not found register\")\n                return\n\n        # increment pointer for fetching next token.\n        pointer += 1",
    "source": "github_repo:geekcomputers/Python",
    "file": "Assembler/assembler.py",
    "license": "MIT",
    "language": "python"
}