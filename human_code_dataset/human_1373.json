{
    "code": "class WorkflowAssistant:\n    def __init__(self, db_path: str = \"workflows.db\"):\n        self.db_path = db_path\n        self.conversation_history = {}\n        \n    def get_db_connection(self):\n        conn = sqlite3.connect(self.db_path)\n        conn.row_factory = sqlite3.Row\n        return conn\n    \n    def search_workflows_intelligent(self, query: str, limit: int = 5) -> List[Dict]:\n        \"\"\"Intelligent workflow search based on natural language query.\"\"\"\n        conn = self.get_db_connection()\n        \n        # Extract keywords and intent from query\n        keywords = self.extract_keywords(query)\n        intent = self.detect_intent(query)\n        \n        # Build search query\n        search_terms = []\n        for keyword in keywords:\n            search_terms.append(f\"name LIKE '%{keyword}%' OR description LIKE '%{keyword}%'\")\n        \n        where_clause = \" OR \".join(search_terms) if search_terms else \"1=1\"\n        \n        # Add intent-based filtering\n        if intent == \"automation\":\n            where_clause += \" AND (trigger_type = 'Scheduled' OR trigger_type = 'Complex')\"\n        elif intent == \"integration\":\n            where_clause += \" AND trigger_type = 'Webhook'\"\n        elif intent == \"manual\":\n            where_clause += \" AND trigger_type = 'Manual'\"\n        \n        query_sql = f\"\"\"\n            SELECT * FROM workflows \n            WHERE {where_clause}\n            ORDER BY \n                CASE WHEN active = 1 THEN 1 ELSE 2 END,\n                node_count DESC\n            LIMIT {limit}\n        \"\"\"\n        \n        cursor = conn.execute(query_sql)\n        workflows = []\n        for row in cursor.fetchall():\n            workflow = dict(row)\n            workflow['integrations'] = json.loads(workflow['integrations'] or '[]')\n            workflow['tags'] = json.loads(workflow['tags'] or '[]')\n            workflows.append(workflow)\n        \n        conn.close()\n        return workflows\n    \n    def extract_keywords(self, query: str) -> List[str]:\n        \"\"\"Extract relevant keywords from user query.\"\"\"\n        # Common automation terms\n        automation_terms = {\n            'email': ['email', 'gmail', 'mail'],\n            'social': ['twitter', 'facebook', 'instagram', 'linkedin', 'social'],\n            'data': ['data', 'database', 'spreadsheet', 'csv', 'excel'],\n            'ai': ['ai', 'openai', 'chatgpt', 'artificial', 'intelligence'],\n            'notification': ['notification', 'alert', 'slack', 'telegram', 'discord'],\n            'automation': ['automation', 'workflow', 'process', 'automate'],\n            'integration': ['integration', 'connect', 'sync', 'api']\n        }\n        \n        query_lower = query.lower()\n        keywords = []\n        \n        for category, terms in automation_terms.items():\n            for term in terms:\n                if term in query_lower:\n                    keywords.append(term)\n        \n        # Extract specific service names\n        services = ['slack', 'telegram', 'openai', 'google', 'microsoft', 'shopify', 'airtable']\n        for service in services:\n            if service in query_lower:\n                keywords.append(service)\n        \n        return list(set(keywords))\n    \n    def detect_intent(self, query: str) -> str:\n        \"\"\"Detect user intent from query.\"\"\"\n        query_lower = query.lower()\n        \n        if any(word in query_lower for word in ['automate', 'schedule', 'recurring', 'daily', 'weekly']):\n            return \"automation\"\n        elif any(word in query_lower for word in ['connect', 'integrate', 'sync', 'webhook']):\n            return \"integration\"\n        elif any(word in query_lower for word in ['manual', 'trigger', 'button', 'click']):\n            return \"manual\"\n        elif any(word in query_lower for word in ['ai', 'chat', 'assistant', 'intelligent']):\n            return \"ai\"\n        else:\n            return \"general\"\n    \n    def generate_response(self, query: str, workflows: List[Dict]) -> str:\n        \"\"\"Generate natural language response based on query and workflows.\"\"\"\n        if not workflows:\n            return \"I couldn't find any workflows matching your request. Try searching for specific services like 'Slack', 'OpenAI', or 'Email automation'.\"\n        \n        # Analyze workflow patterns\n        trigger_types = [w['trigger_type'] for w in workflows]\n        integrations = []\n        for w in workflows:\n            integrations.extend(w['integrations'])\n        \n        common_integrations = list(set(integrations))[:3]\n        most_common_trigger = max(set(trigger_types), key=trigger_types.count)\n        \n        # Generate contextual response\n        response_parts = []\n        \n        if len(workflows) == 1:\n            workflow = workflows[0]\n            response_parts.append(f\"I found a perfect match: **{workflow['name']}**\")\n            response_parts.append(f\"This is a {workflow['trigger_type'].lower()} workflow that {workflow['description'].lower()}\")\n        else:\n            response_parts.append(f\"I found {len(workflows)} relevant workflows:\")\n            \n            for i, workflow in enumerate(workflows[:3], 1):\n                response_parts.append(f\"{i}. **{workflow['name']}** - {workflow['description']}\")\n        \n        if common_integrations:\n            response_parts.append(f\"\\nThese workflows commonly use: {', '.join(common_integrations)}\")\n        \n        if most_common_trigger != 'all':\n            response_parts.append(f\"Most are {most_common_trigger.lower()} triggered workflows.\")\n        \n        return \"\\n\".join(response_parts)\n    \n    def get_suggestions(self, query: str) -> List[str]:\n        \"\"\"Generate helpful suggestions based on query.\"\"\"\n        suggestions = []\n        \n        if 'email' in query.lower():\n            suggestions.extend([\n                \"Email automation workflows\",\n                \"Gmail integration examples\",\n                \"Email notification systems\"\n            ])\n        elif 'ai' in query.lower() or 'openai' in query.lower():\n            suggestions.extend([\n                \"AI-powered workflows\",\n                \"OpenAI integration examples\",\n                \"Chatbot automation\"\n            ])\n        elif 'social' in query.lower():\n            suggestions.extend([\n                \"Social media automation\",\n                \"Twitter integration workflows\",\n                \"LinkedIn automation\"\n            ])\n        else:\n            suggestions.extend([\n                \"Popular automation patterns\",\n                \"Webhook-triggered workflows\",\n                \"Scheduled automation examples\"\n            ])\n        \n        return suggestions[:3]\n    \n    def calculate_confidence(self, query: str, workflows: List[Dict]) -> float:\n        \"\"\"Calculate confidence score for the response.\"\"\"\n        if not workflows:\n            return 0.0\n        \n        # Base confidence on number of matches and relevance\n        base_confidence = min(len(workflows) / 5.0, 1.0)\n        \n        # Boost confidence for exact matches\n        query_lower = query.lower()\n        exact_matches = 0\n        for workflow in workflows:\n            if any(word in workflow['name'].lower() for word in query_lower.split()):\n                exact_matches += 1\n        \n        if exact_matches > 0:\n            base_confidence += 0.2\n        \n        return min(base_confidence, 1.0)",
    "source": "github_repo:Zie619/n8n-workflows",
    "file": "src/ai_assistant.py",
    "license": "MIT",
    "language": "python"
}