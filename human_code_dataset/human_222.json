{
    "code": "class MLA(nn.Module):\n    \"\"\"\n    Multi-Head Latent Attention (MLA) Layer.\n\n    Attributes:\n        dim (int): Dimensionality of the input features.\n        n_heads (int): Number of attention heads.\n        n_local_heads (int): Number of local attention heads for distributed systems.\n        q_lora_rank (int): Rank for low-rank query projection.\n        kv_lora_rank (int): Rank for low-rank key/value projection.\n        qk_nope_head_dim (int): Dimensionality of non-positional query/key projections.\n        qk_rope_head_dim (int): Dimensionality of rotary-positional query/key projections.\n        qk_head_dim (int): Total dimensionality of query/key projections.\n        v_head_dim (int): Dimensionality of value projections.\n        softmax_scale (float): Scaling factor for softmax in attention computation.\n    \"\"\"\n    def __init__(self, args: ModelArgs):\n        super().__init__()\n        self.dim = args.dim\n        self.n_heads = args.n_heads\n        self.n_local_heads = args.n_heads // world_size\n        self.q_lora_rank = args.q_lora_rank\n        self.kv_lora_rank = args.kv_lora_rank\n        self.qk_nope_head_dim = args.qk_nope_head_dim\n        self.qk_rope_head_dim = args.qk_rope_head_dim\n        self.qk_head_dim = args.qk_nope_head_dim + args.qk_rope_head_dim\n        self.v_head_dim = args.v_head_dim\n\n        if self.q_lora_rank == 0:\n            self.wq = ColumnParallelLinear(self.dim, self.n_heads * self.qk_head_dim)\n        else:\n            self.wq_a = Linear(self.dim, self.q_lora_rank)\n            self.q_norm = RMSNorm(self.q_lora_rank)\n            self.wq_b = ColumnParallelLinear(self.q_lora_rank, self.n_heads * self.qk_head_dim)\n        self.wkv_a = Linear(self.dim, self.kv_lora_rank + self.qk_rope_head_dim)\n        self.kv_norm = RMSNorm(self.kv_lora_rank)\n        self.wkv_b = ColumnParallelLinear(self.kv_lora_rank, self.n_heads * (self.qk_nope_head_dim + self.v_head_dim))\n        self.wo = RowParallelLinear(self.n_heads * self.v_head_dim, self.dim)\n        self.softmax_scale = self.qk_head_dim ** -0.5\n        if args.max_seq_len > args.original_seq_len:\n            mscale = 0.1 * args.mscale * math.log(args.rope_factor) + 1.0\n            self.softmax_scale = self.softmax_scale * mscale * mscale\n\n        if attn_impl == \"naive\":\n            self.register_buffer(\"k_cache\", torch.zeros(args.max_batch_size, args.max_seq_len, self.n_local_heads, self.qk_head_dim), persistent=False)\n            self.register_buffer(\"v_cache\", torch.zeros(args.max_batch_size, args.max_seq_len, self.n_local_heads, self.v_head_dim), persistent=False)\n        else:\n            self.register_buffer(\"kv_cache\", torch.zeros(args.max_batch_size, args.max_seq_len, self.kv_lora_rank), persistent=False)\n            self.register_buffer(\"pe_cache\", torch.zeros(args.max_batch_size, args.max_seq_len, self.qk_rope_head_dim), persistent=False)\n\n    def forward(self, x: torch.Tensor, start_pos: int, freqs_cis: torch.Tensor, mask: Optional[torch.Tensor]):\n        \"\"\"\n        Forward pass for the Multi-Head Latent Attention (MLA) Layer.\n\n        Args:\n            x (torch.Tensor): Input tensor of shape (batch_size, seq_len, dim).\n            start_pos (int): Starting position in the sequence for caching.\n            freqs_cis (torch.Tensor): Precomputed complex exponential values for rotary embeddings.\n            mask (Optional[torch.Tensor]): Mask tensor to exclude certain positions from attention.\n\n        Returns:\n            torch.Tensor: Output tensor with the same shape as the input.\n        \"\"\"\n        bsz, seqlen, _ = x.size()\n        end_pos = start_pos + seqlen\n        if self.q_lora_rank == 0:\n            q = self.wq(x)\n        else:\n            q = self.wq_b(self.q_norm(self.wq_a(x)))\n        q = q.view(bsz, seqlen, self.n_local_heads, self.qk_head_dim)\n        q_nope, q_pe = torch.split(q, [self.qk_nope_head_dim, self.qk_rope_head_dim], dim=-1)\n        q_pe = apply_rotary_emb(q_pe, freqs_cis)\n        kv = self.wkv_a(x)\n        kv, k_pe = torch.split(kv, [self.kv_lora_rank, self.qk_rope_head_dim], dim=-1)\n        k_pe = apply_rotary_emb(k_pe.unsqueeze(2), freqs_cis)\n        if attn_impl == \"naive\":\n            q = torch.cat([q_nope, q_pe], dim=-1)\n            kv = self.wkv_b(self.kv_norm(kv))\n            kv = kv.view(bsz, seqlen, self.n_local_heads, self.qk_nope_head_dim + self.v_head_dim)\n            k_nope, v = torch.split(kv, [self.qk_nope_head_dim, self.v_head_dim], dim=-1)\n            k = torch.cat([k_nope, k_pe.expand(-1, -1, self.n_local_heads, -1)], dim=-1)\n            self.k_cache[:bsz, start_pos:end_pos] = k\n            self.v_cache[:bsz, start_pos:end_pos] = v\n            scores = torch.einsum(\"bshd,bthd->bsht\", q, self.k_cache[:bsz, :end_pos]) * self.softmax_scale\n        else:\n            wkv_b = self.wkv_b.weight if self.wkv_b.scale is None else weight_dequant(self.wkv_b.weight, self.wkv_b.scale, block_size) \n            wkv_b = wkv_b.view(self.n_local_heads, -1, self.kv_lora_rank)\n            q_nope = torch.einsum(\"bshd,hdc->bshc\", q_nope, wkv_b[:, :self.qk_nope_head_dim])\n            self.kv_cache[:bsz, start_pos:end_pos] = self.kv_norm(kv)\n            self.pe_cache[:bsz, start_pos:end_pos] = k_pe.squeeze(2)\n            scores = (torch.einsum(\"bshc,btc->bsht\", q_nope, self.kv_cache[:bsz, :end_pos]) +\n                      torch.einsum(\"bshr,btr->bsht\", q_pe, self.pe_cache[:bsz, :end_pos])) * self.softmax_scale\n        if mask is not None:\n            scores += mask.unsqueeze(1)\n        scores = scores.softmax(dim=-1, dtype=torch.float32).type_as(x)\n        if attn_impl == \"naive\":\n            x = torch.einsum(\"bsht,bthd->bshd\", scores, self.v_cache[:bsz, :end_pos])\n        else:\n            x = torch.einsum(\"bsht,btc->bshc\", scores, self.kv_cache[:bsz, :end_pos])\n            x = torch.einsum(\"bshc,hdc->bshd\", x, wkv_b[:, -self.v_head_dim:])\n        x = self.wo(x.flatten(2))\n        return x",
    "source": "github_repo:deepseek-ai/DeepSeek-V3",
    "file": "inference/model.py",
    "license": "MIT",
    "language": "python"
}