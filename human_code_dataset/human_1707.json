{
    "code": "class _PubSubServiceClass:\n    def __init__(self):\n        # 事件字典，元素为 回调函数列表\n        self._eventDict = {}\n        self._eventDictMutex = QMutex()  # 事件字典的锁\n        # 组字典，元素为 组列表。可以成组取消订阅，方便管理。\n        self._groupDict = {}\n        self._groupDictMutex = QMutex()  # 组字典的锁\n        # 信号\n        self._eventSignal = self._EventSignal()\n        self._eventSignal.signal.connect(self._publish)\n\n    # ========================= 【接口】 =========================\n\n    # 订阅事件\n    def subscribe(self, title, func):\n        if not callable(func):\n            logger.error(f\"订阅事件失败！传入 {func} 不是可调用对象。\")\n            return\n        self._eventDictMutex.lock()  # 上锁\n        if title not in self._eventDict:\n            self._eventDict[title] = [func]\n        else:\n            self._eventDict[title].append(func)\n        self._eventDictMutex.unlock()  # 解锁\n\n    # 订阅事件，可额外传入组名，以便管理。\n    def subscribeGroup(self, title, func, groupName):\n        self._groupDictMutex.lock()  # 上锁\n        if groupName not in self._groupDict:\n            self._groupDict[groupName] = [(title, func)]\n        else:\n            self._groupDict[groupName].append((title, func))\n        self._groupDictMutex.unlock()  # 解锁\n        self.subscribe(title, func)\n\n    # 取消订阅事件\n    def unsubscribe(self, title, func):\n        if not callable(func):\n            logger.error(f\"取消订阅事件失败！传入 {func} 不是可调用对象。\")\n            return\n        # 将回调函数从 对应标题的事件列表中 移除\n        self._eventDictMutex.lock()  # 上锁\n        if title in self._eventDict:\n            l = self._eventDict[title]\n            if func in l:\n                l.remove(func)\n        self._eventDictMutex.unlock()  # 解锁\n\n    # 取消订阅某个组的所有事件\n    def unsubscribeGroup(self, groupName):\n        self._groupDictMutex.lock()  # 上锁\n        if groupName in self._groupDict:\n            l = self._groupDict[groupName]\n            for i in l:\n                self.unsubscribe(i[0], i[1])\n            self._groupDict[groupName] = []\n        self._groupDictMutex.unlock()  # 解锁\n\n    # 发布事件\n    def publish(self, title, *args):\n        # 在主线程调用\n        if QThread.currentThread() == QCoreApplication.instance().thread():\n            self._publish(title, args)\n        # 在子线程调用\n        else:\n            self._eventSignal.signal.emit(title, args)\n\n    # ========================= 【实现】 =========================\n\n    # 发布事件的实现（主线程）\n    @Slot(str, \"QVariant\")\n    def _publish(self, title, args):\n        event_funcs = []\n        self._eventDictMutex.lock()  # 上锁\n        if title in self._eventDict:\n            event_funcs = self._eventDict[title].copy()  # 拷贝一份\n        self._eventDictMutex.unlock()  # 解锁\n        for func in event_funcs:\n            try:\n                func(*args)\n            except Exception:\n                logger.error(\n                    f\"发送事件异常。 title: {title}, args: {args}, func: {func}\",\n                    exc_info=True,\n                    stack_info=True,\n                )\n\n    # 信号类\n    class _EventSignal(QObject):\n        signal = Signal(str, \"QVariant\")",
    "source": "github_repo:hiroi-sora/Umi-OCR",
    "file": "UmiOCR-data/py_src/event_bus/pubsub_service.py",
    "license": "MIT",
    "language": "python"
}