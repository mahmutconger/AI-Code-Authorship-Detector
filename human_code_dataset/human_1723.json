{
    "code": "class PixmapProviderClass(QQuickImageProvider):\n    def __init__(self):\n        super().__init__(QQuickImageProvider.Pixmap)\n        self.pixmapDict = {}  # 缓存所有pixmap的字典\n        self.compDict = {}  # 缓存所有组件的字典\n        # 空图占位符\n        self._noneImg = None\n\n    # 向qml返回图片，imgID不存在时返回警告图\n    def requestPixmap(self, path, size=None, resSize=None):\n        if \"/\" in path:\n            compID, imgID = path.split(\"/\", 1)\n            self._delCompCache(compID, imgID)  # 先清缓存\n            if imgID in self.pixmapDict:\n                self.compDict[compID] = imgID  # 记录缓存\n                return self.pixmapDict[imgID]\n        else:  # 清空一个组件的缓存\n            self._delCompCache(path)\n        return self._getNoneImg()  # 返回占位符\n\n    # 添加一个Pixmap图片到提供器，返回imgID\n    def addPixmap(self, pixmap):\n        imgID = str(uuid4())\n        self.pixmapDict[imgID] = pixmap\n        return imgID\n\n    # 向py返回图片，相当于requestPixmap，但imgID不存在时返回None\n    def getPixmap(self, imgID):\n        return self.pixmapDict.get(imgID, None)\n\n    # 向py返回PIL对象\n    def getPilImage(self, imgID):\n        im = self.getPixmap(imgID)\n        if not im:\n            return None\n        try:\n            return ImageQt.fromqimage(im)\n        except Exception:\n            logger.error(\"QPixmap 转 PIL 失败。\", exc_info=True, stack_info=True)\n            return None\n\n    # py将PIL对象写回pixmapDict。主要是记录预处理的图像\n    # imgID可以已存在，也可以新添加\n    def setPilImage(self, img, imgID=\"\"):\n        try:\n            pixmap = ImageQt.toqpixmap(img)\n        except Exception as e:\n            logger.error(\"PIL 转 QPixmap 失败。\", exc_info=True, stack_info=True)\n            return f\"[Error] PIL 转 QPixmap 失败：{e}\"\n        if not imgID:\n            imgID = str(uuid4())\n        self.pixmapDict[imgID] = pixmap\n        return imgID\n\n    # 从pixmapDict缓存中删除一个或一批图片\n    # 一般无需手动调用此函数！缓存会自动管理、清除。\n    def delPixmap(self, imgIDs):\n        if isinstance(imgIDs, str):\n            imgIDs = [imgIDs]\n        for i in imgIDs:\n            if i in self.pixmapDict:\n                del self.pixmapDict[i]\n        logger.debug(f\"删除图片缓存，剩余：{len(self.pixmapDict)}\")\n\n    # 将 QPixmap 或 QImage 转换为字节\n    @staticmethod\n    def toBytes(image):\n        if isinstance(image, QPixmap):\n            image = image.toImage()\n        elif not isinstance(image, QImage):\n            raise ValueError(\n                f\"[Error] Only QImage or QPixmap can toBytes(), no {str(type(image))}.\"\n            )\n        byteArray = QByteArray()  # 创建一个字节数组\n        buffer = QBuffer(byteArray)  # 创建一个缓冲区\n        buffer.open(QBuffer.WriteOnly)\n        image.save(buffer, \"PNG\")  # 将 QImage 保存为字节数组\n        buffer.close()\n        bytesData = byteArray.data()  # 获取字节数组的内容\n        return bytesData\n\n    # 清空一个组件的缓存。imgID可选该组件下一次更新的图片ID。\n    def _delCompCache(self, compID, imgID=\"\"):\n        if compID in self.compDict:\n            last = self.compDict[compID]\n            if imgID and imgID == last:\n                logger.warning(f\"图片组件异常清理： {compID} {imgID}\")\n                return  # 如果下一次更新的ID等于当前ID，则为异常，不进行清理\n            if last in self.pixmapDict:\n                del self.pixmapDict[last]\n            del self.compDict[compID]\n\n    # 返回空图占位符\n    def _getNoneImg(self):\n        if self._noneImg:\n            return self._noneImg\n        pixmap = QPixmap(1, 100)\n        pixmap.fill(Qt.blue)\n        painter = QPainter(pixmap)  # 绘制警告条纹\n        painter.setPen(Qt.red)\n        painter.drawLine(0, 0, 0, 5)\n        painter.drawLine(0, 95, 0, 100)\n        self._noneImg = pixmap\n        return self._noneImg",
    "source": "github_repo:hiroi-sora/Umi-OCR",
    "file": "UmiOCR-data/py_src/image_controller/image_provider.py",
    "license": "MIT",
    "language": "python"
}