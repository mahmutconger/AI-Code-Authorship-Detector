{
    "code": "class FileSelector:\n    \"\"\"\n    Manages file selection and interaction within a project directory.\n\n    This class provides methods to interactively select files from the terminal,\n    save selections for later use, and integrate with system editors for direct\n    file modification.\n\n    Attributes\n    ----------\n    IGNORE_FOLDERS : set\n        A set of directory names to ignore during file selection.\n    FILE_LIST_NAME : str\n        The name of the file that stores the selected files list.\n    COMMENT : str\n        The comment string to be added to the top of the file selection list.\n    \"\"\"\n\n    IGNORE_FOLDERS = {\"site-packages\", \"node_modules\", \"venv\", \"__pycache__\"}\n    FILE_LIST_NAME = \"file_selection.toml\"\n    COMMENT = (\n        \"# Remove '#' to select a file or turn off linting.\\n\\n\"\n        \"# Linting with BLACK (Python) enhances code suggestions from LLMs. \"\n        \"To disable linting, uncomment the relevant option in the linting settings.\\n\\n\"\n        \"# gpt-engineer can only read selected files. \"\n        \"Including irrelevant files will degrade performance, \"\n        \"cost additional tokens and potentially overflow token limit.\\n\\n\"\n    )\n    LINTING_STRING = '[linting]\\n# \"linting\" = \"off\"\\n\\n'\n    is_linting = True\n\n    def __init__(self, project_path: Union[str, Path]):\n        \"\"\"\n        Initializes the FileSelector with a given project path.\n\n        Parameters\n        ----------\n        project_path : Union[str, Path]\n            The path to the project directory where file selection is to be performed.\n        \"\"\"\n        self.project_path = project_path\n        self.metadata_db = DiskMemory(metadata_path(self.project_path))\n        self.toml_path = self.metadata_db.path / self.FILE_LIST_NAME\n\n    def ask_for_files(self, skip_file_selection=False) -> tuple[FilesDict, bool]:\n        \"\"\"\n        Prompts the user to select files for context improvement.\n\n        This method supports selection from the terminal or using a previously saved list.\n        In test mode, it retrieves files from a predefined TOML configuration.\n\n        Returns\n        -------\n        FilesDict\n            A dictionary with file paths as keys and file contents as values.\n        \"\"\"\n\n        if os.getenv(\"GPTE_TEST_MODE\") or skip_file_selection:\n            # In test mode, retrieve files from a predefined TOML configuration\n            # also get from toml if skip_file_selector is active\n            assert self.FILE_LIST_NAME in self.metadata_db\n            selected_files = self.get_files_from_toml(self.project_path, self.toml_path)\n        else:\n            # Otherwise, use the editor file selector for interactive selection\n            if self.FILE_LIST_NAME in self.metadata_db:\n                print(\n                    f\"File list detected at {self.toml_path}. Edit or delete it if you want to select new files.\"\n                )\n                selected_files = self.editor_file_selector(self.project_path, False)\n            else:\n                selected_files = self.editor_file_selector(self.project_path, True)\n\n        content_dict = {}\n        for file_path in selected_files:\n            # selected files contains paths that are relative to the project path\n            try:\n                # to open the file we need the path from the cwd\n                with open(\n                    Path(self.project_path) / file_path, \"r\", encoding=\"utf-8\"\n                ) as content:\n                    content_dict[str(file_path)] = content.read()\n            except FileNotFoundError:\n                print(f\"Warning: File not found {file_path}\")\n            except UnicodeDecodeError:\n                print(f\"Warning: File not UTF-8 encoded {file_path}, skipping\")\n\n        return FilesDict(content_dict), self.is_linting\n\n    def editor_file_selector(\n        self, input_path: Union[str, Path], init: bool = True\n    ) -> List[str]:\n        \"\"\"\n        Provides an interactive file selection interface using a .toml file.\n\n        Parameters\n        ----------\n        input_path : Union[str, Path]\n            The path where file selection is to be performed.\n        init : bool, optional\n            Indicates whether to initialize the .toml file with the file tree.\n\n        Returns\n        -------\n        List[str]\n            A list of strings representing the paths of selected files.\n        \"\"\"\n\n        root_path = Path(input_path)\n        tree_dict = {}\n        toml_file = DiskMemory(metadata_path(input_path)).path / \"file_selection.toml\"\n        # Define the toml file path\n\n        # Initialize .toml file with file tree if in initial state\n        if init:\n            tree_dict = {x: \"selected\" for x in self.get_current_files(root_path)}\n\n            s = toml.dumps({\"files\": tree_dict})\n\n            # add comments on all lines that match = \"selected\"\n            s = \"\\n\".join(\n                [\n                    \"# \" + line if line.endswith(' = \"selected\"') else line\n                    for line in s.split(\"\\n\")\n                ]\n            )\n            # Write to the toml file\n            with open(toml_file, \"w\") as f:\n                f.write(self.COMMENT)\n                f.write(self.LINTING_STRING)\n                f.write(s)\n\n        else:\n            # Load existing files from the .toml configuration\n            all_files = self.get_current_files(root_path)\n            s = toml.dumps({\"files\": {x: \"selected\" for x in all_files}})\n\n            # get linting status from the toml file\n            with open(toml_file, \"r\") as file:\n                linting_status = toml.load(file)\n            if (\n                \"linting\" in linting_status\n                and linting_status[\"linting\"].get(\"linting\", \"\").lower() == \"off\"\n            ):\n                self.is_linting = False\n                self.LINTING_STRING = '[linting]\\n\"linting\" = \"off\"\\n\\n'\n                print(\"\\nLinting is disabled\")\n\n            with open(toml_file, \"r\") as file:\n                selected_files = toml.load(file)\n\n            lines = s.split(\"\\n\")\n            s = \"\\n\".join(\n                lines[:1]\n                + [\n                    line\n                    if line.split(\" = \")[0].strip('\"') in selected_files[\"files\"]\n                    else \"# \" + line\n                    for line in lines[1:]\n                ]\n            )\n\n            # Write the merged list back to the .toml for user review and modification\n            with open(toml_file, \"w\") as file:\n                file.write(self.COMMENT)  # Ensure to write the comment\n                file.write(self.LINTING_STRING)\n                file.write(s)\n\n        print(\n            \"Please select and deselect (add # in front) files, save it, and close it to continue...\"\n        )\n        self.open_with_default_editor(\n            toml_file\n        )  # Open the .toml file in the default editor for user modification\n        return self.get_files_from_toml(\n            input_path, toml_file\n        )  # Return the list of selected files after user edits\n\n    def open_with_default_editor(self, file_path: Union[str, Path]):\n        \"\"\"\n        Opens a file with the system's default text editor.\n\n        Parameters\n        ----------\n        file_path : Union[str, Path]\n            The path to the file to be opened in the text editor.\n        \"\"\"\n\n        editors = [\n            \"gedit\",\n            \"notepad\",\n            \"nvim\",\n            \"write\",\n            \"nano\",\n            \"vim\",\n            \"emacs\",\n        ]  # Putting the beginner-friendly text editor forward\n        chosen_editor = os.environ.get(\"EDITOR\")\n\n        # Try the preferred editor first, then fallback to common editors\n        if chosen_editor:\n            try:\n                subprocess.run([chosen_editor, file_path])\n                return\n            except Exception:\n                pass\n\n        for editor in editors:\n            try:\n                subprocess.run([editor, file_path])\n                return\n            except Exception:\n                continue\n        print(\"No suitable text editor found. Please edit the file manually.\")\n\n    def is_utf8(self, file_path: Union[str, Path]) -> bool:\n        \"\"\"\n        Checks if the file at the given path is UTF-8 encoded.\n\n        Parameters\n        ----------\n        file_path : Union[str, Path]\n            The path to the file to be checked.\n\n        Returns\n        -------\n        bool\n            True if the file is UTF-8 encoded, False otherwise.\n        \"\"\"\n\n        try:\n            with open(file_path, \"rb\") as file:\n                file.read().decode(\"utf-8\")\n                return True\n        except UnicodeDecodeError:\n            return False\n\n    def get_files_from_toml(\n        self, input_path: Union[str, Path], toml_file: Union[str, Path]\n    ) -> List[str]:\n        \"\"\"\n        Retrieves a list of selected files from a .toml configuration file.\n\n        Parameters\n        ----------\n        input_path : Union[str, Path]\n            The path where file selection was performed.\n        toml_file : Union[str, Path]\n            The path to the .toml file containing the file selection.\n\n        Returns\n        -------\n        List[str]\n            A list of strings representing the paths of selected files.\n\n        Raises\n        ------\n        Exception\n            If no files are selected in the .toml file.\n        \"\"\"\n        selected_files = []\n        edited_tree = toml.load(toml_file)  # Load the edited .toml file\n\n        # check if users have disabled linting or not\n        if (\n            \"linting\" in edited_tree\n            and edited_tree[\"linting\"].get(\"linting\", \"\").lower() == \"off\"\n        ):\n            self.is_linting = False\n            print(\"\\nLinting is disabled\")\n        else:\n            self.is_linting = True\n\n        # Iterate through the files in the .toml and append selected files to the list\n        for file, _ in edited_tree[\"files\"].items():\n            selected_files.append(file)\n\n        # Ensure that at least one file is selected, or raise an exception\n        if not selected_files:\n            raise Exception(\n                \"No files were selected. Please select at least one file to proceed.\"\n            )\n\n        print(f\"\\nYou have selected the following files:\\n{input_path}\")\n\n        project_path = Path(input_path).resolve()\n        selected_paths = set(\n            project_path.joinpath(file).resolve(strict=False) for file in selected_files\n        )\n\n        for displayable_path in DisplayablePath.make_tree(project_path):\n            if displayable_path.path in selected_paths:\n                p = displayable_path\n                while p.parent and p.parent.path not in selected_paths:\n                    selected_paths.add(p.parent.path)\n                    p = p.parent\n\n        try:\n            for displayable_path in DisplayablePath.make_tree(project_path):\n                if displayable_path.path in selected_paths:\n                    print(displayable_path.displayable())\n\n        except FileNotFoundError:\n            print(\"Specified path does not exist: \", project_path)\n        except Exception as e:\n            print(\"An error occurred while trying to display the file tree:\", e)\n\n        print(\"\\n\")\n        return selected_files\n\n    def merge_file_lists(\n        self, existing_files: Dict[str, Any], new_files: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Merges two lists of files, preserving the selection status.\n\n        Parameters\n        ----------\n        existing_files : Dict[str, Any]\n            The dictionary of existing files with their properties.\n        new_files : Dict[str, Any]\n            The dictionary of new files with their properties.\n\n        Returns\n        -------\n        Dict[str, Any]\n            The updated dictionary of files after merging.\n        \"\"\"\n        # Update the existing files with any new files or changes\n        for file, properties in new_files.items():\n            if file not in existing_files:\n                existing_files[file] = properties  # Add new files as unselected\n            # If you want to update other properties of existing files, you can do so here\n\n        return existing_files\n\n    def should_filter_file(self, file_path: Path, filters: List[str]) -> bool:\n        \"\"\"\n        Determines if a file should be ignored based on .gitignore rules.\n        \"\"\"\n        for f in filters:\n            if fnmatch.fnmatchcase(str(file_path), f):\n                return True\n        return False\n\n    def get_current_files(self, project_path: Union[str, Path]) -> List[str]:\n        \"\"\"\n        Generates a list of all files in the project directory. Will use .gitignore files if project_path is a git repository.\n\n        Parameters\n        ----------\n        project_path : Union[str, Path]\n            The path to the project directory.\n\n        Returns\n        -------\n        List[str]\n            A list of strings representing the relative paths of all files in the project directory.\n        \"\"\"\n        all_files = []\n        project_path = Path(\n            project_path\n        ).resolve()  # Ensure path is absolute and resolved\n\n        file_list = project_path.glob(\"**/*\")\n\n        for path in file_list:  # Recursively list all files\n            if path.is_file():\n                relpath = path.relative_to(project_path)\n                parts = relpath.parts\n                if any(part.startswith(\".\") for part in parts):\n                    continue  # Skip hidden files\n                if any(part in self.IGNORE_FOLDERS for part in parts):\n                    continue\n                if relpath.name == \"prompt\":\n                    continue  # Skip files named 'prompt'\n\n                all_files.append(str(relpath))\n\n        if is_git_repo(project_path) and \"projects\" not in project_path.parts:\n            all_files = filter_by_gitignore(project_path, all_files)\n\n        return sorted(all_files, key=lambda x: Path(x).as_posix())",
    "source": "github_repo:AntonOsika/gpt-engineer",
    "file": "gpt_engineer/applications/cli/file_selector.py",
    "license": "MIT",
    "language": "python"
}