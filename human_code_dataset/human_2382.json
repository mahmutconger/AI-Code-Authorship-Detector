{
    "code": "def audio_callback(self, indata: np.ndarray, outdata: np.ndarray, frames, times, status):\n        start_time = time.perf_counter()\n        indata = librosa.to_mono(indata.T)\n        if self.gui_config.threhold > -60:\n            rms = librosa.feature.rms(y=indata, frame_length=4 * self.zc, hop_length=self.zc)\n            db_threhold = (librosa.amplitude_to_db(rms, ref=1.0)[0] < self.gui_config.threhold)\n            for i in range(db_threhold.shape[0]):\n                if db_threhold[i]:\n                    indata[i * self.zc : (i + 1) * self.zc] = 0\n        self.input_wav[: -self.block_frame] = self.input_wav[self.block_frame :].clone()\n        self.input_wav[-self.block_frame :] = torch.from_numpy(indata).to(self.config.device)\n        self.input_wav_res[: -self.block_frame_16k] = self.input_wav_res[self.block_frame_16k :].clone()\n        if self.gui_config.I_noise_reduce and self.function == \"vc\":\n            input_wav = self.input_wav[-self.crossfade_frame - self.block_frame - 2 * self.zc :]\n            input_wav = self.tg(input_wav.unsqueeze(0), self.input_wav.unsqueeze(0))[0, 2 * self.zc :]\n            input_wav[: self.crossfade_frame] *= self.fade_in_window\n            input_wav[: self.crossfade_frame] += self.nr_buffer * self.fade_out_window\n            self.nr_buffer[:] = input_wav[-self.crossfade_frame :]\n            input_wav = torch.cat((self.res_buffer[:], input_wav[: self.block_frame]))\n            self.res_buffer[:] = input_wav[-2 * self.zc :]\n            self.input_wav_res[-self.block_frame_16k - 160 :] = self.resampler(input_wav)[160:]\n        else:\n            self.input_wav_res[-self.block_frame_16k - 160 :] = self.resampler(self.input_wav[-self.block_frame - 2 * self.zc :])[160:]\n        if self.function == \"vc\":\n            f0_extractor_frame = self.block_frame_16k + 800\n            if self.gui_config.f0method == \"rmvpe\":\n                f0_extractor_frame = (5120 * ((f0_extractor_frame - 1) // 5120 + 1) - 160)\n            infer_wav = self.rvc.infer(\n                self.input_wav_res,\n                self.input_wav_res[-f0_extractor_frame:].cpu().numpy(),\n                self.block_frame_16k,\n                self.valid_rate,\n                self.pitch,\n                self.pitchf,\n                self.gui_config.f0method,\n            )\n            infer_wav = infer_wav[-self.crossfade_frame - self.sola_search_frame - self.block_frame :]\n        else:\n            infer_wav = self.input_wav[-self.crossfade_frame - self.sola_search_frame - self.block_frame :].clone()\n        if (self.gui_config.O_noise_reduce and self.function == \"vc\") or (self.gui_config.I_noise_reduce and self.function == \"im\"):\n            self.output_buffer[: -self.block_frame] = self.output_buffer[self.block_frame :].clone()\n            self.output_buffer[-self.block_frame :] = infer_wav[-self.block_frame :]\n            infer_wav = self.tg(infer_wav.unsqueeze(0), self.output_buffer.unsqueeze(0)).squeeze(0)\n        if self.gui_config.rms_mix_rate < 1 and self.function == \"vc\":\n            rms1 = librosa.feature.rms(y=self.input_wav_res[-160 * infer_wav.shape[0] // self.zc :].cpu().numpy(), frame_length=640, hop_length=160)\n            rms1 = torch.from_numpy(rms1).to(self.config.device)\n            rms1 = F.interpolate(rms1.unsqueeze(0), size=infer_wav.shape[0] + 1, mode=\"linear\", align_corners=True)[0, 0, :-1]\n            rms2 = librosa.feature.rms(y=infer_wav[:].cpu().numpy(), frame_length=4 * self.zc, hop_length=self.zc)\n            rms2 = torch.from_numpy(rms2).to(self.config.device)\n            rms2 = F.interpolate(rms2.unsqueeze(0), size=infer_wav.shape[0] + 1, mode=\"linear\", align_corners=True)[0, 0, :-1]\n            rms2 = torch.max(rms2, torch.zeros_like(rms2) + 1e-3)\n            infer_wav *= torch.pow(rms1 / rms2, torch.tensor(1 - self.gui_config.rms_mix_rate))\n        conv_input = infer_wav[None, None, : self.crossfade_frame + self.sola_search_frame]\n        cor_nom = F.conv1d(conv_input, self.sola_buffer[None, None, :])\n        cor_den = torch.sqrt(F.conv1d(conv_input**2, torch.ones(1, 1, self.crossfade_frame, device=self.config.device)) + 1e-8)\n        if sys.platform == \"darwin\":\n            _, sola_offset = torch.max(cor_nom[0, 0] / cor_den[0, 0])\n            sola_offset = sola_offset.item()\n        else:\n            sola_offset = torch.argmax(cor_nom[0, 0] / cor_den[0, 0])\n        logger.info(f\"sola_offset = {sola_offset}\")\n        infer_wav = infer_wav[sola_offset : sola_offset + self.block_frame + self.crossfade_frame]\n        infer_wav[: self.crossfade_frame] *= self.fade_in_window\n        infer_wav[: self.crossfade_frame] += self.sola_buffer * self.fade_out_window\n        self.sola_buffer[:] = infer_wav[-self.crossfade_frame :]\n        if sys.platform == \"darwin\":\n            outdata[:] = infer_wav[: -self.crossfade_frame].cpu().numpy()[:, np.newaxis]\n        else:\n            outdata[:] = infer_wav[: -self.crossfade_frame].repeat(2, 1).t().cpu().numpy()\n        total_time = time.perf_counter() - start_time\n        logger.info(f\"Infer time: {total_time:.2f}\")",
    "source": "github_repo:RVC-Project/Retrieval-based-Voice-Conversion-WebUI",
    "file": "api_231006.py",
    "license": "MIT",
    "language": "python"
}