{
    "code": "class MessageManager:\n\tvision_detail_level: Literal['auto', 'low', 'high']\n\n\tdef __init__(\n\t\tself,\n\t\ttask: str,\n\t\tsystem_message: SystemMessage,\n\t\tfile_system: FileSystem,\n\t\tstate: MessageManagerState = MessageManagerState(),\n\t\tuse_thinking: bool = True,\n\t\tinclude_attributes: list[str] | None = None,\n\t\tsensitive_data: dict[str, str | dict[str, str]] | None = None,\n\t\tmax_history_items: int | None = None,\n\t\tvision_detail_level: Literal['auto', 'low', 'high'] = 'auto',\n\t\tinclude_tool_call_examples: bool = False,\n\t\tinclude_recent_events: bool = False,\n\t\tsample_images: list[ContentPartTextParam | ContentPartImageParam] | None = None,\n\t\tllm_screenshot_size: tuple[int, int] | None = None,\n\t):\n\t\tself.task = task\n\t\tself.state = state\n\t\tself.system_prompt = system_message\n\t\tself.file_system = file_system\n\t\tself.sensitive_data_description = ''\n\t\tself.use_thinking = use_thinking\n\t\tself.max_history_items = max_history_items\n\t\tself.vision_detail_level = vision_detail_level\n\t\tself.include_tool_call_examples = include_tool_call_examples\n\t\tself.include_recent_events = include_recent_events\n\t\tself.sample_images = sample_images\n\t\tself.llm_screenshot_size = llm_screenshot_size\n\n\t\tassert max_history_items is None or max_history_items > 5, 'max_history_items must be None or greater than 5'\n\n\t\t# Store settings as direct attributes instead of in a settings object\n\t\tself.include_attributes = include_attributes or []\n\t\tself.sensitive_data = sensitive_data\n\t\tself.last_input_messages = []\n\t\tself.last_state_message_text: str | None = None\n\t\t# Only initialize messages if state is empty\n\t\tif len(self.state.history.get_messages()) == 0:\n\t\t\tself._set_message_with_type(self.system_prompt, 'system')\n\n\t@property\n\tdef agent_history_description(self) -> str:\n\t\t\"\"\"Build agent history description from list of items, respecting max_history_items limit\"\"\"\n\t\tif self.max_history_items is None:\n\t\t\t# Include all items\n\t\t\treturn '\\n'.join(item.to_string() for item in self.state.agent_history_items)\n\n\t\ttotal_items = len(self.state.agent_history_items)\n\n\t\t# If we have fewer items than the limit, just return all items\n\t\tif total_items <= self.max_history_items:\n\t\t\treturn '\\n'.join(item.to_string() for item in self.state.agent_history_items)\n\n\t\t# We have more items than the limit, so we need to omit some\n\t\tomitted_count = total_items - self.max_history_items\n\n\t\t# Show first item + omitted message + most recent (max_history_items - 1) items\n\t\t# The omitted message doesn't count against the limit, only real history items do\n\t\trecent_items_count = self.max_history_items - 1  # -1 for first item\n\n\t\titems_to_include = [\n\t\t\tself.state.agent_history_items[0].to_string(),  # Keep first item (initialization)\n\t\t\tf'<sys>[... {omitted_count} previous steps omitted...]</sys>',\n\t\t]\n\t\t# Add most recent items\n\t\titems_to_include.extend([item.to_string() for item in self.state.agent_history_items[-recent_items_count:]])\n\n\t\treturn '\\n'.join(items_to_include)\n\n\tdef add_new_task(self, new_task: str) -> None:\n\t\tnew_task = '<follow_up_user_request> ' + new_task.strip() + ' </follow_up_user_request>'\n\t\tif '<initial_user_request>' not in self.task:\n\t\t\tself.task = '<initial_user_request>' + self.task + '</initial_user_request>'\n\t\tself.task += '\\n' + new_task\n\t\ttask_update_item = HistoryItem(system_message=new_task)\n\t\tself.state.agent_history_items.append(task_update_item)\n\n\tdef _update_agent_history_description(\n\t\tself,\n\t\tmodel_output: AgentOutput | None = None,\n\t\tresult: list[ActionResult] | None = None,\n\t\tstep_info: AgentStepInfo | None = None,\n\t) -> None:\n\t\t\"\"\"Update the agent history description\"\"\"\n\n\t\tif result is None:\n\t\t\tresult = []\n\t\tstep_number = step_info.step_number if step_info else None\n\n\t\tself.state.read_state_description = ''\n\t\tself.state.read_state_images = []  # Clear images from previous step\n\n\t\taction_results = ''\n\t\tresult_len = len(result)\n\t\tread_state_idx = 0\n\n\t\tfor idx, action_result in enumerate(result):\n\t\t\tif action_result.include_extracted_content_only_once and action_result.extracted_content:\n\t\t\t\tself.state.read_state_description += (\n\t\t\t\t\tf'<read_state_{read_state_idx}>\\n{action_result.extracted_content}\\n</read_state_{read_state_idx}>\\n'\n\t\t\t\t)\n\t\t\t\tread_state_idx += 1\n\t\t\t\tlogger.debug(f'Added extracted_content to read_state_description: {action_result.extracted_content}')\n\n\t\t\t# Store images for one-time inclusion in the next message\n\t\t\tif action_result.images:\n\t\t\t\tself.state.read_state_images.extend(action_result.images)\n\t\t\t\tlogger.debug(f'Added {len(action_result.images)} image(s) to read_state_images')\n\n\t\t\tif action_result.long_term_memory:\n\t\t\t\taction_results += f'{action_result.long_term_memory}\\n'\n\t\t\t\tlogger.debug(f'Added long_term_memory to action_results: {action_result.long_term_memory}')\n\t\t\telif action_result.extracted_content and not action_result.include_extracted_content_only_once:\n\t\t\t\taction_results += f'{action_result.extracted_content}\\n'\n\t\t\t\tlogger.debug(f'Added extracted_content to action_results: {action_result.extracted_content}')\n\n\t\t\tif action_result.error:\n\t\t\t\tif len(action_result.error) > 200:\n\t\t\t\t\terror_text = action_result.error[:100] + '......' + action_result.error[-100:]\n\t\t\t\telse:\n\t\t\t\t\terror_text = action_result.error\n\t\t\t\taction_results += f'{error_text}\\n'\n\t\t\t\tlogger.debug(f'Added error to action_results: {error_text}')\n\n\t\t# Simple 60k character limit for read_state_description\n\t\tMAX_CONTENT_SIZE = 60000\n\t\tif len(self.state.read_state_description) > MAX_CONTENT_SIZE:\n\t\t\tself.state.read_state_description = (\n\t\t\t\tself.state.read_state_description[:MAX_CONTENT_SIZE] + '\\n... [Content truncated at 60k characters]'\n\t\t\t)\n\t\t\tlogger.debug(f'Truncated read_state_description to {MAX_CONTENT_SIZE} characters')\n\n\t\tself.state.read_state_description = self.state.read_state_description.strip('\\n')\n\n\t\tif action_results:\n\t\t\taction_results = f'Result\\n{action_results}'\n\t\taction_results = action_results.strip('\\n') if action_results else None\n\n\t\t# Simple 60k character limit for action_results\n\t\tif action_results and len(action_results) > MAX_CONTENT_SIZE:\n\t\t\taction_results = action_results[:MAX_CONTENT_SIZE] + '\\n... [Content truncated at 60k characters]'\n\t\t\tlogger.debug(f'Truncated action_results to {MAX_CONTENT_SIZE} characters')\n\n\t\t# Build the history item\n\t\tif model_output is None:\n\t\t\t# Add history item for initial actions (step 0) or errors (step > 0)\n\t\t\tif step_number is not None:\n\t\t\t\tif step_number == 0 and action_results:\n\t\t\t\t\t# Step 0 with initial action results\n\t\t\t\t\thistory_item = HistoryItem(step_number=step_number, action_results=action_results)\n\t\t\t\t\tself.state.agent_history_items.append(history_item)\n\t\t\t\telif step_number > 0:\n\t\t\t\t\t# Error case for steps > 0\n\t\t\t\t\thistory_item = HistoryItem(step_number=step_number, error='Agent failed to output in the right format.')\n\t\t\t\t\tself.state.agent_history_items.append(history_item)\n\t\telse:\n\t\t\thistory_item = HistoryItem(\n\t\t\t\tstep_number=step_number,\n\t\t\t\tevaluation_previous_goal=model_output.current_state.evaluation_previous_goal,\n\t\t\t\tmemory=model_output.current_state.memory,\n\t\t\t\tnext_goal=model_output.current_state.next_goal,\n\t\t\t\taction_results=action_results,\n\t\t\t)\n\t\t\tself.state.agent_history_items.append(history_item)\n\n\tdef _get_sensitive_data_description(self, current_page_url) -> str:\n\t\tsensitive_data = self.sensitive_data\n\t\tif not sensitive_data:\n\t\t\treturn ''\n\n\t\t# Collect placeholders for sensitive data\n\t\tplaceholders: set[str] = set()\n\n\t\tfor key, value in sensitive_data.items():\n\t\t\tif isinstance(value, dict):\n\t\t\t\t# New format: {domain: {key: value}}\n\t\t\t\tif current_page_url and match_url_with_domain_pattern(current_page_url, key, True):\n\t\t\t\t\tplaceholders.update(value.keys())\n\t\t\telse:\n\t\t\t\t# Old format: {key: value}\n\t\t\t\tplaceholders.add(key)\n\n\t\tif placeholders:\n\t\t\tplaceholder_list = sorted(list(placeholders))\n\t\t\tinfo = f'Here are placeholders for sensitive data:\\n{placeholder_list}\\n'\n\t\t\tinfo += 'To use them, write <secret>the placeholder name</secret>'\n\t\t\treturn info\n\n\t\treturn ''\n\n\t@observe_debug(ignore_input=True, ignore_output=True, name='create_state_messages')\n\t@time_execution_sync('--create_state_messages')\n\tdef create_state_messages(\n\t\tself,\n\t\tbrowser_state_summary: BrowserStateSummary,\n\t\tmodel_output: AgentOutput | None = None,\n\t\tresult: list[ActionResult] | None = None,\n\t\tstep_info: AgentStepInfo | None = None,\n\t\tuse_vision: bool | Literal['auto'] = True,\n\t\tpage_filtered_actions: str | None = None,\n\t\tsensitive_data=None,\n\t\tavailable_file_paths: list[str] | None = None,  # Always pass current available_file_paths\n\t) -> None:\n\t\t\"\"\"Create single state message with all content\"\"\"\n\n\t\t# Clear contextual messages from previous steps to prevent accumulation\n\t\tself.state.history.context_messages.clear()\n\n\t\t# First, update the agent history items with the latest step results\n\t\tself._update_agent_history_description(model_output, result, step_info)\n\n\t\t# Use the passed sensitive_data parameter, falling back to instance variable\n\t\teffective_sensitive_data = sensitive_data if sensitive_data is not None else self.sensitive_data\n\t\tif effective_sensitive_data is not None:\n\t\t\t# Update instance variable to keep it in sync\n\t\t\tself.sensitive_data = effective_sensitive_data\n\t\t\tself.sensitive_data_description = self._get_sensitive_data_description(browser_state_summary.url)\n\n\t\t# Use only the current screenshot, but check if action results request screenshot inclusion\n\t\tscreenshots = []\n\t\tinclude_screenshot_requested = False\n\n\t\t# Check if any action results request screenshot inclusion\n\t\tif result:\n\t\t\tfor action_result in result:\n\t\t\t\tif action_result.metadata and action_result.metadata.get('include_screenshot'):\n\t\t\t\t\tinclude_screenshot_requested = True\n\t\t\t\t\tlogger.debug('Screenshot inclusion requested by action result')\n\t\t\t\t\tbreak\n\n\t\t# Handle different use_vision modes:\n\t\t# - \"auto\": Only include screenshot if explicitly requested by action (e.g., screenshot)\n\t\t# - True: Always include screenshot\n\t\t# - False: Never include screenshot\n\t\tinclude_screenshot = False\n\t\tif use_vision is True:\n\t\t\t# Always include screenshot when use_vision=True\n\t\t\tinclude_screenshot = True\n\t\telif use_vision == 'auto':\n\t\t\t# Only include screenshot if explicitly requested by action when use_vision=\"auto\"\n\t\t\tinclude_screenshot = include_screenshot_requested\n\t\t# else: use_vision is False, never include screenshot (include_screenshot stays False)\n\n\t\tif include_screenshot and browser_state_summary.screenshot:\n\t\t\tscreenshots.append(browser_state_summary.screenshot)\n\n\t\t# Use vision in the user message if screenshots are included\n\t\teffective_use_vision = len(screenshots) > 0\n\n\t\t# Create single state message with all content\n\t\tassert browser_state_summary\n\t\tstate_message = AgentMessagePrompt(\n\t\t\tbrowser_state_summary=browser_state_summary,\n\t\t\tfile_system=self.file_system,\n\t\t\tagent_history_description=self.agent_history_description,\n\t\t\tread_state_description=self.state.read_state_description,\n\t\t\ttask=self.task,\n\t\t\tinclude_attributes=self.include_attributes,\n\t\t\tstep_info=step_info,\n\t\t\tpage_filtered_actions=page_filtered_actions,\n\t\t\tsensitive_data=self.sensitive_data_description,\n\t\t\tavailable_file_paths=available_file_paths,\n\t\t\tscreenshots=screenshots,\n\t\t\tvision_detail_level=self.vision_detail_level,\n\t\t\tinclude_recent_events=self.include_recent_events,\n\t\t\tsample_images=self.sample_images,\n\t\t\tread_state_images=self.state.read_state_images,\n\t\t\tllm_screenshot_size=self.llm_screenshot_size,\n\t\t).get_user_message(effective_use_vision)\n\n\t\t# Store state message text for history\n\t\tself.last_state_message_text = state_message.text\n\n\t\t# Set the state message with caching enabled\n\t\tself._set_message_with_type(state_message, 'state')\n\n\tdef _log_history_lines(self) -> str:\n\t\t\"\"\"Generate a formatted log string of message history for debugging / printing to terminal\"\"\"\n\t\t# TODO: fix logging\n\n\t\t# try:\n\t\t# \ttotal_input_tokens = 0\n\t\t# \tmessage_lines = []\n\t\t# \tterminal_width = shutil.get_terminal_size((80, 20)).columns\n\n\t\t# \tfor i, m in enumerate(self.state.history.messages):\n\t\t# \t\ttry:\n\t\t# \t\t\ttotal_input_tokens += m.metadata.tokens\n\t\t# \t\t\tis_last_message = i == len(self.state.history.messages) - 1\n\n\t\t# \t\t\t# Extract content for logging\n\t\t# \t\t\tcontent = _log_extract_message_content(m.message, is_last_message, m.metadata)\n\n\t\t# \t\t\t# Format the message line(s)\n\t\t# \t\t\tlines = _log_format_message_line(m, content, is_last_message, terminal_width)\n\t\t# \t\t\tmessage_lines.extend(lines)\n\t\t# \t\texcept Exception as e:\n\t\t# \t\t\tlogger.warning(f'Failed to format message {i} for logging: {e}')\n\t\t# \t\t\t# Add a fallback line for this message\n\t\t# \t\t\tmessage_lines.append('â“[   ?]: [Error formatting this message]')\n\n\t\t# \t# Build final log message\n\t\t# \treturn (\n\t\t# \t\tf'ðŸ“œ LLM Message history ({len(self.state.history.messages)} messages, {total_input_tokens} tokens):\\n'\n\t\t# \t\t+ '\\n'.join(message_lines)\n\t\t# \t)\n\t\t# except Exception as e:\n\t\t# \tlogger.warning(f'Failed to generate history log: {e}')\n\t\t# \t# Return a minimal fallback message\n\t\t# \treturn f'ðŸ“œ LLM Message history (error generating log: {e})'\n\n\t\treturn ''\n\n\t@time_execution_sync('--get_messages')\n\tdef get_messages(self) -> list[BaseMessage]:\n\t\t\"\"\"Get current message list, potentially trimmed to max tokens\"\"\"\n\n\t\t# Log message history for debugging\n\t\tlogger.debug(self._log_history_lines())\n\t\tself.last_input_messages = self.state.history.get_messages()\n\t\treturn self.last_input_messages\n\n\tdef _set_message_with_type(self, message: BaseMessage, message_type: Literal['system', 'state']) -> None:\n\t\t\"\"\"Replace a specific state message slot with a new message\"\"\"\n\t\t# Don't filter system and state messages - they should contain placeholder tags or normal conversation\n\t\tif message_type == 'system':\n\t\t\tself.state.history.system_message = message\n\t\telif message_type == 'state':\n\t\t\tself.state.history.state_message = message\n\t\telse:\n\t\t\traise ValueError(f'Invalid state message type: {message_type}')\n\n\tdef _add_context_message(self, message: BaseMessage) -> None:\n\t\t\"\"\"Add a contextual message specific to this step (e.g., validation errors, retry instructions, timeout warnings)\"\"\"\n\t\t# Don't filter context messages - they should contain normal conversation or error messages\n\t\tself.state.history.context_messages.append(message)\n\n\t@time_execution_sync('--filter_sensitive_data')\n\tdef _filter_sensitive_data(self, message: BaseMessage) -> BaseMessage:\n\t\t\"\"\"Filter out sensitive data from the message\"\"\"\n\n\t\tdef replace_sensitive(value: str) -> str:\n\t\t\tif not self.sensitive_data:\n\t\t\t\treturn value\n\n\t\t\t# Collect all sensitive values, immediately converting old format to new format\n\t\t\tsensitive_values: dict[str, str] = {}\n\n\t\t\t# Process all sensitive data entries\n\t\t\tfor key_or_domain, content in self.sensitive_data.items():\n\t\t\t\tif isinstance(content, dict):\n\t\t\t\t\t# Already in new format: {domain: {key: value}}\n\t\t\t\t\tfor key, val in content.items():\n\t\t\t\t\t\tif val:  # Skip empty values\n\t\t\t\t\t\t\tsensitive_values[key] = val\n\t\t\t\telif content:  # Old format: {key: value} - convert to new format internally\n\t\t\t\t\t# We treat this as if it was {'http*://*': {key_or_domain: content}}\n\t\t\t\t\tsensitive_values[key_or_domain] = content\n\n\t\t\t# If there are no valid sensitive data entries, just return the original value\n\t\t\tif not sensitive_values:\n\t\t\t\tlogger.warning('No valid entries found in sensitive_data dictionary')\n\t\t\t\treturn value\n\n\t\t\t# Replace all valid sensitive data values with their placeholder tags\n\t\t\tfor key, val in sensitive_values.items():\n\t\t\t\tvalue = value.replace(val, f'<secret>{key}</secret>')\n\n\t\t\treturn value\n\n\t\tif isinstance(message.content, str):\n\t\t\tmessage.content = replace_sensitive(message.content)\n\t\telif isinstance(message.content, list):\n\t\t\tfor i, item in enumerate(message.content):\n\t\t\t\tif isinstance(item, ContentPartTextParam):\n\t\t\t\t\titem.text = replace_sensitive(item.text)\n\t\t\t\t\tmessage.content[i] = item\n\t\treturn message",
    "source": "github_repo:browser-use/browser-use",
    "file": "browser_use/agent/message_manager/service.py",
    "license": "MIT",
    "language": "python"
}