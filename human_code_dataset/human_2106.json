{
    "code": "class TFIDF(KeywordExtractor):\n\n    def __init__(self, idf_path=None):\n        self.tokenizer = jieba.dt\n        self.postokenizer = jieba.posseg.dt\n        self.stop_words = self.STOP_WORDS.copy()\n        self.idf_loader = IDFLoader(idf_path or DEFAULT_IDF)\n        self.idf_freq, self.median_idf = self.idf_loader.get_idf()\n\n    def set_idf_path(self, idf_path):\n        new_abs_path = _get_abs_path(idf_path)\n        if not os.path.isfile(new_abs_path):\n            raise Exception(\"jieba: file does not exist: \" + new_abs_path)\n        self.idf_loader.set_new_path(new_abs_path)\n        self.idf_freq, self.median_idf = self.idf_loader.get_idf()\n\n    def extract_tags(self, sentence, topK=20, withWeight=False, allowPOS=(), withFlag=False):\n        \"\"\"\n        Extract keywords from sentence using TF-IDF algorithm.\n        Parameter:\n            - topK: return how many top keywords. `None` for all possible words.\n            - withWeight: if True, return a list of (word, weight);\n                          if False, return a list of words.\n            - allowPOS: the allowed POS list eg. ['ns', 'n', 'vn', 'v','nr'].\n                        if the POS of w is not in this list,it will be filtered.\n            - withFlag: only work with allowPOS is not empty.\n                        if True, return a list of pair(word, weight) like posseg.cut\n                        if False, return a list of words\n        \"\"\"\n        if allowPOS:\n            allowPOS = frozenset(allowPOS)\n            words = self.postokenizer.cut(sentence)\n        else:\n            words = self.tokenizer.cut(sentence)\n        freq = {}\n        for w in words:\n            if allowPOS:\n                if w.flag not in allowPOS:\n                    continue\n                elif not withFlag:\n                    w = w.word\n            wc = w.word if allowPOS and withFlag else w\n            if len(wc.strip()) < 2 or wc.lower() in self.stop_words:\n                continue\n            freq[w] = freq.get(w, 0.0) + 1.0\n        total = sum(freq.values())\n        for k in freq:\n            kw = k.word if allowPOS and withFlag else k\n            freq[k] *= self.idf_freq.get(kw, self.median_idf) / total\n\n        if withWeight:\n            tags = sorted(freq.items(), key=itemgetter(1), reverse=True)\n        else:\n            tags = sorted(freq, key=freq.__getitem__, reverse=True)\n        if topK:\n            return tags[:topK]\n        else:\n            return tags",
    "source": "github_repo:fxsjy/jieba",
    "file": "jieba/analyse/tfidf.py",
    "license": "MIT",
    "language": "python"
}