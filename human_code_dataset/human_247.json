{
    "code": "def forward(self, x: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Forward pass for the gating mechanism.\n\n        Args:\n            x (torch.Tensor): Input tensor.\n\n        Returns:\n            Tuple[torch.Tensor, torch.Tensor]: Routing weights and selected expert indices.\n        \"\"\"\n        scores = linear(x, self.weight)\n        if self.score_func == \"softmax\":\n            scores = scores.softmax(dim=-1, dtype=torch.float32)\n        else:\n            scores = scores.sigmoid()\n        original_scores = scores\n        if self.bias is not None:\n            scores = scores + self.bias\n        if self.n_groups > 1:\n            scores = scores.view(x.size(0), self.n_groups, -1)\n            if self.bias is None:\n                group_scores = scores.amax(dim=-1)\n            else:\n                group_scores = scores.topk(2, dim=-1)[0].sum(dim=-1)\n            indices = group_scores.topk(self.topk_groups, dim=-1)[1]\n            mask = scores.new_ones(x.size(0), self.n_groups, dtype=bool).scatter_(1, indices, False)\n            scores = scores.masked_fill_(mask.unsqueeze(-1), float(\"-inf\")).flatten(1)\n        indices = torch.topk(scores, self.topk, dim=-1)[1]\n        weights = original_scores.gather(1, indices)\n        if self.score_func == \"sigmoid\":\n            weights /= weights.sum(dim=-1, keepdim=True)\n        weights *= self.route_scale\n        return weights.type_as(x), indices",
    "source": "github_repo:deepseek-ai/DeepSeek-V3",
    "file": "inference/model.py",
    "license": "MIT",
    "language": "python"
}