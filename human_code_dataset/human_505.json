{
    "code": "class Element:\n\t\"\"\"Element operations using BackendNodeId.\"\"\"\n\n\tdef __init__(\n\t\tself,\n\t\tbrowser_session: 'BrowserSession',\n\t\tbackend_node_id: int,\n\t\tsession_id: str | None = None,\n\t):\n\t\tself._browser_session = browser_session\n\t\tself._client = browser_session.cdp_client\n\t\tself._backend_node_id = backend_node_id\n\t\tself._session_id = session_id\n\n\tasync def _get_node_id(self) -> int:\n\t\t\"\"\"Get DOM node ID from backend node ID.\"\"\"\n\t\tparams: 'PushNodesByBackendIdsToFrontendParameters' = {'backendNodeIds': [self._backend_node_id]}\n\t\tresult = await self._client.send.DOM.pushNodesByBackendIdsToFrontend(params, session_id=self._session_id)\n\t\treturn result['nodeIds'][0]\n\n\tasync def _get_remote_object_id(self) -> str | None:\n\t\t\"\"\"Get remote object ID for this element.\"\"\"\n\t\tnode_id = await self._get_node_id()\n\t\tparams: 'ResolveNodeParameters' = {'nodeId': node_id}\n\t\tresult = await self._client.send.DOM.resolveNode(params, session_id=self._session_id)\n\t\tobject_id = result['object'].get('objectId', None)\n\n\t\tif not object_id:\n\t\t\treturn None\n\t\treturn object_id\n\n\tasync def click(\n\t\tself,\n\t\tbutton: 'MouseButton' = 'left',\n\t\tclick_count: int = 1,\n\t\tmodifiers: list[ModifierType] | None = None,\n\t) -> None:\n\t\t\"\"\"Click the element using the advanced watchdog implementation.\"\"\"\n\n\t\ttry:\n\t\t\t# Get viewport dimensions for visibility checks\n\t\t\tlayout_metrics = await self._client.send.Page.getLayoutMetrics(session_id=self._session_id)\n\t\t\tviewport_width = layout_metrics['layoutViewport']['clientWidth']\n\t\t\tviewport_height = layout_metrics['layoutViewport']['clientHeight']\n\n\t\t\t# Try multiple methods to get element geometry\n\t\t\tquads = []\n\n\t\t\t# Method 1: Try DOM.getContentQuads first (best for inline elements and complex layouts)\n\t\t\ttry:\n\t\t\t\tcontent_quads_result = await self._client.send.DOM.getContentQuads(\n\t\t\t\t\tparams={'backendNodeId': self._backend_node_id}, session_id=self._session_id\n\t\t\t\t)\n\t\t\t\tif 'quads' in content_quads_result and content_quads_result['quads']:\n\t\t\t\t\tquads = content_quads_result['quads']\n\t\t\texcept Exception:\n\t\t\t\tpass\n\n\t\t\t# Method 2: Fall back to DOM.getBoxModel\n\t\t\tif not quads:\n\t\t\t\ttry:\n\t\t\t\t\tbox_model = await self._client.send.DOM.getBoxModel(\n\t\t\t\t\t\tparams={'backendNodeId': self._backend_node_id}, session_id=self._session_id\n\t\t\t\t\t)\n\t\t\t\t\tif 'model' in box_model and 'content' in box_model['model']:\n\t\t\t\t\t\tcontent_quad = box_model['model']['content']\n\t\t\t\t\t\tif len(content_quad) >= 8:\n\t\t\t\t\t\t\t# Convert box model format to quad format\n\t\t\t\t\t\t\tquads = [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tcontent_quad[0],\n\t\t\t\t\t\t\t\t\tcontent_quad[1],  # x1, y1\n\t\t\t\t\t\t\t\t\tcontent_quad[2],\n\t\t\t\t\t\t\t\t\tcontent_quad[3],  # x2, y2\n\t\t\t\t\t\t\t\t\tcontent_quad[4],\n\t\t\t\t\t\t\t\t\tcontent_quad[5],  # x3, y3\n\t\t\t\t\t\t\t\t\tcontent_quad[6],\n\t\t\t\t\t\t\t\t\tcontent_quad[7],  # x4, y4\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t]\n\t\t\t\texcept Exception:\n\t\t\t\t\tpass\n\n\t\t\t# Method 3: Fall back to JavaScript getBoundingClientRect\n\t\t\tif not quads:\n\t\t\t\ttry:\n\t\t\t\t\tresult = await self._client.send.DOM.resolveNode(\n\t\t\t\t\t\tparams={'backendNodeId': self._backend_node_id}, session_id=self._session_id\n\t\t\t\t\t)\n\t\t\t\t\tif 'object' in result and 'objectId' in result['object']:\n\t\t\t\t\t\tobject_id = result['object']['objectId']\n\n\t\t\t\t\t\t# Get bounding rect via JavaScript\n\t\t\t\t\t\tbounds_result = await self._client.send.Runtime.callFunctionOn(\n\t\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t\t'functionDeclaration': \"\"\"\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\tconst rect = this.getBoundingClientRect();\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\tx: rect.left,\n\t\t\t\t\t\t\t\t\t\t\ty: rect.top,\n\t\t\t\t\t\t\t\t\t\t\twidth: rect.width,\n\t\t\t\t\t\t\t\t\t\t\theight: rect.height\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\"\"\",\n\t\t\t\t\t\t\t\t'objectId': object_id,\n\t\t\t\t\t\t\t\t'returnByValue': True,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsession_id=self._session_id,\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif 'result' in bounds_result and 'value' in bounds_result['result']:\n\t\t\t\t\t\t\trect = bounds_result['result']['value']\n\t\t\t\t\t\t\t# Convert rect to quad format\n\t\t\t\t\t\t\tx, y, w, h = rect['x'], rect['y'], rect['width'], rect['height']\n\t\t\t\t\t\t\tquads = [\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\ty,  # top-left\n\t\t\t\t\t\t\t\t\tx + w,\n\t\t\t\t\t\t\t\t\ty,  # top-right\n\t\t\t\t\t\t\t\t\tx + w,\n\t\t\t\t\t\t\t\t\ty + h,  # bottom-right\n\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\ty + h,  # bottom-left\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t]\n\t\t\t\texcept Exception:\n\t\t\t\t\tpass\n\n\t\t\t# If we still don't have quads, fall back to JS click\n\t\t\tif not quads:\n\t\t\t\ttry:\n\t\t\t\t\tresult = await self._client.send.DOM.resolveNode(\n\t\t\t\t\t\tparams={'backendNodeId': self._backend_node_id}, session_id=self._session_id\n\t\t\t\t\t)\n\t\t\t\t\tif 'object' not in result or 'objectId' not in result['object']:\n\t\t\t\t\t\traise Exception('Failed to find DOM element based on backendNodeId, maybe page content changed?')\n\t\t\t\t\tobject_id = result['object']['objectId']\n\n\t\t\t\t\tawait self._client.send.Runtime.callFunctionOn(\n\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t'functionDeclaration': 'function() { this.click(); }',\n\t\t\t\t\t\t\t'objectId': object_id,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsession_id=self._session_id,\n\t\t\t\t\t)\n\t\t\t\t\tawait asyncio.sleep(0.05)\n\t\t\t\t\treturn\n\t\t\t\texcept Exception as js_e:\n\t\t\t\t\traise Exception(f'Failed to click element: {js_e}')\n\n\t\t\t# Find the largest visible quad within the viewport\n\t\t\tbest_quad = None\n\t\t\tbest_area = 0\n\n\t\t\tfor quad in quads:\n\t\t\t\tif len(quad) < 8:\n\t\t\t\t\tcontinue\n\n\t\t\t\t# Calculate quad bounds\n\t\t\t\txs = [quad[i] for i in range(0, 8, 2)]\n\t\t\t\tys = [quad[i] for i in range(1, 8, 2)]\n\t\t\t\tmin_x, max_x = min(xs), max(xs)\n\t\t\t\tmin_y, max_y = min(ys), max(ys)\n\n\t\t\t\t# Check if quad intersects with viewport\n\t\t\t\tif max_x < 0 or max_y < 0 or min_x > viewport_width or min_y > viewport_height:\n\t\t\t\t\tcontinue  # Quad is completely outside viewport\n\n\t\t\t\t# Calculate visible area (intersection with viewport)\n\t\t\t\tvisible_min_x = max(0, min_x)\n\t\t\t\tvisible_max_x = min(viewport_width, max_x)\n\t\t\t\tvisible_min_y = max(0, min_y)\n\t\t\t\tvisible_max_y = min(viewport_height, max_y)\n\n\t\t\t\tvisible_width = visible_max_x - visible_min_x\n\t\t\t\tvisible_height = visible_max_y - visible_min_y\n\t\t\t\tvisible_area = visible_width * visible_height\n\n\t\t\t\tif visible_area > best_area:\n\t\t\t\t\tbest_area = visible_area\n\t\t\t\t\tbest_quad = quad\n\n\t\t\tif not best_quad:\n\t\t\t\t# No visible quad found, use the first quad anyway\n\t\t\t\tbest_quad = quads[0]\n\n\t\t\t# Calculate center point of the best quad\n\t\t\tcenter_x = sum(best_quad[i] for i in range(0, 8, 2)) / 4\n\t\t\tcenter_y = sum(best_quad[i] for i in range(1, 8, 2)) / 4\n\n\t\t\t# Ensure click point is within viewport bounds\n\t\t\tcenter_x = max(0, min(viewport_width - 1, center_x))\n\t\t\tcenter_y = max(0, min(viewport_height - 1, center_y))\n\n\t\t\t# Scroll element into view\n\t\t\ttry:\n\t\t\t\tawait self._client.send.DOM.scrollIntoViewIfNeeded(\n\t\t\t\t\tparams={'backendNodeId': self._backend_node_id}, session_id=self._session_id\n\t\t\t\t)\n\t\t\t\tawait asyncio.sleep(0.05)  # Wait for scroll to complete\n\t\t\texcept Exception:\n\t\t\t\tpass\n\n\t\t\t# Calculate modifier bitmask for CDP\n\t\t\tmodifier_value = 0\n\t\t\tif modifiers:\n\t\t\t\tmodifier_map = {'Alt': 1, 'Control': 2, 'Meta': 4, 'Shift': 8}\n\t\t\t\tfor mod in modifiers:\n\t\t\t\t\tmodifier_value |= modifier_map.get(mod, 0)\n\n\t\t\t# Perform the click using CDP\n\t\t\ttry:\n\t\t\t\t# Move mouse to element\n\t\t\t\tawait self._client.send.Input.dispatchMouseEvent(\n\t\t\t\t\tparams={\n\t\t\t\t\t\t'type': 'mouseMoved',\n\t\t\t\t\t\t'x': center_x,\n\t\t\t\t\t\t'y': center_y,\n\t\t\t\t\t},\n\t\t\t\t\tsession_id=self._session_id,\n\t\t\t\t)\n\t\t\t\tawait asyncio.sleep(0.05)\n\n\t\t\t\t# Mouse down\n\t\t\t\ttry:\n\t\t\t\t\tawait asyncio.wait_for(\n\t\t\t\t\t\tself._client.send.Input.dispatchMouseEvent(\n\t\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t\t'type': 'mousePressed',\n\t\t\t\t\t\t\t\t'x': center_x,\n\t\t\t\t\t\t\t\t'y': center_y,\n\t\t\t\t\t\t\t\t'button': button,\n\t\t\t\t\t\t\t\t'clickCount': click_count,\n\t\t\t\t\t\t\t\t'modifiers': modifier_value,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsession_id=self._session_id,\n\t\t\t\t\t\t),\n\t\t\t\t\t\ttimeout=1.0,  # 1 second timeout for mousePressed\n\t\t\t\t\t)\n\t\t\t\t\tawait asyncio.sleep(0.08)\n\t\t\t\texcept TimeoutError:\n\t\t\t\t\tpass  # Don't sleep if we timed out\n\n\t\t\t\t# Mouse up\n\t\t\t\ttry:\n\t\t\t\t\tawait asyncio.wait_for(\n\t\t\t\t\t\tself._client.send.Input.dispatchMouseEvent(\n\t\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t\t'type': 'mouseReleased',\n\t\t\t\t\t\t\t\t'x': center_x,\n\t\t\t\t\t\t\t\t'y': center_y,\n\t\t\t\t\t\t\t\t'button': button,\n\t\t\t\t\t\t\t\t'clickCount': click_count,\n\t\t\t\t\t\t\t\t'modifiers': modifier_value,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsession_id=self._session_id,\n\t\t\t\t\t\t),\n\t\t\t\t\t\ttimeout=3.0,  # 3 second timeout for mouseReleased\n\t\t\t\t\t)\n\t\t\t\texcept TimeoutError:\n\t\t\t\t\tpass\n\n\t\t\texcept Exception as e:\n\t\t\t\t# Fall back to JavaScript click via CDP\n\t\t\t\ttry:\n\t\t\t\t\tresult = await self._client.send.DOM.resolveNode(\n\t\t\t\t\t\tparams={'backendNodeId': self._backend_node_id}, session_id=self._session_id\n\t\t\t\t\t)\n\t\t\t\t\tif 'object' not in result or 'objectId' not in result['object']:\n\t\t\t\t\t\traise Exception('Failed to find DOM element based on backendNodeId, maybe page content changed?')\n\t\t\t\t\tobject_id = result['object']['objectId']\n\n\t\t\t\t\tawait self._client.send.Runtime.callFunctionOn(\n\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t'functionDeclaration': 'function() { this.click(); }',\n\t\t\t\t\t\t\t'objectId': object_id,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsession_id=self._session_id,\n\t\t\t\t\t)\n\t\t\t\t\tawait asyncio.sleep(0.1)\n\t\t\t\t\treturn\n\t\t\t\texcept Exception as js_e:\n\t\t\t\t\traise Exception(f'Failed to click element: {e}')\n\n\t\texcept Exception as e:\n\t\t\t# Extract key element info for error message\n\t\t\traise RuntimeError(f'Failed to click element: {e}')\n\n\tasync def fill(self, value: str, clear: bool = True) -> None:\n\t\t\"\"\"Fill the input element using proper CDP methods with improved focus handling.\"\"\"\n\t\ttry:\n\t\t\t# Use the existing CDP client and session\n\t\t\tcdp_client = self._client\n\t\t\tsession_id = self._session_id\n\t\t\tbackend_node_id = self._backend_node_id\n\n\t\t\t# Track coordinates for metadata\n\t\t\tinput_coordinates = None\n\n\t\t\t# Scroll element into view\n\t\t\ttry:\n\t\t\t\tawait cdp_client.send.DOM.scrollIntoViewIfNeeded(params={'backendNodeId': backend_node_id}, session_id=session_id)\n\t\t\t\tawait asyncio.sleep(0.01)\n\t\t\texcept Exception as e:\n\t\t\t\tlogger.warning(f'Failed to scroll element into view: {e}')\n\n\t\t\t# Get object ID for the element\n\t\t\tresult = await cdp_client.send.DOM.resolveNode(\n\t\t\t\tparams={'backendNodeId': backend_node_id},\n\t\t\t\tsession_id=session_id,\n\t\t\t)\n\t\t\tif 'object' not in result or 'objectId' not in result['object']:\n\t\t\t\traise RuntimeError('Failed to get object ID for element')\n\t\t\tobject_id = result['object']['objectId']\n\n\t\t\t# Get element coordinates for focus\n\t\t\ttry:\n\t\t\t\tbounds_result = await cdp_client.send.Runtime.callFunctionOn(\n\t\t\t\t\tparams={\n\t\t\t\t\t\t'functionDeclaration': 'function() { return this.getBoundingClientRect(); }',\n\t\t\t\t\t\t'objectId': object_id,\n\t\t\t\t\t\t'returnByValue': True,\n\t\t\t\t\t},\n\t\t\t\t\tsession_id=session_id,\n\t\t\t\t)\n\t\t\t\tif bounds_result.get('result', {}).get('value'):\n\t\t\t\t\tbounds = bounds_result['result']['value']  # type: ignore\n\t\t\t\t\tcenter_x = bounds['x'] + bounds['width'] / 2\n\t\t\t\t\tcenter_y = bounds['y'] + bounds['height'] / 2\n\t\t\t\t\tinput_coordinates = {'input_x': center_x, 'input_y': center_y}\n\t\t\t\t\tlogger.debug(f'Using element coordinates: x={center_x:.1f}, y={center_y:.1f}')\n\t\t\texcept Exception as e:\n\t\t\t\tlogger.debug(f'Could not get element coordinates: {e}')\n\n\t\t\t# Ensure session_id is not None\n\t\t\tif session_id is None:\n\t\t\t\traise RuntimeError('Session ID is required for fill operation')\n\n\t\t\t# Step 1: Focus the element\n\t\t\tfocused_successfully = await self._focus_element_simple(\n\t\t\t\tbackend_node_id=backend_node_id,\n\t\t\t\tobject_id=object_id,\n\t\t\t\tcdp_client=cdp_client,\n\t\t\t\tsession_id=session_id,\n\t\t\t\tinput_coordinates=input_coordinates,\n\t\t\t)\n\n\t\t\t# Step 2: Clear existing text if requested\n\t\t\tif clear:\n\t\t\t\tcleared_successfully = await self._clear_text_field(\n\t\t\t\t\tobject_id=object_id, cdp_client=cdp_client, session_id=session_id\n\t\t\t\t)\n\t\t\t\tif not cleared_successfully:\n\t\t\t\t\tlogger.warning('Text field clearing failed, typing may append to existing text')\n\n\t\t\t# Step 3: Type the text character by character using proper human-like key events\n\t\t\tlogger.debug(f'Typing text character by character: \"{value}\"')\n\n\t\t\tfor i, char in enumerate(value):\n\t\t\t\t# Handle newline characters as Enter key\n\t\t\t\tif char == '\\n':\n\t\t\t\t\t# Send proper Enter key sequence\n\t\t\t\t\tawait cdp_client.send.Input.dispatchKeyEvent(\n\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t'type': 'keyDown',\n\t\t\t\t\t\t\t'key': 'Enter',\n\t\t\t\t\t\t\t'code': 'Enter',\n\t\t\t\t\t\t\t'windowsVirtualKeyCode': 13,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsession_id=session_id,\n\t\t\t\t\t)\n\n\t\t\t\t\t# Small delay to emulate human typing speed\n\t\t\t\t\tawait asyncio.sleep(0.001)\n\n\t\t\t\t\t# Send char event with carriage return\n\t\t\t\t\tawait cdp_client.send.Input.dispatchKeyEvent(\n\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t'type': 'char',\n\t\t\t\t\t\t\t'text': '\\r',\n\t\t\t\t\t\t\t'key': 'Enter',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsession_id=session_id,\n\t\t\t\t\t)\n\n\t\t\t\t\t# Send keyUp event\n\t\t\t\t\tawait cdp_client.send.Input.dispatchKeyEvent(\n\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t'type': 'keyUp',\n\t\t\t\t\t\t\t'key': 'Enter',\n\t\t\t\t\t\t\t'code': 'Enter',\n\t\t\t\t\t\t\t'windowsVirtualKeyCode': 13,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsession_id=session_id,\n\t\t\t\t\t)\n\t\t\t\telse:\n\t\t\t\t\t# Handle regular characters\n\t\t\t\t\t# Get proper modifiers, VK code, and base key for the character\n\t\t\t\t\tmodifiers, vk_code, base_key = self._get_char_modifiers_and_vk(char)\n\t\t\t\t\tkey_code = self._get_key_code_for_char(base_key)\n\n\t\t\t\t\t# Step 1: Send keyDown event (NO text parameter)\n\t\t\t\t\tawait cdp_client.send.Input.dispatchKeyEvent(\n\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t'type': 'keyDown',\n\t\t\t\t\t\t\t'key': base_key,\n\t\t\t\t\t\t\t'code': key_code,\n\t\t\t\t\t\t\t'modifiers': modifiers,\n\t\t\t\t\t\t\t'windowsVirtualKeyCode': vk_code,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsession_id=session_id,\n\t\t\t\t\t)\n\n\t\t\t\t\t# Small delay to emulate human typing speed\n\t\t\t\t\tawait asyncio.sleep(0.001)\n\n\t\t\t\t\t# Step 2: Send char event (WITH text parameter) - this is crucial for text input\n\t\t\t\t\tawait cdp_client.send.Input.dispatchKeyEvent(\n\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t'type': 'char',\n\t\t\t\t\t\t\t'text': char,\n\t\t\t\t\t\t\t'key': char,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsession_id=session_id,\n\t\t\t\t\t)\n\n\t\t\t\t\t# Step 3: Send keyUp event (NO text parameter)\n\t\t\t\t\tawait cdp_client.send.Input.dispatchKeyEvent(\n\t\t\t\t\t\tparams={\n\t\t\t\t\t\t\t'type': 'keyUp',\n\t\t\t\t\t\t\t'key': base_key,\n\t\t\t\t\t\t\t'code': key_code,\n\t\t\t\t\t\t\t'modifiers': modifiers,\n\t\t\t\t\t\t\t'windowsVirtualKeyCode': vk_code,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsession_id=session_id,\n\t\t\t\t\t)\n\n\t\t\t\t# Add 18ms delay between keystrokes\n\t\t\t\tawait asyncio.sleep(0.018)\n\n\t\texcept Exception as e:\n\t\t\traise Exception(f'Failed to fill element: {str(e)}')\n\n\tasync def hover(self) -> None:\n\t\t\"\"\"Hover over the element.\"\"\"\n\t\tbox = await self.get_bounding_box()\n\t\tif not box:\n\t\t\traise RuntimeError('Element is not visible or has no bounding box')\n\n\t\tx = box['x'] + box['width'] / 2\n\t\ty = box['y'] + box['height'] / 2\n\n\t\tparams: 'DispatchMouseEventParameters' = {'type': 'mouseMoved', 'x': x, 'y': y}\n\t\tawait self._client.send.Input.dispatchMouseEvent(params, session_id=self._session_id)\n\n\tasync def focus(self) -> None:\n\t\t\"\"\"Focus the element.\"\"\"\n\t\tnode_id = await self._get_node_id()\n\t\tparams: 'FocusParameters' = {'nodeId': node_id}\n\t\tawait self._client.send.DOM.focus(params, session_id=self._session_id)\n\n\tasync def check(self) -> None:\n\t\t\"\"\"Check or uncheck a checkbox/radio button.\"\"\"\n\t\tawait self.click()\n\n\tasync def select_option(self, values: str | list[str]) -> None:\n\t\t\"\"\"Select option(s) in a select element.\"\"\"\n\t\tif isinstance(values, str):\n\t\t\tvalues = [values]\n\n\t\t# Focus the element first\n\t\ttry:\n\t\t\tawait self.focus()\n\t\texcept Exception:\n\t\t\tlogger.warning('Failed to focus element')\n\n\t\t# For select elements, we need to find option elements and click them\n\t\t# This is a simplified approach - in practice, you might need to handle\n\t\t# different select types (single vs multi-select) differently\n\t\tnode_id = await self._get_node_id()\n\n\t\t# Request child nodes to get the options\n\t\tparams: 'RequestChildNodesParameters' = {'nodeId': node_id, 'depth': 1}\n\t\tawait self._client.send.DOM.requestChildNodes(params, session_id=self._session_id)\n\n\t\t# Get the updated node description with children\n\t\tdescribe_params: 'DescribeNodeParameters' = {'nodeId': node_id, 'depth': 1}\n\t\tdescribe_result = await self._client.send.DOM.describeNode(describe_params, session_id=self._session_id)\n\n\t\tselect_node = describe_result['node']\n\n\t\t# Find and select matching options\n\t\tfor child in select_node.get('children', []):\n\t\t\tif child.get('nodeName', '').lower() == 'option':\n\t\t\t\t# Get option attributes\n\t\t\t\tattrs = child.get('attributes', [])\n\t\t\t\toption_attrs = {}\n\t\t\t\tfor i in range(0, len(attrs), 2):\n\t\t\t\t\tif i + 1 < len(attrs):\n\t\t\t\t\t\toption_attrs[attrs[i]] = attrs[i + 1]\n\n\t\t\t\toption_value = option_attrs.get('value', '')\n\t\t\t\toption_text = child.get('nodeValue', '')\n\n\t\t\t\t# Check if this option should be selected\n\t\t\t\tshould_select = option_value in values or option_text in values\n\n\t\t\t\tif should_select:\n\t\t\t\t\t# Click the option to select it\n\t\t\t\t\toption_node_id = child.get('nodeId')\n\t\t\t\t\tif option_node_id:\n\t\t\t\t\t\t# Get backend node ID for the option\n\t\t\t\t\t\toption_describe_params: 'DescribeNodeParameters' = {'nodeId': option_node_id}\n\t\t\t\t\t\toption_backend_result = await self._client.send.DOM.describeNode(\n\t\t\t\t\t\t\toption_describe_params, session_id=self._session_id\n\t\t\t\t\t\t)\n\t\t\t\t\t\toption_backend_id = option_backend_result['node']['backendNodeId']\n\n\t\t\t\t\t\t# Create an Element for the option and click it\n\t\t\t\t\t\toption_element = Element(self._browser_session, option_backend_id, self._session_id)\n\t\t\t\t\t\tawait option_element.click()\n\n\tasync def drag_to(\n\t\tself,\n\t\ttarget: Union['Element', Position],\n\t\tsource_position: Position | None = None,\n\t\ttarget_position: Position | None = None,\n\t) -> None:\n\t\t\"\"\"Drag this element to another element or position.\"\"\"\n\t\t# Get source coordinates\n\t\tif source_position:\n\t\t\tsource_x = source_position['x']\n\t\t\tsource_y = source_position['y']\n\t\telse:\n\t\t\tsource_box = await self.get_bounding_box()\n\t\t\tif not source_box:\n\t\t\t\traise RuntimeError('Source element is not visible')\n\t\t\tsource_x = source_box['x'] + source_box['width'] / 2\n\t\t\tsource_y = source_box['y'] + source_box['height'] / 2\n\n\t\t# Get target coordinates\n\t\tif isinstance(target, dict) and 'x' in target and 'y' in target:\n\t\t\ttarget_x = target['x']\n\t\t\ttarget_y = target['y']\n\t\telse:\n\t\t\tif target_position:\n\t\t\t\ttarget_box = await target.get_bounding_box()\n\t\t\t\tif not target_box:\n\t\t\t\t\traise RuntimeError('Target element is not visible')\n\t\t\t\ttarget_x = target_box['x'] + target_position['x']\n\t\t\t\ttarget_y = target_box['y'] + target_position['y']\n\t\t\telse:\n\t\t\t\ttarget_box = await target.get_bounding_box()\n\t\t\t\tif not target_box:\n\t\t\t\t\traise RuntimeError('Target element is not visible')\n\t\t\t\ttarget_x = target_box['x'] + target_box['width'] / 2\n\t\t\t\ttarget_y = target_box['y'] + target_box['height'] / 2\n\n\t\t# Perform drag operation\n\t\tawait self._client.send.Input.dispatchMouseEvent(\n\t\t\t{'type': 'mousePressed', 'x': source_x, 'y': source_y, 'button': 'left'},\n\t\t\tsession_id=self._session_id,\n\t\t)\n\n\t\tawait self._client.send.Input.dispatchMouseEvent(\n\t\t\t{'type': 'mouseMoved', 'x': target_x, 'y': target_y},\n\t\t\tsession_id=self._session_id,\n\t\t)\n\n\t\tawait self._client.send.Input.dispatchMouseEvent(\n\t\t\t{'type': 'mouseReleased', 'x': target_x, 'y': target_y, 'button': 'left'},\n\t\t\tsession_id=self._session_id,\n\t\t)\n\n\t# Element properties and queries\n\tasync def get_attribute(self, name: str) -> str | None:\n\t\t\"\"\"Get an attribute value.\"\"\"\n\t\tnode_id = await self._get_node_id()\n\t\tparams: 'GetAttributesParameters' = {'nodeId': node_id}\n\t\tresult = await self._client.send.DOM.getAttributes(params, session_id=self._session_id)\n\n\t\tattributes = result['attributes']\n\t\tfor i in range(0, len(attributes), 2):\n\t\t\tif attributes[i] == name:\n\t\t\t\treturn attributes[i + 1]\n\t\treturn None\n\n\tasync def get_bounding_box(self) -> BoundingBox | None:\n\t\t\"\"\"Get the bounding box of the element.\"\"\"\n\t\ttry:\n\t\t\tnode_id = await self._get_node_id()\n\t\t\tparams: 'GetBoxModelParameters' = {'nodeId': node_id}\n\t\t\tresult = await self._client.send.DOM.getBoxModel(params, session_id=self._session_id)\n\n\t\t\tif 'model' not in result:\n\t\t\t\treturn None\n\n\t\t\t# Get content box (first 8 values are content quad: x1,y1,x2,y2,x3,y3,x4,y4)\n\t\t\tcontent = result['model']['content']\n\t\t\tif len(content) < 8:\n\t\t\t\treturn None\n\n\t\t\t# Calculate bounding box from quad\n\t\t\tx_coords = [content[i] for i in range(0, 8, 2)]\n\t\t\ty_coords = [content[i] for i in range(1, 8, 2)]\n\n\t\t\tx = min(x_coords)\n\t\t\ty = min(y_coords)\n\t\t\twidth = max(x_coords) - x\n\t\t\theight = max(y_coords) - y\n\n\t\t\treturn BoundingBox(x=x, y=y, width=width, height=height)\n\n\t\texcept Exception:\n\t\t\treturn None\n\n\tasync def screenshot(self, format: str = 'png', quality: int | None = None) -> str:\n\t\t\"\"\"Take a screenshot of this element and return base64 encoded image.\n\n\t\tArgs:\n\t\t\tformat: Image format ('jpeg', 'png', 'webp')\n\t\t\tquality: Quality 0-100 for JPEG format\n\n\t\tReturns:\n\t\t\tBase64-encoded image data\n\t\t\"\"\"\n\t\t# Get element's bounding box\n\t\tbox = await self.get_bounding_box()\n\t\tif not box:\n\t\t\traise RuntimeError('Element is not visible or has no bounding box')\n\n\t\t# Create viewport clip for the element\n\t\tviewport: 'Viewport' = {'x': box['x'], 'y': box['y'], 'width': box['width'], 'height': box['height'], 'scale': 1.0}\n\n\t\t# Prepare screenshot parameters\n\t\tparams: 'CaptureScreenshotParameters' = {'format': format, 'clip': viewport}\n\n\t\tif quality is not None and format.lower() == 'jpeg':\n\t\t\tparams['quality'] = quality\n\n\t\t# Take screenshot\n\t\tresult = await self._client.send.Page.captureScreenshot(params, session_id=self._session_id)\n\n\t\treturn result['data']\n\n\tasync def evaluate(self, page_function: str, *args) -> str:\n\t\t\"\"\"Execute JavaScript code in the context of this element.\n\n\t\tThe JavaScript code executes with 'this' bound to the element, allowing direct\n\t\taccess to element properties and methods.\n\n\t\tArgs:\n\t\t\tpage_function: JavaScript code that MUST start with (...args) => format\n\t\t\t*args: Arguments to pass to the function\n\n\t\tReturns:\n\t\t\tString representation of the JavaScript execution result.\n\t\t\tObjects and arrays are JSON-stringified.\n\n\t\tExample:\n\t\t\t# Get element's text content\n\t\t\ttext = await element.evaluate(\"() => this.textContent\")\n\n\t\t\t# Set style with argument\n\t\t\tawait element.evaluate(\"(color) => this.style.color = color\", \"red\")\n\n\t\t\t# Get computed style\n\t\t\tcolor = await element.evaluate(\"() => getComputedStyle(this).color\")\n\n\t\t\t# Async operations\n\t\t\tresult = await element.evaluate(\"async () => { await new Promise(r => setTimeout(r, 100)); return this.id; }\")\n\t\t\"\"\"\n\t\t# Get remote object ID for this element\n\t\tobject_id = await self._get_remote_object_id()\n\t\tif not object_id:\n\t\t\traise RuntimeError('Element has no remote object ID (element may be detached from DOM)')\n\n\t\t# Validate arrow function format (allow async prefix)\n\t\tpage_function = page_function.strip()\n\t\t# Check for arrow function with optional async prefix\n\t\tif not ('=>' in page_function and (page_function.startswith('(') or page_function.startswith('async'))):\n\t\t\traise ValueError(\n\t\t\t\tf'JavaScript code must start with (...args) => or async (...args) => format. Got: {page_function[:50]}...'\n\t\t\t)\n\n\t\t# Convert arrow function to function declaration for CallFunctionOn\n\t\t# CallFunctionOn expects 'function(...args) { ... }' format, not arrow functions\n\t\t# We need to convert: '() => expression' to 'function() { return expression; }'\n\t\t# or: '(x, y) => { statements }' to 'function(x, y) { statements }'\n\n\t\t# Extract parameters and body from arrow function\n\t\timport re\n\n\t\t# Check if it's an async arrow function\n\t\tis_async = page_function.strip().startswith('async')\n\t\tasync_prefix = 'async ' if is_async else ''\n\n\t\t# Match: (params) => body  or  async (params) => body\n\t\t# Strip 'async' prefix if present for parsing\n\t\tfunc_to_parse = page_function.strip()\n\t\tif is_async:\n\t\t\tfunc_to_parse = func_to_parse[5:].strip()  # Remove 'async' prefix\n\n\t\tarrow_match = re.match(r'\\s*\\(([^)]*)\\)\\s*=>\\s*(.+)', func_to_parse, re.DOTALL)\n\t\tif not arrow_match:\n\t\t\traise ValueError(f'Could not parse arrow function: {page_function[:50]}...')\n\n\t\tparams_str = arrow_match.group(1).strip()  # e.g., '', 'x', 'x, y'\n\t\tbody = arrow_match.group(2).strip()\n\n\t\t# If body doesn't start with {, it's an expression that needs implicit return\n\t\tif not body.startswith('{'):\n\t\t\tfunction_declaration = f'{async_prefix}function({params_str}) {{ return {body}; }}'\n\t\telse:\n\t\t\t# Body already has braces, use as-is\n\t\t\tfunction_declaration = f'{async_prefix}function({params_str}) {body}'\n\n\t\t# Build CallArgument list for args if provided\n\t\tcall_arguments = []\n\t\tif args:\n\t\t\tfrom cdp_use.cdp.runtime.types import CallArgument\n\n\t\t\tfor arg in args:\n\t\t\t\t# Convert Python values to CallArgument format\n\t\t\t\tcall_arguments.append(CallArgument(value=arg))\n\n\t\t# Prepare CallFunctionOn parameters\n\n\t\tparams: 'CallFunctionOnParameters' = {\n\t\t\t'functionDeclaration': function_declaration,\n\t\t\t'objectId': object_id,\n\t\t\t'returnByValue': True,\n\t\t\t'awaitPromise': True,\n\t\t}\n\n\t\tif call_arguments:\n\t\t\tparams['arguments'] = call_arguments\n\n\t\t# Execute the function on the element\n\t\tresult = await self._client.send.Runtime.callFunctionOn(\n\t\t\tparams,\n\t\t\tsession_id=self._session_id,\n\t\t)\n\n\t\t# Handle exceptions\n\t\tif 'exceptionDetails' in result:\n\t\t\traise RuntimeError(f'JavaScript evaluation failed: {result[\"exceptionDetails\"]}')\n\n\t\t# Extract and return value\n\t\tvalue = result.get('result', {}).get('value')\n\n\t\t# Return string representation (matching Page.evaluate behavior)\n\t\tif value is None:\n\t\t\treturn ''\n\t\telif isinstance(value, str):\n\t\t\treturn value\n\t\telse:\n\t\t\t# Convert objects, numbers, booleans to string\n\t\t\timport json\n\n\t\t\ttry:\n\t\t\t\treturn json.dumps(value) if isinstance(value, (dict, list)) else str(value)\n\t\t\texcept (TypeError, ValueError):\n\t\t\t\treturn str(value)\n\n\t# Helpers for modifiers etc\n\tdef _get_char_modifiers_and_vk(self, char: str) -> tuple[int, int, str]:\n\t\t\"\"\"Get modifiers, virtual key code, and base key for a character.\n\n\t\tReturns:\n\t\t\t(modifiers, windowsVirtualKeyCode, base_key)\n\t\t\"\"\"\n\t\t# Characters that require Shift modifier\n\t\tshift_chars = {\n\t\t\t'!': ('1', 49),\n\t\t\t'@': ('2', 50),\n\t\t\t'#': ('3', 51),\n\t\t\t'$': ('4', 52),\n\t\t\t'%': ('5', 53),\n\t\t\t'^': ('6', 54),\n\t\t\t'&': ('7', 55),\n\t\t\t'*': ('8', 56),\n\t\t\t'(': ('9', 57),\n\t\t\t')': ('0', 48),\n\t\t\t'_': ('-', 189),\n\t\t\t'+': ('=', 187),\n\t\t\t'{': ('[', 219),\n\t\t\t'}': (']', 221),\n\t\t\t'|': ('\\\\', 220),\n\t\t\t':': (';', 186),\n\t\t\t'\"': (\"'\", 222),\n\t\t\t'<': (',', 188),\n\t\t\t'>': ('.', 190),\n\t\t\t'?': ('/', 191),\n\t\t\t'~': ('`', 192),\n\t\t}\n\n\t\t# Check if character requires Shift\n\t\tif char in shift_chars:\n\t\t\tbase_key, vk_code = shift_chars[char]\n\t\t\treturn (8, vk_code, base_key)  # Shift=8\n\n\t\t# Uppercase letters require Shift\n\t\tif char.isupper():\n\t\t\treturn (8, ord(char), char.lower())  # Shift=8\n\n\t\t# Lowercase letters\n\t\tif char.islower():\n\t\t\treturn (0, ord(char.upper()), char)\n\n\t\t# Numbers\n\t\tif char.isdigit():\n\t\t\treturn (0, ord(char), char)\n\n\t\t# Special characters without Shift\n\t\tno_shift_chars = {\n\t\t\t' ': 32,\n\t\t\t'-': 189,\n\t\t\t'=': 187,\n\t\t\t'[': 219,\n\t\t\t']': 221,\n\t\t\t'\\\\': 220,\n\t\t\t';': 186,\n\t\t\t\"'\": 222,\n\t\t\t',': 188,\n\t\t\t'.': 190,\n\t\t\t'/': 191,\n\t\t\t'`': 192,\n\t\t}\n\n\t\tif char in no_shift_chars:\n\t\t\treturn (0, no_shift_chars[char], char)\n\n\t\t# Fallback\n\t\treturn (0, ord(char.upper()) if char.isalpha() else ord(char), char)\n\n\tdef _get_key_code_for_char(self, char: str) -> str:\n\t\t\"\"\"Get the proper key code for a character (like Playwright does).\"\"\"\n\t\t# Key code mapping for common characters (using proper base keys + modifiers)\n\t\tkey_codes = {\n\t\t\t' ': 'Space',\n\t\t\t'.': 'Period',\n\t\t\t',': 'Comma',\n\t\t\t'-': 'Minus',\n\t\t\t'_': 'Minus',  # Underscore uses Minus with Shift\n\t\t\t'@': 'Digit2',  # @ uses Digit2 with Shift\n\t\t\t'!': 'Digit1',  # ! uses Digit1 with Shift (not 'Exclamation')\n\t\t\t'?': 'Slash',  # ? uses Slash with Shift\n\t\t\t':': 'Semicolon',  # : uses Semicolon with Shift\n\t\t\t';': 'Semicolon',\n\t\t\t'(': 'Digit9',  # ( uses Digit9 with Shift\n\t\t\t')': 'Digit0',  # ) uses Digit0 with Shift\n\t\t\t'[': 'BracketLeft',\n\t\t\t']': 'BracketRight',\n\t\t\t'{': 'BracketLeft',  # { uses BracketLeft with Shift\n\t\t\t'}': 'BracketRight',  # } uses BracketRight with Shift\n\t\t\t'/': 'Slash',\n\t\t\t'\\\\': 'Backslash',\n\t\t\t'=': 'Equal',\n\t\t\t'+': 'Equal',  # + uses Equal with Shift\n\t\t\t'*': 'Digit8',  # * uses Digit8 with Shift\n\t\t\t'&': 'Digit7',  # & uses Digit7 with Shift\n\t\t\t'%': 'Digit5',  # % uses Digit5 with Shift\n\t\t\t'$': 'Digit4',  # $ uses Digit4 with Shift\n\t\t\t'#': 'Digit3',  # # uses Digit3 with Shift\n\t\t\t'^': 'Digit6',  # ^ uses Digit6 with Shift\n\t\t\t'~': 'Backquote',  # ~ uses Backquote with Shift\n\t\t\t'`': 'Backquote',\n\t\t\t'\"': 'Quote',  # \" uses Quote with Shift\n\t\t\t\"'\": 'Quote',\n\t\t\t'<': 'Comma',  # < uses Comma with Shift\n\t\t\t'>': 'Period',  # > uses Period with Shift\n\t\t\t'|': 'Backslash',  # | uses Backslash with Shift\n\t\t}\n\n\t\tif char in key_codes:\n\t\t\treturn key_codes[char]\n\t\telif char.isalpha():\n\t\t\treturn f'Key{char.upper()}'\n\t\telif char.isdigit():\n\t\t\treturn f'Digit{char}'\n\t\telse:\n\t\t\t# Fallback for unknown characters\n\t\t\treturn f'Key{char.upper()}' if char.isascii() and char.isalpha() else 'Unidentified'\n\n\tasync def _clear_text_field(self, object_id: str, cdp_client, session_id: str) -> bool:\n\t\t\"\"\"Clear text field using multiple strategies, starting with the most reliable.\"\"\"\n\t\ttry:\n\t\t\t# Strategy 1: Direct JavaScript value setting (most reliable for modern web apps)\n\t\t\tlogger.debug('Clearing text field using JavaScript value setting')\n\n\t\t\tawait cdp_client.send.Runtime.callFunctionOn(\n\t\t\t\tparams={\n\t\t\t\t\t'functionDeclaration': \"\"\"\n\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t// Try to select all text first (only works on text-like inputs)\n\t\t\t\t\t\t\t// This handles cases where cursor is in the middle of text\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tthis.select();\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t// Some input types (date, color, number, etc.) don't support select()\n\t\t\t\t\t\t\t\t// That's fine, we'll just clear the value directly\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Set value to empty\n\t\t\t\t\t\t\tthis.value = \"\";\n\t\t\t\t\t\t\t// Dispatch events to notify frameworks like React\n\t\t\t\t\t\t\tthis.dispatchEvent(new Event(\"input\", { bubbles: true }));\n\t\t\t\t\t\t\tthis.dispatchEvent(new Event(\"change\", { bubbles: true }));\n\t\t\t\t\t\t\treturn this.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\"\"\",\n\t\t\t\t\t'objectId': object_id,\n\t\t\t\t\t'returnByValue': True,\n\t\t\t\t},\n\t\t\t\tsession_id=session_id,\n\t\t\t)\n\n\t\t\t# Verify clearing worked by checking the value\n\t\t\tverify_result = await cdp_client.send.Runtime.callFunctionOn(\n\t\t\t\tparams={\n\t\t\t\t\t'functionDeclaration': 'function() { return this.value; }',\n\t\t\t\t\t'objectId': object_id,\n\t\t\t\t\t'returnByValue': True,\n\t\t\t\t},\n\t\t\t\tsession_id=session_id,\n\t\t\t)\n\n\t\t\tcurrent_value = verify_result.get('result', {}).get('value', '')\n\t\t\tif not current_value:\n\t\t\t\tlogger.debug('Text field cleared successfully using JavaScript')\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\tlogger.debug(f'JavaScript clear partially failed, field still contains: \"{current_value}\"')\n\n\t\texcept Exception as e:\n\t\t\tlogger.debug(f'JavaScript clear failed: {e}')\n\n\t\t# Strategy 2: Triple-click + Delete (fallback for stubborn fields)\n\t\ttry:\n\t\t\tlogger.debug('Fallback: Clearing using triple-click + Delete')\n\n\t\t\t# Get element center coordinates for triple-click\n\t\t\tbounds_result = await cdp_client.send.Runtime.callFunctionOn(\n\t\t\t\tparams={\n\t\t\t\t\t'functionDeclaration': 'function() { return this.getBoundingClientRect(); }',\n\t\t\t\t\t'objectId': object_id,\n\t\t\t\t\t'returnByValue': True,\n\t\t\t\t},\n\t\t\t\tsession_id=session_id,\n\t\t\t)\n\n\t\t\tif bounds_result.get('result', {}).get('value'):\n\t\t\t\tbounds = bounds_result['result']['value']  # type: ignore  # type: ignore\n\t\t\t\tcenter_x = bounds['x'] + bounds['width'] / 2\n\t\t\t\tcenter_y = bounds['y'] + bounds['height'] / 2\n\n\t\t\t\t# Triple-click to select all text\n\t\t\t\tawait cdp_client.send.Input.dispatchMouseEvent(\n\t\t\t\t\tparams={\n\t\t\t\t\t\t'type': 'mousePressed',\n\t\t\t\t\t\t'x': center_x,\n\t\t\t\t\t\t'y': center_y,\n\t\t\t\t\t\t'button': 'left',\n\t\t\t\t\t\t'clickCount': 3,\n\t\t\t\t\t},\n\t\t\t\t\tsession_id=session_id,\n\t\t\t\t)\n\t\t\t\tawait cdp_client.send.Input.dispatchMouseEvent(\n\t\t\t\t\tparams={\n\t\t\t\t\t\t'type': 'mouseReleased',\n\t\t\t\t\t\t'x': center_x,\n\t\t\t\t\t\t'y': center_y,\n\t\t\t\t\t\t'button': 'left',\n\t\t\t\t\t\t'clickCount': 3,\n\t\t\t\t\t},\n\t\t\t\t\tsession_id=session_id,\n\t\t\t\t)\n\n\t\t\t\t# Delete selected text\n\t\t\t\tawait cdp_client.send.Input.dispatchKeyEvent(\n\t\t\t\t\tparams={\n\t\t\t\t\t\t'type': 'keyDown',\n\t\t\t\t\t\t'key': 'Delete',\n\t\t\t\t\t\t'code': 'Delete',\n\t\t\t\t\t},\n\t\t\t\t\tsession_id=session_id,\n\t\t\t\t)\n\t\t\t\tawait cdp_client.send.Input.dispatchKeyEvent(\n\t\t\t\t\tparams={\n\t\t\t\t\t\t'type': 'keyUp',\n\t\t\t\t\t\t'key': 'Delete',\n\t\t\t\t\t\t'code': 'Delete',\n\t\t\t\t\t},\n\t\t\t\t\tsession_id=session_id,\n\t\t\t\t)\n\n\t\t\t\tlogger.debug('Text field cleared using triple-click + Delete')\n\t\t\t\treturn True\n\n\t\texcept Exception as e:\n\t\t\tlogger.debug(f'Triple-click clear failed: {e}')\n\n\t\t# If all strategies failed\n\t\tlogger.warning('All text clearing strategies failed')\n\t\treturn False\n\n\tasync def _focus_element_simple(\n\t\tself, backend_node_id: int, object_id: str, cdp_client, session_id: str, input_coordinates=None\n\t) -> bool:\n\t\t\"\"\"Focus element using multiple strategies with robust fallbacks.\"\"\"\n\t\ttry:\n\t\t\t# Strategy 1: CDP focus (most reliable)\n\t\t\tlogger.debug('Focusing element using CDP focus')\n\t\t\tawait cdp_client.send.DOM.focus(params={'backendNodeId': backend_node_id}, session_id=session_id)\n\t\t\tlogger.debug('Element focused successfully using CDP focus')\n\t\t\treturn True\n\t\texcept Exception as e:\n\t\t\tlogger.debug(f'CDP focus failed: {e}, trying JavaScript focus')\n\n\t\ttry:\n\t\t\t# Strategy 2: JavaScript focus (fallback)\n\t\t\tlogger.debug('Focusing element using JavaScript focus')\n\t\t\tawait cdp_client.send.Runtime.callFunctionOn(\n\t\t\t\tparams={\n\t\t\t\t\t'functionDeclaration': 'function() { this.focus(); }',\n\t\t\t\t\t'objectId': object_id,\n\t\t\t\t},\n\t\t\t\tsession_id=session_id,\n\t\t\t)\n\t\t\tlogger.debug('Element focused successfully using JavaScript')\n\t\t\treturn True\n\t\texcept Exception as e:\n\t\t\tlogger.debug(f'JavaScript focus failed: {e}, trying click focus')\n\n\t\ttry:\n\t\t\t# Strategy 3: Click to focus (last resort)\n\t\t\tif input_coordinates:\n\t\t\t\tlogger.debug(f'Focusing element by clicking at coordinates: {input_coordinates}')\n\t\t\t\tcenter_x = input_coordinates['input_x']\n\t\t\t\tcenter_y = input_coordinates['input_y']\n\n\t\t\t\t# Click on the element to focus it\n\t\t\t\tawait cdp_client.send.Input.dispatchMouseEvent(\n\t\t\t\t\tparams={\n\t\t\t\t\t\t'type': 'mousePressed',\n\t\t\t\t\t\t'x': center_x,\n\t\t\t\t\t\t'y': center_y,\n\t\t\t\t\t\t'button': 'left',\n\t\t\t\t\t\t'clickCount': 1,\n\t\t\t\t\t},\n\t\t\t\t\tsession_id=session_id,\n\t\t\t\t)\n\t\t\t\tawait cdp_client.send.Input.dispatchMouseEvent(\n\t\t\t\t\tparams={\n\t\t\t\t\t\t'type': 'mouseReleased',\n\t\t\t\t\t\t'x': center_x,\n\t\t\t\t\t\t'y': center_y,\n\t\t\t\t\t\t'button': 'left',\n\t\t\t\t\t\t'clickCount': 1,\n\t\t\t\t\t},\n\t\t\t\t\tsession_id=session_id,\n\t\t\t\t)\n\t\t\t\tlogger.debug('Element focused using click')\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\tlogger.debug('No coordinates available for click focus')\n\t\texcept Exception as e:\n\t\t\tlogger.warning(f'All focus strategies failed: {e}')\n\t\treturn False\n\n\tasync def get_basic_info(self) -> ElementInfo:\n\t\t\"\"\"Get basic information about the element including coordinates and properties.\"\"\"\n\t\ttry:\n\t\t\t# Get basic node information\n\t\t\tnode_id = await self._get_node_id()\n\t\t\tdescribe_result = await self._client.send.DOM.describeNode({'nodeId': node_id}, session_id=self._session_id)\n\n\t\t\tnode_info = describe_result['node']\n\n\t\t\t# Get bounding box\n\t\t\tbounding_box = await self.get_bounding_box()\n\n\t\t\t# Get attributes as a proper dict\n\t\t\tattributes_list = node_info.get('attributes', [])\n\t\t\tattributes_dict: dict[str, str] = {}\n\t\t\tfor i in range(0, len(attributes_list), 2):\n\t\t\t\tif i + 1 < len(attributes_list):\n\t\t\t\t\tattributes_dict[attributes_list[i]] = attributes_list[i + 1]\n\n\t\t\treturn ElementInfo(\n\t\t\t\tbackendNodeId=self._backend_node_id,\n\t\t\t\tnodeId=node_id,\n\t\t\t\tnodeName=node_info.get('nodeName', ''),\n\t\t\t\tnodeType=node_info.get('nodeType', 0),\n\t\t\t\tnodeValue=node_info.get('nodeValue'),\n\t\t\t\tattributes=attributes_dict,\n\t\t\t\tboundingBox=bounding_box,\n\t\t\t\terror=None,\n\t\t\t)\n\t\texcept Exception as e:\n\t\t\treturn ElementInfo(\n\t\t\t\tbackendNodeId=self._backend_node_id,\n\t\t\t\tnodeId=None,\n\t\t\t\tnodeName='',\n\t\t\t\tnodeType=0,\n\t\t\t\tnodeValue=None,\n\t\t\t\tattributes={},\n\t\t\t\tboundingBox=None,\n\t\t\t\terror=str(e),\n\t\t\t)",
    "source": "github_repo:browser-use/browser-use",
    "file": "browser_use/actor/element.py",
    "license": "MIT",
    "language": "python"
}