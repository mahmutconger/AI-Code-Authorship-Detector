{
    "code": "class Page:\n\t\"\"\"Page operations (tab or iframe).\"\"\"\n\n\tdef __init__(\n\t\tself, browser_session: 'BrowserSession', target_id: str, session_id: str | None = None, llm: 'BaseChatModel | None' = None\n\t):\n\t\tself._browser_session = browser_session\n\t\tself._client = browser_session.cdp_client\n\t\tself._target_id = target_id\n\t\tself._session_id: str | None = session_id\n\t\tself._mouse: 'Mouse | None' = None\n\n\t\tself._llm = llm\n\n\tasync def _ensure_session(self) -> str:\n\t\t\"\"\"Ensure we have a session ID for this target.\"\"\"\n\t\tif not self._session_id:\n\t\t\tparams: 'AttachToTargetParameters' = {'targetId': self._target_id, 'flatten': True}\n\t\t\tresult = await self._client.send.Target.attachToTarget(params)\n\t\t\tself._session_id = result['sessionId']\n\n\t\t\t# Enable necessary domains\n\t\t\timport asyncio\n\n\t\t\tawait asyncio.gather(\n\t\t\t\tself._client.send.Page.enable(session_id=self._session_id),\n\t\t\t\tself._client.send.DOM.enable(session_id=self._session_id),\n\t\t\t\tself._client.send.Runtime.enable(session_id=self._session_id),\n\t\t\t\tself._client.send.Network.enable(session_id=self._session_id),\n\t\t\t)\n\n\t\treturn self._session_id\n\n\t@property\n\tasync def session_id(self) -> str:\n\t\t\"\"\"Get the session ID for this target.\n\n\t\t@dev Pass this to an arbitrary CDP call\n\t\t\"\"\"\n\t\treturn await self._ensure_session()\n\n\t@property\n\tasync def mouse(self) -> 'Mouse':\n\t\t\"\"\"Get the mouse interface for this target.\"\"\"\n\t\tif not self._mouse:\n\t\t\tsession_id = await self._ensure_session()\n\t\t\tfrom .mouse import Mouse\n\n\t\t\tself._mouse = Mouse(self._browser_session, session_id, self._target_id)\n\t\treturn self._mouse\n\n\tasync def reload(self) -> None:\n\t\t\"\"\"Reload the target.\"\"\"\n\t\tsession_id = await self._ensure_session()\n\t\tawait self._client.send.Page.reload(session_id=session_id)\n\n\tasync def get_element(self, backend_node_id: int) -> 'Element':\n\t\t\"\"\"Get an element by its backend node ID.\"\"\"\n\t\tsession_id = await self._ensure_session()\n\n\t\tfrom .element import Element as Element_\n\n\t\treturn Element_(self._browser_session, backend_node_id, session_id)\n\n\tasync def evaluate(self, page_function: str, *args) -> str:\n\t\t\"\"\"Execute JavaScript in the target.\n\n\t\tArgs:\n\t\t\tpage_function: JavaScript code that MUST start with (...args) => format\n\t\t\t*args: Arguments to pass to the function\n\n\t\tReturns:\n\t\t\tString representation of the JavaScript execution result.\n\t\t\tObjects and arrays are JSON-stringified.\n\t\t\"\"\"\n\t\tsession_id = await self._ensure_session()\n\n\t\t# Clean and fix common JavaScript string parsing issues\n\t\tpage_function = self._fix_javascript_string(page_function)\n\n\t\t# Enforce arrow function format\n\t\tif not (page_function.startswith('(') and '=>' in page_function):\n\t\t\traise ValueError(f'JavaScript code must start with (...args) => format. Got: {page_function[:50]}...')\n\n\t\t# Build the expression - call the arrow function with provided args\n\t\tif args:\n\t\t\t# Convert args to JSON representation for safe passing\n\t\t\timport json\n\n\t\t\targ_strs = [json.dumps(arg) for arg in args]\n\t\t\texpression = f'({page_function})({\", \".join(arg_strs)})'\n\t\telse:\n\t\t\texpression = f'({page_function})()'\n\n\t\t# Debug: print the actual expression being evaluated\n\t\tprint(f'DEBUG: Evaluating JavaScript: {repr(expression)}')\n\n\t\tparams: 'EvaluateParameters' = {'expression': expression, 'returnByValue': True, 'awaitPromise': True}\n\t\tresult = await self._client.send.Runtime.evaluate(\n\t\t\tparams,\n\t\t\tsession_id=session_id,\n\t\t)\n\n\t\tif 'exceptionDetails' in result:\n\t\t\traise RuntimeError(f'JavaScript evaluation failed: {result[\"exceptionDetails\"]}')\n\n\t\tvalue = result.get('result', {}).get('value')\n\n\t\t# Always return string representation\n\t\tif value is None:\n\t\t\treturn ''\n\t\telif isinstance(value, str):\n\t\t\treturn value\n\t\telse:\n\t\t\t# Convert objects, numbers, booleans to string\n\t\t\timport json\n\n\t\t\ttry:\n\t\t\t\treturn json.dumps(value) if isinstance(value, (dict, list)) else str(value)\n\t\t\texcept (TypeError, ValueError):\n\t\t\t\treturn str(value)\n\n\tdef _fix_javascript_string(self, js_code: str) -> str:\n\t\t\"\"\"Fix common JavaScript string parsing issues when written as Python string.\"\"\"\n\n\t\t# Just do minimal, safe cleaning\n\t\tjs_code = js_code.strip()\n\n\t\t# Only fix the most common and safe issues:\n\n\t\t# 1. Remove obvious Python string wrapper quotes if they exist\n\t\tif (js_code.startswith('\"') and js_code.endswith('\"')) or (js_code.startswith(\"'\") and js_code.endswith(\"'\")):\n\t\t\t# Check if it's a wrapped string (not part of JS syntax)\n\t\t\tinner = js_code[1:-1]\n\t\t\tif inner.count('\"') + inner.count(\"'\") == 0 or '() =>' in inner:\n\t\t\t\tjs_code = inner\n\n\t\t# 2. Only fix clearly escaped quotes that shouldn't be\n\t\t# But be very conservative - only if we're sure it's a Python string artifact\n\t\tif '\\\\\"' in js_code and js_code.count('\\\\\"') > js_code.count('\"'):\n\t\t\tjs_code = js_code.replace('\\\\\"', '\"')\n\t\tif \"\\\\'\" in js_code and js_code.count(\"\\\\'\") > js_code.count(\"'\"):\n\t\t\tjs_code = js_code.replace(\"\\\\'\", \"'\")\n\n\t\t# 3. Basic whitespace normalization only\n\t\tjs_code = js_code.strip()\n\n\t\t# Final validation - ensure it's not empty\n\t\tif not js_code:\n\t\t\traise ValueError('JavaScript code is empty after cleaning')\n\n\t\treturn js_code\n\n\tasync def screenshot(self, format: str = 'png', quality: int | None = None) -> str:\n\t\t\"\"\"Take a screenshot and return base64 encoded image.\n\n\t\tArgs:\n\t\t    format: Image format ('jpeg', 'png', 'webp')\n\t\t    quality: Quality 0-100 for JPEG format\n\n\t\tReturns:\n\t\t    Base64-encoded image data\n\t\t\"\"\"\n\t\tsession_id = await self._ensure_session()\n\n\t\tparams: 'CaptureScreenshotParameters' = {'format': format}\n\n\t\tif quality is not None and format.lower() == 'jpeg':\n\t\t\tparams['quality'] = quality\n\n\t\tresult = await self._client.send.Page.captureScreenshot(params, session_id=session_id)\n\n\t\treturn result['data']\n\n\tasync def press(self, key: str) -> None:\n\t\t\"\"\"Press a key on the page (sends keyboard input to the focused element or page).\"\"\"\n\t\tsession_id = await self._ensure_session()\n\n\t\t# Handle key combinations like \"Control+A\"\n\t\tif '+' in key:\n\t\t\tparts = key.split('+')\n\t\t\tmodifiers = parts[:-1]\n\t\t\tmain_key = parts[-1]\n\n\t\t\t# Calculate modifier bitmask\n\t\t\tmodifier_value = 0\n\t\t\tmodifier_map = {'Alt': 1, 'Control': 2, 'Meta': 4, 'Shift': 8}\n\t\t\tfor mod in modifiers:\n\t\t\t\tmodifier_value |= modifier_map.get(mod, 0)\n\n\t\t\t# Press modifier keys\n\t\t\tfor mod in modifiers:\n\t\t\t\tcode, vk_code = get_key_info(mod)\n\t\t\t\tparams: 'DispatchKeyEventParameters' = {'type': 'keyDown', 'key': mod, 'code': code}\n\t\t\t\tif vk_code is not None:\n\t\t\t\t\tparams['windowsVirtualKeyCode'] = vk_code\n\t\t\t\tawait self._client.send.Input.dispatchKeyEvent(params, session_id=session_id)\n\n\t\t\t# Press main key with modifiers bitmask\n\t\t\tmain_code, main_vk_code = get_key_info(main_key)\n\t\t\tmain_down_params: 'DispatchKeyEventParameters' = {\n\t\t\t\t'type': 'keyDown',\n\t\t\t\t'key': main_key,\n\t\t\t\t'code': main_code,\n\t\t\t\t'modifiers': modifier_value,\n\t\t\t}\n\t\t\tif main_vk_code is not None:\n\t\t\t\tmain_down_params['windowsVirtualKeyCode'] = main_vk_code\n\t\t\tawait self._client.send.Input.dispatchKeyEvent(main_down_params, session_id=session_id)\n\n\t\t\tmain_up_params: 'DispatchKeyEventParameters' = {\n\t\t\t\t'type': 'keyUp',\n\t\t\t\t'key': main_key,\n\t\t\t\t'code': main_code,\n\t\t\t\t'modifiers': modifier_value,\n\t\t\t}\n\t\t\tif main_vk_code is not None:\n\t\t\t\tmain_up_params['windowsVirtualKeyCode'] = main_vk_code\n\t\t\tawait self._client.send.Input.dispatchKeyEvent(main_up_params, session_id=session_id)\n\n\t\t\t# Release modifier keys\n\t\t\tfor mod in reversed(modifiers):\n\t\t\t\tcode, vk_code = get_key_info(mod)\n\t\t\t\trelease_params: 'DispatchKeyEventParameters' = {'type': 'keyUp', 'key': mod, 'code': code}\n\t\t\t\tif vk_code is not None:\n\t\t\t\t\trelease_params['windowsVirtualKeyCode'] = vk_code\n\t\t\t\tawait self._client.send.Input.dispatchKeyEvent(release_params, session_id=session_id)\n\t\telse:\n\t\t\t# Simple key press\n\t\t\tcode, vk_code = get_key_info(key)\n\t\t\tkey_down_params: 'DispatchKeyEventParameters' = {'type': 'keyDown', 'key': key, 'code': code}\n\t\t\tif vk_code is not None:\n\t\t\t\tkey_down_params['windowsVirtualKeyCode'] = vk_code\n\t\t\tawait self._client.send.Input.dispatchKeyEvent(key_down_params, session_id=session_id)\n\n\t\t\tkey_up_params: 'DispatchKeyEventParameters' = {'type': 'keyUp', 'key': key, 'code': code}\n\t\t\tif vk_code is not None:\n\t\t\t\tkey_up_params['windowsVirtualKeyCode'] = vk_code\n\t\t\tawait self._client.send.Input.dispatchKeyEvent(key_up_params, session_id=session_id)\n\n\tasync def set_viewport_size(self, width: int, height: int) -> None:\n\t\t\"\"\"Set the viewport size.\"\"\"\n\t\tsession_id = await self._ensure_session()\n\n\t\tparams: 'SetDeviceMetricsOverrideParameters' = {\n\t\t\t'width': width,\n\t\t\t'height': height,\n\t\t\t'deviceScaleFactor': 1.0,\n\t\t\t'mobile': False,\n\t\t}\n\t\tawait self._client.send.Emulation.setDeviceMetricsOverride(\n\t\t\tparams,\n\t\t\tsession_id=session_id,\n\t\t)\n\n\t# Target properties (from CDP getTargetInfo)\n\tasync def get_target_info(self) -> 'TargetInfo':\n\t\t\"\"\"Get target information.\"\"\"\n\t\tparams: 'GetTargetInfoParameters' = {'targetId': self._target_id}\n\t\tresult = await self._client.send.Target.getTargetInfo(params)\n\t\treturn result['targetInfo']\n\n\tasync def get_url(self) -> str:\n\t\t\"\"\"Get the current URL.\"\"\"\n\t\tinfo = await self.get_target_info()\n\t\treturn info.get('url', '')\n\n\tasync def get_title(self) -> str:\n\t\t\"\"\"Get the current title.\"\"\"\n\t\tinfo = await self.get_target_info()\n\t\treturn info.get('title', '')\n\n\tasync def goto(self, url: str) -> None:\n\t\t\"\"\"Navigate this target to a URL.\"\"\"\n\t\tsession_id = await self._ensure_session()\n\n\t\tparams: 'NavigateParameters' = {'url': url}\n\t\tawait self._client.send.Page.navigate(params, session_id=session_id)\n\n\tasync def navigate(self, url: str) -> None:\n\t\t\"\"\"Alias for goto.\"\"\"\n\t\tawait self.goto(url)\n\n\tasync def go_back(self) -> None:\n\t\t\"\"\"Navigate back in history.\"\"\"\n\t\tsession_id = await self._ensure_session()\n\n\t\ttry:\n\t\t\t# Get navigation history\n\t\t\thistory = await self._client.send.Page.getNavigationHistory(session_id=session_id)\n\t\t\tcurrent_index = history['currentIndex']\n\t\t\tentries = history['entries']\n\n\t\t\t# Check if we can go back\n\t\t\tif current_index <= 0:\n\t\t\t\traise RuntimeError('Cannot go back - no previous entry in history')\n\n\t\t\t# Navigate to the previous entry\n\t\t\tprevious_entry_id = entries[current_index - 1]['id']\n\t\t\tparams: 'NavigateToHistoryEntryParameters' = {'entryId': previous_entry_id}\n\t\t\tawait self._client.send.Page.navigateToHistoryEntry(params, session_id=session_id)\n\n\t\texcept Exception as e:\n\t\t\traise RuntimeError(f'Failed to navigate back: {e}')\n\n\tasync def go_forward(self) -> None:\n\t\t\"\"\"Navigate forward in history.\"\"\"\n\t\tsession_id = await self._ensure_session()\n\n\t\ttry:\n\t\t\t# Get navigation history\n\t\t\thistory = await self._client.send.Page.getNavigationHistory(session_id=session_id)\n\t\t\tcurrent_index = history['currentIndex']\n\t\t\tentries = history['entries']\n\n\t\t\t# Check if we can go forward\n\t\t\tif current_index >= len(entries) - 1:\n\t\t\t\traise RuntimeError('Cannot go forward - no next entry in history')\n\n\t\t\t# Navigate to the next entry\n\t\t\tnext_entry_id = entries[current_index + 1]['id']\n\t\t\tparams: 'NavigateToHistoryEntryParameters' = {'entryId': next_entry_id}\n\t\t\tawait self._client.send.Page.navigateToHistoryEntry(params, session_id=session_id)\n\n\t\texcept Exception as e:\n\t\t\traise RuntimeError(f'Failed to navigate forward: {e}')\n\n\t# Element finding methods (these would need to be implemented based on DOM queries)\n\tasync def get_elements_by_css_selector(self, selector: str) -> list['Element']:\n\t\t\"\"\"Get elements by CSS selector.\"\"\"\n\t\tsession_id = await self._ensure_session()\n\n\t\t# Get document first\n\t\tdoc_result = await self._client.send.DOM.getDocument(session_id=session_id)\n\t\tdocument_node_id = doc_result['root']['nodeId']\n\n\t\t# Query selector all\n\t\tquery_params: 'QuerySelectorAllParameters' = {'nodeId': document_node_id, 'selector': selector}\n\t\tresult = await self._client.send.DOM.querySelectorAll(query_params, session_id=session_id)\n\n\t\telements = []\n\t\tfrom .element import Element as Element_\n\n\t\t# Convert node IDs to backend node IDs\n\t\tfor node_id in result['nodeIds']:\n\t\t\t# Get backend node ID\n\t\t\tdescribe_params: 'DescribeNodeParameters' = {'nodeId': node_id}\n\t\t\tnode_result = await self._client.send.DOM.describeNode(describe_params, session_id=session_id)\n\t\t\tbackend_node_id = node_result['node']['backendNodeId']\n\t\t\telements.append(Element_(self._browser_session, backend_node_id, session_id))\n\n\t\treturn elements\n\n\t# AI METHODS\n\n\t@property\n\tdef dom_service(self) -> 'DomService':\n\t\t\"\"\"Get the DOM service for this target.\"\"\"\n\t\treturn DomService(self._browser_session)\n\n\tasync def get_element_by_prompt(self, prompt: str, llm: 'BaseChatModel | None' = None) -> 'Element | None':\n\t\t\"\"\"Get an element by a prompt.\"\"\"\n\t\tawait self._ensure_session()\n\t\tllm = llm or self._llm\n\n\t\tif not llm:\n\t\t\traise ValueError('LLM not provided')\n\n\t\tdom_service = self.dom_service\n\n\t\t# Lazy fetch all_frames inside get_dom_tree if needed (for cross-origin iframes)\n\t\tenhanced_dom_tree, _ = await dom_service.get_dom_tree(target_id=self._target_id, all_frames=None)\n\n\t\tsession_id = self._browser_session.id\n\t\tserialized_dom_state, _ = DOMTreeSerializer(\n\t\t\tenhanced_dom_tree, None, paint_order_filtering=True, session_id=session_id\n\t\t).serialize_accessible_elements()\n\n\t\tllm_representation = serialized_dom_state.llm_representation()\n\n\t\tsystem_message = SystemMessage(\n\t\t\tcontent=\"\"\"You are an AI created to find an element on a page by a prompt.\n\n<browser_state>\nInteractive Elements: All interactive elements will be provided in format as [index]<type>text</type> where\n- index: Numeric identifier for interaction\n- type: HTML element type (button, input, etc.)\n- text: Element description\n\nExamples:\n[33]<div>User form</div>\n[35]<button aria-label='Submit form'>Submit</button>\n\nNote that:\n- Only elements with numeric indexes in [] are interactive\n- (stacked) indentation (with \\t) is important and means that the element is a (html) child of the element above (with a lower index)\n- Pure text elements without [] are not interactive.\n</browser_state>\n\nYour task is to find an element index (if any) that matches the prompt (written in <prompt> tag).\n\nIf non of the elements matches the, return None.\n\nBefore you return the element index, reason about the state and elements for a sentence or two.\"\"\"\n\t\t)\n\n\t\tstate_message = UserMessage(\n\t\t\tcontent=f\"\"\"\n\t\t\t<browser_state>\n\t\t\t{llm_representation}\n\t\t\t</browser_state>\n\n\t\t\t<prompt>\n\t\t\t{prompt}\n\t\t\t</prompt>\n\t\t\t\"\"\"\n\t\t)\n\n\t\tclass ElementResponse(BaseModel):\n\t\t\t# thinking: str\n\t\t\telement_highlight_index: int | None\n\n\t\tllm_response = await llm.ainvoke(\n\t\t\t[\n\t\t\t\tsystem_message,\n\t\t\t\tstate_message,\n\t\t\t],\n\t\t\toutput_format=ElementResponse,\n\t\t)\n\n\t\telement_highlight_index = llm_response.completion.element_highlight_index\n\n\t\tif element_highlight_index is None or element_highlight_index not in serialized_dom_state.selector_map:\n\t\t\treturn None\n\n\t\telement = serialized_dom_state.selector_map[element_highlight_index]\n\n\t\tfrom .element import Element as Element_\n\n\t\treturn Element_(self._browser_session, element.backend_node_id, self._session_id)\n\n\tasync def must_get_element_by_prompt(self, prompt: str, llm: 'BaseChatModel | None' = None) -> 'Element':\n\t\t\"\"\"Get an element by a prompt.\n\n\t\t@dev LLM can still return None, this just raises an error if the element is not found.\n\t\t\"\"\"\n\t\telement = await self.get_element_by_prompt(prompt, llm)\n\t\tif element is None:\n\t\t\traise ValueError(f'No element found for prompt: {prompt}')\n\n\t\treturn element\n\n\tasync def extract_content(self, prompt: str, structured_output: type[T], llm: 'BaseChatModel | None' = None) -> T:\n\t\t\"\"\"Extract structured content from the current page using LLM.\n\n\t\tExtracts clean markdown from the page and sends it to LLM for structured data extraction.\n\n\t\tArgs:\n\t\t\tprompt: Description of what content to extract\n\t\t\tstructured_output: Pydantic BaseModel class defining the expected output structure\n\t\t\tllm: Language model to use for extraction\n\n\t\tReturns:\n\t\t\tThe structured BaseModel instance with extracted content\n\t\t\"\"\"\n\t\tllm = llm or self._llm\n\n\t\tif not llm:\n\t\t\traise ValueError('LLM not provided')\n\n\t\t# Extract clean markdown using the same method as in tools/service.py\n\t\ttry:\n\t\t\tcontent, content_stats = await self._extract_clean_markdown()\n\t\texcept Exception as e:\n\t\t\traise RuntimeError(f'Could not extract clean markdown: {type(e).__name__}')\n\n\t\t# System prompt for structured extraction\n\t\tsystem_prompt = \"\"\"\nYou are an expert at extracting structured data from the markdown of a webpage.\n\n<input>\nYou will be given a query and the markdown of a webpage that has been filtered to remove noise and advertising content.\n</input>\n\n<instructions>\n- You are tasked to extract information from the webpage that is relevant to the query.\n- You should ONLY use the information available in the webpage to answer the query. Do not make up information or provide guess from your own knowledge.\n- If the information relevant to the query is not available in the page, your response should mention that.\n- If the query asks for all items, products, etc., make sure to directly list all of them.\n- Return the extracted content in the exact structured format specified.\n</instructions>\n\n<output>\n- Your output should present ALL the information relevant to the query in the specified structured format.\n- Do not answer in conversational format - directly output the relevant information in the structured format.\n</output>\n\"\"\".strip()\n\n\t\t# Build prompt with just query and content\n\t\tprompt_content = f'<query>\\n{prompt}\\n</query>\\n\\n<webpage_content>\\n{content}\\n</webpage_content>'\n\n\t\t# Send to LLM with structured output\n\t\timport asyncio\n\n\t\ttry:\n\t\t\tresponse = await asyncio.wait_for(\n\t\t\t\tllm.ainvoke(\n\t\t\t\t\t[SystemMessage(content=system_prompt), UserMessage(content=prompt_content)], output_format=structured_output\n\t\t\t\t),\n\t\t\t\ttimeout=120.0,\n\t\t\t)\n\n\t\t\t# Return the structured output BaseModel instance\n\t\t\treturn response.completion\n\t\texcept Exception as e:\n\t\t\traise RuntimeError(str(e))\n\n\tasync def _extract_clean_markdown(self, extract_links: bool = False) -> tuple[str, dict]:\n\t\t\"\"\"Extract clean markdown from the current page using enhanced DOM tree.\n\n\t\tUses the shared markdown extractor for consistency with tools/service.py.\n\t\t\"\"\"\n\t\tfrom browser_use.dom.markdown_extractor import extract_clean_markdown\n\n\t\tdom_service = self.dom_service\n\t\treturn await extract_clean_markdown(dom_service=dom_service, target_id=self._target_id, extract_links=extract_links)",
    "source": "github_repo:browser-use/browser-use",
    "file": "browser_use/actor/page.py",
    "license": "MIT",
    "language": "python"
}