{
    "code": "class MCPAgent(ToolCallAgent):\n    \"\"\"Agent for interacting with MCP (Model Context Protocol) servers.\n\n    This agent connects to an MCP server using either SSE or stdio transport\n    and makes the server's tools available through the agent's tool interface.\n    \"\"\"\n\n    name: str = \"mcp_agent\"\n    description: str = \"An agent that connects to an MCP server and uses its tools.\"\n\n    system_prompt: str = SYSTEM_PROMPT\n    next_step_prompt: str = NEXT_STEP_PROMPT\n\n    # Initialize MCP tool collection\n    mcp_clients: MCPClients = Field(default_factory=MCPClients)\n    available_tools: MCPClients = None  # Will be set in initialize()\n\n    max_steps: int = 20\n    connection_type: str = \"stdio\"  # \"stdio\" or \"sse\"\n\n    # Track tool schemas to detect changes\n    tool_schemas: Dict[str, Dict[str, Any]] = Field(default_factory=dict)\n    _refresh_tools_interval: int = 5  # Refresh tools every N steps\n\n    # Special tool names that should trigger termination\n    special_tool_names: List[str] = Field(default_factory=lambda: [\"terminate\"])\n\n    async def initialize(\n        self,\n        connection_type: Optional[str] = None,\n        server_url: Optional[str] = None,\n        command: Optional[str] = None,\n        args: Optional[List[str]] = None,\n    ) -> None:\n        \"\"\"Initialize the MCP connection.\n\n        Args:\n            connection_type: Type of connection to use (\"stdio\" or \"sse\")\n            server_url: URL of the MCP server (for SSE connection)\n            command: Command to run (for stdio connection)\n            args: Arguments for the command (for stdio connection)\n        \"\"\"\n        if connection_type:\n            self.connection_type = connection_type\n\n        # Connect to the MCP server based on connection type\n        if self.connection_type == \"sse\":\n            if not server_url:\n                raise ValueError(\"Server URL is required for SSE connection\")\n            await self.mcp_clients.connect_sse(server_url=server_url)\n        elif self.connection_type == \"stdio\":\n            if not command:\n                raise ValueError(\"Command is required for stdio connection\")\n            await self.mcp_clients.connect_stdio(command=command, args=args or [])\n        else:\n            raise ValueError(f\"Unsupported connection type: {self.connection_type}\")\n\n        # Set available_tools to our MCP instance\n        self.available_tools = self.mcp_clients\n\n        # Store initial tool schemas\n        await self._refresh_tools()\n\n        # Add system message about available tools\n        tool_names = list(self.mcp_clients.tool_map.keys())\n        tools_info = \", \".join(tool_names)\n\n        # Add system prompt and available tools information\n        self.memory.add_message(\n            Message.system_message(\n                f\"{self.system_prompt}\\n\\nAvailable MCP tools: {tools_info}\"\n            )\n        )\n\n    async def _refresh_tools(self) -> Tuple[List[str], List[str]]:\n        \"\"\"Refresh the list of available tools from the MCP server.\n\n        Returns:\n            A tuple of (added_tools, removed_tools)\n        \"\"\"\n        if not self.mcp_clients.sessions:\n            return [], []\n\n        # Get current tool schemas directly from the server\n        response = await self.mcp_clients.list_tools()\n        current_tools = {tool.name: tool.inputSchema for tool in response.tools}\n\n        # Determine added, removed, and changed tools\n        current_names = set(current_tools.keys())\n        previous_names = set(self.tool_schemas.keys())\n\n        added_tools = list(current_names - previous_names)\n        removed_tools = list(previous_names - current_names)\n\n        # Check for schema changes in existing tools\n        changed_tools = []\n        for name in current_names.intersection(previous_names):\n            if current_tools[name] != self.tool_schemas.get(name):\n                changed_tools.append(name)\n\n        # Update stored schemas\n        self.tool_schemas = current_tools\n\n        # Log and notify about changes\n        if added_tools:\n            logger.info(f\"Added MCP tools: {added_tools}\")\n            self.memory.add_message(\n                Message.system_message(f\"New tools available: {', '.join(added_tools)}\")\n            )\n        if removed_tools:\n            logger.info(f\"Removed MCP tools: {removed_tools}\")\n            self.memory.add_message(\n                Message.system_message(\n                    f\"Tools no longer available: {', '.join(removed_tools)}\"\n                )\n            )\n        if changed_tools:\n            logger.info(f\"Changed MCP tools: {changed_tools}\")\n\n        return added_tools, removed_tools\n\n    async def think(self) -> bool:\n        \"\"\"Process current state and decide next action.\"\"\"\n        # Check MCP session and tools availability\n        if not self.mcp_clients.sessions or not self.mcp_clients.tool_map:\n            logger.info(\"MCP service is no longer available, ending interaction\")\n            self.state = AgentState.FINISHED\n            return False\n\n        # Refresh tools periodically\n        if self.current_step % self._refresh_tools_interval == 0:\n            await self._refresh_tools()\n            # All tools removed indicates shutdown\n            if not self.mcp_clients.tool_map:\n                logger.info(\"MCP service has shut down, ending interaction\")\n                self.state = AgentState.FINISHED\n                return False\n\n        # Use the parent class's think method\n        return await super().think()\n\n    async def _handle_special_tool(self, name: str, result: Any, **kwargs) -> None:\n        \"\"\"Handle special tool execution and state changes\"\"\"\n        # First process with parent handler\n        await super()._handle_special_tool(name, result, **kwargs)\n\n        # Handle multimedia responses\n        if isinstance(result, ToolResult) and result.base64_image:\n            self.memory.add_message(\n                Message.system_message(\n                    MULTIMEDIA_RESPONSE_PROMPT.format(tool_name=name)\n                )\n            )\n\n    def _should_finish_execution(self, name: str, **kwargs) -> bool:\n        \"\"\"Determine if tool execution should finish the agent\"\"\"\n        # Terminate if the tool name is 'terminate'\n        return name.lower() == \"terminate\"\n\n    async def cleanup(self) -> None:\n        \"\"\"Clean up MCP connection when done.\"\"\"\n        if self.mcp_clients.sessions:\n            await self.mcp_clients.disconnect()\n            logger.info(\"MCP connection closed\")\n\n    async def run(self, request: Optional[str] = None) -> str:\n        \"\"\"Run the agent with cleanup when done.\"\"\"\n        try:\n            result = await super().run(request)\n            return result\n        finally:\n            # Ensure cleanup happens even if there's an error\n            await self.cleanup()",
    "source": "github_repo:FoundationAgents/OpenManus",
    "file": "app/agent/mcp.py",
    "license": "MIT",
    "language": "python"
}