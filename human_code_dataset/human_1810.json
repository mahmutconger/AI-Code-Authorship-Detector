{
    "code": "class ClaudeAIBot(Bot, OpenAIImage):\n    def __init__(self):\n        super().__init__()\n        self.sessions = SessionManager(ClaudeAiSession, model=conf().get(\"model\") or \"gpt-3.5-turbo\")\n        self.claude_api_cookie = conf().get(\"claude_api_cookie\")\n        self.proxy = conf().get(\"proxy\")\n        self.con_uuid_dic = {}\n        if self.proxy:\n            self.proxies = {\n            \"http\": self.proxy,\n            \"https\": self.proxy\n        }\n        else:\n            self.proxies = None\n        self.error = \"\"\n        self.org_uuid = self.get_organization_id()\n\n    def generate_uuid(self):\n        random_uuid = uuid.uuid4()\n        random_uuid_str = str(random_uuid)\n        formatted_uuid = f\"{random_uuid_str[0:8]}-{random_uuid_str[9:13]}-{random_uuid_str[14:18]}-{random_uuid_str[19:23]}-{random_uuid_str[24:]}\"\n        return formatted_uuid\n        \n    def reply(self, query, context: Context = None) -> Reply:\n        if context.type == ContextType.TEXT:\n            return self._chat(query, context)\n        elif context.type == ContextType.IMAGE_CREATE:\n            ok, res = self.create_img(query, 0)\n            if ok:\n                reply = Reply(ReplyType.IMAGE_URL, res)\n            else:\n                reply = Reply(ReplyType.ERROR, res)\n            return reply\n        else:\n            reply = Reply(ReplyType.ERROR, \"Bot不支持处理{}类型的消息\".format(context.type))\n            return reply\n\n    def get_organization_id(self):\n        url = \"https://claude.ai/api/organizations\"\n        headers = {\n            'User-Agent':\n                'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0',\n            'Accept-Language': 'en-US,en;q=0.5',\n            'Referer': 'https://claude.ai/chats',\n            'Content-Type': 'application/json',\n            'Sec-Fetch-Dest': 'empty',\n            'Sec-Fetch-Mode': 'cors',\n            'Sec-Fetch-Site': 'same-origin',\n            'Connection': 'keep-alive',\n            'Cookie': f'{self.claude_api_cookie}'\n        }\n        try:\n            response = requests.get(url, headers=headers, impersonate=\"chrome110\", proxies =self.proxies, timeout=400)\n            res = json.loads(response.text)\n            uuid = res[0]['uuid']\n        except:\n            if \"App unavailable\" in response.text:\n                logger.error(\"IP error: The IP is not allowed to be used on Claude\")\n                self.error = \"ip所在地区不被claude支持\"\n            elif \"Invalid authorization\" in response.text:\n                logger.error(\"Cookie error: Invalid authorization of claude, check cookie please.\")\n                self.error = \"无法通过claude身份验证，请检查cookie\"\n            return None\n        return uuid\n\n    def conversation_share_check(self,session_id):\n        if conf().get(\"claude_uuid\") is not None and conf().get(\"claude_uuid\") != \"\":\n            con_uuid = conf().get(\"claude_uuid\")\n            return con_uuid\n        if session_id not in self.con_uuid_dic:\n            self.con_uuid_dic[session_id] = self.generate_uuid()\n            self.create_new_chat(self.con_uuid_dic[session_id])\n        return self.con_uuid_dic[session_id]\n\n    def check_cookie(self):\n        flag = self.get_organization_id()\n        return flag\n\n    def create_new_chat(self, con_uuid):\n        \"\"\"\n        新建claude对话实体\n        :param con_uuid: 对话id\n        :return:\n        \"\"\"\n        url = f\"https://claude.ai/api/organizations/{self.org_uuid}/chat_conversations\"\n        payload = json.dumps({\"uuid\": con_uuid, \"name\": \"\"})\n        headers = {\n            'User-Agent':\n                'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0',\n            'Accept-Language': 'en-US,en;q=0.5',\n            'Referer': 'https://claude.ai/chats',\n            'Content-Type': 'application/json',\n            'Origin': 'https://claude.ai',\n            'DNT': '1',\n            'Connection': 'keep-alive',\n            'Cookie': self.claude_api_cookie,\n            'Sec-Fetch-Dest': 'empty',\n            'Sec-Fetch-Mode': 'cors',\n            'Sec-Fetch-Site': 'same-origin',\n            'TE': 'trailers'\n        }\n        response = requests.post(url, headers=headers, data=payload, impersonate=\"chrome110\", proxies=self.proxies, timeout=400)\n        # Returns JSON of the newly created conversation information\n        return response.json()\n        \n    def _chat(self, query, context, retry_count=0) -> Reply:\n        \"\"\"\n        发起对话请求\n        :param query: 请求提示词\n        :param context: 对话上下文\n        :param retry_count: 当前递归重试次数\n        :return: 回复\n        \"\"\"\n        if retry_count >= 2:\n            # exit from retry 2 times\n            logger.warn(\"[CLAUDEAI] failed after maximum number of retry times\")\n            return Reply(ReplyType.ERROR, \"请再问我一次吧\")\n\n        try:\n            session_id = context[\"session_id\"]\n            if self.org_uuid is None:\n                return Reply(ReplyType.ERROR, self.error)\n\n            session = self.sessions.session_query(query, session_id)\n            con_uuid = self.conversation_share_check(session_id)\n\n            model = conf().get(\"model\") or \"gpt-3.5-turbo\"\n            # remove system message\n            if session.messages[0].get(\"role\") == \"system\":\n                if model == \"wenxin\" or model == \"claude\":\n                    session.messages.pop(0)\n            logger.info(f\"[CLAUDEAI] query={query}\")\n\n            # do http request\n            base_url = \"https://claude.ai\"\n            payload = json.dumps({\n                \"completion\": {\n                    \"prompt\": f\"{query}\",\n                    \"timezone\": \"Asia/Kolkata\",\n                    \"model\": \"claude-2\"\n                },\n                \"organization_uuid\": f\"{self.org_uuid}\",\n                \"conversation_uuid\": f\"{con_uuid}\",\n                \"text\": f\"{query}\",\n                \"attachments\": []\n            })\n            headers = {\n                'User-Agent':\n                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0',\n                'Accept': 'text/event-stream, text/event-stream',\n                'Accept-Language': 'en-US,en;q=0.5',\n                'Referer': 'https://claude.ai/chats',\n                'Content-Type': 'application/json',\n                'Origin': 'https://claude.ai',\n                'DNT': '1',\n                'Connection': 'keep-alive',\n                'Cookie': f'{self.claude_api_cookie}',\n                'Sec-Fetch-Dest': 'empty',\n                'Sec-Fetch-Mode': 'cors',\n                'Sec-Fetch-Site': 'same-origin',\n                'TE': 'trailers'\n            }\n\n            res = requests.post(base_url + \"/api/append_message\", headers=headers, data=payload,impersonate=\"chrome110\",proxies= self.proxies,timeout=400)\n            if res.status_code == 200 or \"pemission\" in res.text:\n                # execute success\n                decoded_data = res.content.decode(\"utf-8\")\n                decoded_data = re.sub('\\n+', '\\n', decoded_data).strip()\n                data_strings = decoded_data.split('\\n')\n                completions = []\n                for data_string in data_strings:\n                    json_str = data_string[6:].strip()\n                    data = json.loads(json_str)\n                    if 'completion' in data:\n                        completions.append(data['completion'])\n\n                reply_content = ''.join(completions)\n\n                if \"rate limi\" in reply_content:\n                    logger.error(\"rate limit error: The conversation has reached the system speed limit and is synchronized with Cladue. Please go to the official website to check the lifting time\")\n                    return Reply(ReplyType.ERROR, \"对话达到系统速率限制，与cladue同步，请进入官网查看解除限制时间\")\n                logger.info(f\"[CLAUDE] reply={reply_content}, total_tokens=invisible\")\n                self.sessions.session_reply(reply_content, session_id, 100)\n                return Reply(ReplyType.TEXT, reply_content)\n            else:\n                flag = self.check_cookie()\n                if flag == None:\n                    return Reply(ReplyType.ERROR, self.error)\n\n                response = res.json()\n                error = response.get(\"error\")\n                logger.error(f\"[CLAUDE] chat failed, status_code={res.status_code}, \"\n                             f\"msg={error.get('message')}, type={error.get('type')}, detail: {res.text}, uuid: {con_uuid}\")\n\n                if res.status_code >= 500:\n                    # server error, need retry\n                    time.sleep(2)\n                    logger.warn(f\"[CLAUDE] do retry, times={retry_count}\")\n                    return self._chat(query, context, retry_count + 1)\n                return Reply(ReplyType.ERROR, \"提问太快啦，请休息一下再问我吧\")\n\n        except Exception as e:\n            logger.exception(e)\n            # retry\n            time.sleep(2)\n            logger.warn(f\"[CLAUDE] do retry, times={retry_count}\")\n            return self._chat(query, context, retry_count + 1)",
    "source": "github_repo:zhayujie/chatgpt-on-wechat",
    "file": "bot/claude/claude_ai_bot.py",
    "license": "MIT",
    "language": "python"
}