{
    "code": "class DoclingParseV2DocumentBackend(PdfDocumentBackend):\n    def __init__(self, in_doc: \"InputDocument\", path_or_stream: Union[BytesIO, Path]):\n        super().__init__(in_doc, path_or_stream)\n\n        with pypdfium2_lock:\n            self._pdoc = pdfium.PdfDocument(self.path_or_stream)\n            self.parser = pdf_parser_v2(\"fatal\")\n\n            success = False\n            if isinstance(self.path_or_stream, BytesIO):\n                success = self.parser.load_document_from_bytesio(\n                    self.document_hash, self.path_or_stream\n                )\n            elif isinstance(self.path_or_stream, Path):\n                success = self.parser.load_document(\n                    self.document_hash, str(self.path_or_stream)\n                )\n\n            if not success:\n                raise RuntimeError(\n                    f\"docling-parse v2 could not load document {self.document_hash}.\"\n                )\n\n    def page_count(self) -> int:\n        # return len(self._pdoc)  # To be replaced with docling-parse API\n\n        len_1 = len(self._pdoc)\n        len_2 = self.parser.number_of_pages(self.document_hash)\n\n        if len_1 != len_2:\n            _log.error(f\"Inconsistent number of pages: {len_1}!={len_2}\")\n\n        return len_2\n\n    def load_page(self, page_no: int) -> DoclingParseV2PageBackend:\n        with pypdfium2_lock:\n            return DoclingParseV2PageBackend(\n                self.parser, self.document_hash, page_no, self._pdoc[page_no]\n            )\n\n    def is_valid(self) -> bool:\n        return self.page_count() > 0\n\n    def unload(self):\n        super().unload()\n        self.parser.unload_document(self.document_hash)\n        with pypdfium2_lock:\n            self._pdoc.close()\n            self._pdoc = None",
    "source": "github_repo:docling-project/docling",
    "file": "docling/backend/docling_parse_v2_backend.py",
    "license": "MIT",
    "language": "python"
}