{
    "code": "class _HotkeyController:\n    # ========================= 【接口】 =========================\n\n    # 添加一组快捷键，对应触发事件为title。 press 为0时按下触发，1抬起触发\n    def addHotkey(self, keysName, title, press=0):\n        self._start()\n        if press != 0 and press != 1:\n            return f\"[Error] press只能为0按下或1抬起，不能为 {press} 。\"\n        keySet = _KeyTranslator.names2set(keysName)\n        self._hotkeyMutex.lock()\n        kl = self._hotkeyList[press]\n        for k in kl:  # 检测重复\n            if k[\"keySet\"] == keySet:  # 键集合相同\n                self._hotkeyMutex.unlock()\n                msg = \"[Success] 注册事件相同的重复快捷键。\"\n                if k[\"title\"] != title:  # 事件标题不同\n                    msg = f'[Warning] Registering same hotkey. The existing event for {keysName} is {k[\"title\"]}, new event is {title} .'\n                return msg\n        # 加入列表\n        kl.append({\"keySet\": keySet, \"title\": title})\n        self._hotkeyMutex.unlock()\n        return \"[Success]\"\n\n    # 移除一组快捷键，传入键名或事件之一\n    def delHotkey(self, keysName=\"\", title=\"\", press=0):\n        if press != 0 and press != 1:\n            logger.error(f\"press只能为0按下或1抬起，不能为 {press} 。\")\n            return\n        keySet = _KeyTranslator.names2set(keysName)\n        self._hotkeyMutex.lock()\n        kListOld = self._hotkeyList[press]  # 旧列表\n        kListNew = []  # 新列表\n        for k in kListOld:\n            # 忽略键集合相同或标题相同\n            if (keysName and k[\"keySet\"] == keySet) or (title and title == k[\"title\"]):\n                pass\n            # 其余键写入新列表\n            else:\n                kListNew.append(k)\n        self._hotkeyList[press] = kListNew\n        self._hotkeyMutex.unlock()\n\n    # 开始录制快捷键。过程发送事件为runningTitle，完毕发送事件为finishTitle\n    def readHotkey(\n        self, runningTitle=\"<<readHotkeyRunning>>\", finishTitle=\"<<readHotkeyFinish>>\"\n    ):\n        self._start()\n        if self._status == 1:\n            return (\n                \"[Warning] Recording is running. 当前快捷键录制已在进行，不能同时录制！\"\n            )\n        self._status = 1\n        self._readRunningTitle = runningTitle\n        self._readFinishTitle = finishTitle\n        return \"[Success]\"\n\n    # ========================= 【实现】 =========================\n\n    def __init__(self):\n        self._listener = None  # 监听器\n        # 热键列表，[0]存放按下触发，[1]存放抬起触发\n        # 每个元素为：{\"keySet\":按键集合, \"title\":事件标题}\n        self._hotkeyList = [[], []]\n        self._hotkeyMutex = QMutex()  # 热键列表的锁\n        self._status = 0  # 状态，0正常，1录制中\n        self._pressSet = set()  # 当前已按下的按键集合\n        self._strict = True  # 键集合相等的判定，T为严格，F为宽松\n        self._ttl = 30  # 长按键超时忽略时间，秒\n        self._ttlDict = {}  # 存放当前已按下按键的超时时间\n        self._readRunningTitle = \"\"\n        self._readFinishTitle = \"\"\n        # 注册默认监听的热键\n        self.addHotkey(\"esc\", \"<<esc>>\")\n\n    # 第一次注册热键时，启动监听\n    def _start(self):\n        if not self._listener:\n            self._listener = keyboard.Listener(\n                on_press=self._onPress, on_release=self._onRelease\n            )\n            self._listener.start()\n\n    # 按键按下的回调\n    def _onPress(self, key):\n        keyName = _KeyTranslator.key2name(key)\n        # 禁止重复触发\n        if keyName in self._pressSet:\n            return\n        self._checkTTL()  # 检查超时\n        self._pressSet.add(keyName)  # 加入集合\n        self._ttlDict[keyName] = time() + self._ttl  # 记录超时时间\n        if self._status == 0:  # 正常运行\n            self._checkKeyEvent(0, keyName)  # 检查按下模式的快捷键\n        elif self._status == 1:  # 录制中\n            self._readRunning()\n\n    # 按键抬起的回调\n    def _onRelease(self, key):\n        keyName = _KeyTranslator.key2name(key)\n        if not keyName in self._pressSet:\n            return\n        self._checkTTL()  # 检查超时\n        if self._status == 0:  # 正常运行\n            self._checkKeyEvent(1, keyName)  # 检查抬起模式的快捷键\n        elif self._status == 1:  # 录制结束\n            self._readFinish()\n        if keyName in self._pressSet:\n            self._pressSet.discard(keyName)  # 从集合中删除\n            del self._ttlDict[keyName]  # 删除超时时间\n\n    # 检查并触发按键事件\n    def _checkKeyEvent(self, press, nowKey):\n        # 对比每组按键集合。一致触发，则发送事件\n        if self._strict:  # 严格模式，要求完全一致\n            for k in self._hotkeyList[press]:\n                if k[\"keySet\"] == self._pressSet:\n                    PubSubService.publish(k[\"title\"])\n        else:  # 宽松模式，只要求当前组合中包含指定按键，且当前按下的按键在指定按键中\n            for k in self._hotkeyList[press]:\n                if k[\"keySet\"] <= self._pressSet and nowKey in k[\"keySet\"]:\n                    PubSubService.publish(k[\"title\"])\n\n    # 更新录制\n    def _readRunning(self):\n        names = _KeyTranslator.set2names(self._pressSet)\n        PubSubService.publish(self._readRunningTitle, names)\n\n    # 录制结束\n    def _readFinish(self):\n        self._status = 0\n        if \"esc\" in self._pressSet:  # 含esc，则为退出\n            PubSubService.publish(self._readFinishTitle, \"\")\n        else:\n            names = _KeyTranslator.set2names(self._pressSet)\n            PubSubService.publish(self._readFinishTitle, names)\n\n    # 检查已按键的超时时间。若超时，则删除该键\n    def _checkTTL(self):\n        nowTime = time()\n        for k in self._pressSet.copy():\n            if nowTime >= self._ttlDict[k]:\n                logger.debug(f\"忽略超时按键 {k}\")\n                del self._ttlDict[k]\n                self._pressSet.discard(k)",
    "source": "github_repo:hiroi-sora/Umi-OCR",
    "file": "UmiOCR-data/py_src/event_bus/key_mouse/keyboard.py",
    "license": "MIT",
    "language": "python"
}