{
    "code": "class TestSubMaster:\n\n  def setup_method(self):\n    # ZMQ pub socket takes too long to die\n    # sleep to prevent multiple publishers error between tests\n    zmq_sleep(3)\n\n  def test_init(self):\n    sm = messaging.SubMaster(events)\n    for p in [sm.updated, sm.recv_time, sm.recv_frame, sm.alive,\n              sm.sock, sm.data, sm.logMonoTime, sm.valid]:\n      assert len(cast(Sized, p)) == len(events)\n\n  def test_init_state(self):\n    socks = random_socks()\n    sm = messaging.SubMaster(socks)\n    assert sm.frame == -1\n    assert not any(sm.updated.values())\n    assert not any(sm.seen.values())\n    on_demand = {s: SERVICE_LIST[s].frequency <= 1e-5 for s in sm.services}\n    assert all(sm.alive[s] == sm.valid[s] == sm.freq_ok[s] == on_demand[s] for s in sm.services)\n    assert all(t == 0. for t in sm.recv_time.values())\n    assert all(f == 0 for f in sm.recv_frame.values())\n    assert all(t == 0 for t in sm.logMonoTime.values())\n\n    for p in [sm.updated, sm.recv_time, sm.recv_frame, sm.alive,\n              sm.sock, sm.data, sm.logMonoTime, sm.valid]:\n      assert len(cast(Sized, p)) == len(socks)\n\n  def test_getitem(self):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sm = messaging.SubMaster([sock,])\n    zmq_sleep()\n\n    msg = random_carstate()\n    pub_sock.send(msg.to_bytes())\n    sm.update(1000)\n    assert_carstate(msg.carState, sm[sock])\n\n  # TODO: break this test up to individually test SubMaster.update and SubMaster.update_msgs\n  def test_update(self):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sm = messaging.SubMaster([sock,])\n    zmq_sleep()\n\n    for i in range(10):\n      msg = messaging.new_message(sock)\n      pub_sock.send(msg.to_bytes())\n      sm.update(1000)\n      assert sm.frame == i\n      assert all(sm.updated.values())\n\n  def test_update_timeout(self):\n    sock = random_sock()\n    sm = messaging.SubMaster([sock,])\n    timeout = random.randrange(1000, 3000)\n    start_time = time.monotonic()\n    sm.update(timeout)\n    t = time.monotonic() - start_time\n    assert t >= timeout/1000.\n    assert t < 3\n    assert not any(sm.updated.values())\n\n  def test_avg_frequency_checks(self):\n    for poll in (True, False):\n      sm = messaging.SubMaster([\"modelV2\", \"carParams\", \"carState\", \"cameraOdometry\", \"liveCalibration\"],\n                               poll=(\"modelV2\" if poll else None),\n                               frequency=(20. if not poll else None))\n\n      checks = {\n        \"carState\": (20, 20),\n        \"modelV2\": (20, 20 if poll else 10),\n        \"cameraOdometry\": (20, 10),\n        \"liveCalibration\": (4, 4),\n        \"carParams\": (None, None),\n        \"userBookmark\": (None, None),\n      }\n\n      for service, (max_freq, min_freq) in checks.items():\n        if max_freq is not None:\n          assert sm._check_avg_freq(service)\n          assert sm.freq_tracker[service].max_freq == max_freq*1.2\n          assert sm.freq_tracker[service].min_freq == min_freq*0.8\n        else:\n          assert not sm._check_avg_freq(service)\n\n  def test_alive(self):\n    pass\n\n  def test_ignore_alive(self):\n    pass\n\n  def test_valid(self):\n    pass\n\n  # SubMaster should always conflate\n  def test_conflate(self):\n    sock = \"carState\"\n    pub_sock = messaging.pub_sock(sock)\n    sm = messaging.SubMaster([sock,])\n\n    n = 10\n    for i in range(n+1):\n      msg = messaging.new_message(sock)\n      msg.carState.vEgo = i\n      pub_sock.send(msg.to_bytes())\n      time.sleep(0.01)\n    sm.update(1000)\n    assert sm[sock].vEgo == n",
    "source": "github_repo:commaai/openpilot",
    "file": "cereal/messaging/tests/test_pub_sub_master.py",
    "license": "MIT",
    "language": "python"
}