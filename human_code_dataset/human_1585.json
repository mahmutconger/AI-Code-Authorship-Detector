{
    "code": "class ToolSpecExtractor:\n    def __init__(self) -> None:\n        self.tools_spec: list[dict[str, Any]] = []\n        self.processed_tools: set[str] = set()\n\n    def extract_all_tools(self) -> list[dict[str, Any]]:\n        for name in dir(tools):\n            if name.endswith(\"Tool\") and name not in self.processed_tools:\n                obj = getattr(tools, name, None)\n                if inspect.isclass(obj) and issubclass(obj, BaseTool):\n                    self.extract_tool_info(obj)\n                    self.processed_tools.add(name)\n        return self.tools_spec\n\n    def extract_tool_info(self, tool_class: type[BaseTool]) -> None:\n        try:\n            core_schema = tool_class.__pydantic_core_schema__\n            if not core_schema:\n                return\n\n            schema = self._unwrap_schema(core_schema)\n            fields = schema.get(\"schema\", {}).get(\"fields\", {})\n\n            tool_info = {\n                \"name\": tool_class.__name__,\n                \"humanized_name\": self._extract_field_default(\n                    fields.get(\"name\"), fallback=tool_class.__name__\n                ),\n                \"description\": str(\n                    self._extract_field_default(fields.get(\"description\"))\n                ).strip(),\n                \"run_params_schema\": self._extract_params(fields.get(\"args_schema\")),\n                \"init_params_schema\": self._extract_init_params(tool_class),\n                \"env_vars\": self._extract_env_vars(fields.get(\"env_vars\")),\n                \"package_dependencies\": self._extract_field_default(\n                    fields.get(\"package_dependencies\"), fallback=[]\n                ),\n            }\n\n            self.tools_spec.append(tool_info)\n\n        except Exception:  # noqa: S110\n            pass\n\n    @staticmethod\n    def _unwrap_schema(schema: Mapping[str, Any] | dict[str, Any]) -> dict[str, Any]:\n        result: dict[str, Any] = dict(schema)\n        while (\n            result.get(\"type\") in {\"function-after\", \"default\"} and \"schema\" in result\n        ):\n            result = dict(result[\"schema\"])\n        return result\n\n    @staticmethod\n    def _extract_field_default(\n        field: dict | None, fallback: str | list[Any] = \"\"\n    ) -> str | list[Any] | int:\n        if not field:\n            return fallback\n\n        schema = field.get(\"schema\", {})\n        default = schema.get(\"default\")\n        return default if isinstance(default, (list, str, int)) else fallback\n\n    @staticmethod\n    def _extract_params(args_schema_field: dict | None) -> dict[str, Any]:\n        if not args_schema_field:\n            return {}\n\n        args_schema_class = args_schema_field.get(\"schema\", {}).get(\"default\")\n        if not (\n            inspect.isclass(args_schema_class)\n            and issubclass(args_schema_class, BaseModel)\n        ):\n            return {}\n\n        # Cast to type[BaseModel] after runtime check\n        schema_class = cast(type[BaseModel], args_schema_class)\n        try:\n            return schema_class.model_json_schema(schema_generator=SchemaGenerator)\n        except Exception:\n            return {}\n\n    @staticmethod\n    def _extract_env_vars(env_vars_field: dict | None) -> list[dict[str, Any]]:\n        if not env_vars_field:\n            return []\n\n        return [\n            {\n                \"name\": env_var.name,\n                \"description\": env_var.description,\n                \"required\": env_var.required,\n                \"default\": env_var.default,\n            }\n            for env_var in env_vars_field.get(\"schema\", {}).get(\"default\", [])\n            if isinstance(env_var, EnvVar)\n        ]\n\n    @staticmethod\n    def _extract_init_params(tool_class: type[BaseTool]) -> dict[str, Any]:\n        ignored_init_params = [\n            \"name\",\n            \"description\",\n            \"env_vars\",\n            \"args_schema\",\n            \"description_updated\",\n            \"cache_function\",\n            \"result_as_answer\",\n            \"max_usage_count\",\n            \"current_usage_count\",\n            \"package_dependencies\",\n        ]\n\n        json_schema = tool_class.model_json_schema(\n            schema_generator=SchemaGenerator, mode=\"serialization\"\n        )\n\n        json_schema[\"properties\"] = {\n            key: value\n            for key, value in json_schema[\"properties\"].items()\n            if key not in ignored_init_params\n        }\n        return json_schema\n\n    def save_to_json(self, output_path: str) -> None:\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump({\"tools\": self.tools_spec}, f, indent=2, sort_keys=True)",
    "source": "github_repo:crewAIInc/crewAI",
    "file": "lib/crewai-tools/generate_tool_specs.py",
    "license": "MIT",
    "language": "python"
}