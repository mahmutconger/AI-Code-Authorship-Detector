{
    "code": "class AsciiDocBackend(DeclarativeDocumentBackend):\n    def __init__(self, in_doc: \"InputDocument\", path_or_stream: Union[BytesIO, Path]):\n        super().__init__(in_doc, path_or_stream)\n\n        self.path_or_stream = path_or_stream\n\n        try:\n            if isinstance(self.path_or_stream, BytesIO):\n                text_stream = self.path_or_stream.getvalue().decode(\"utf-8\")\n                self.lines = text_stream.split(\"\\n\")\n            if isinstance(self.path_or_stream, Path):\n                with open(self.path_or_stream, encoding=\"utf-8\") as f:\n                    self.lines = f.readlines()\n            self.valid = True\n\n        except Exception as e:\n            raise RuntimeError(\n                f\"Could not initialize AsciiDoc backend for file with hash {self.document_hash}.\"\n            ) from e\n        return\n\n    def is_valid(self) -> bool:\n        return self.valid\n\n    @classmethod\n    def supports_pagination(cls) -> bool:\n        return False\n\n    def unload(self):\n        return\n\n    @classmethod\n    def supported_formats(cls) -> set[InputFormat]:\n        return {InputFormat.ASCIIDOC}\n\n    def convert(self) -> DoclingDocument:\n        \"\"\"\n        Parses the ASCII into a structured document model.\n        \"\"\"\n\n        origin = DocumentOrigin(\n            filename=self.file.name or \"file\",\n            mimetype=\"text/asciidoc\",\n            binary_hash=self.document_hash,\n        )\n\n        doc = DoclingDocument(name=self.file.stem or \"file\", origin=origin)\n\n        doc = self._parse(doc)\n\n        return doc\n\n    def _parse(self, doc: DoclingDocument):\n        \"\"\"\n        Main function that orchestrates the parsing by yielding components:\n        title, section headers, text, lists, and tables.\n        \"\"\"\n\n        in_list = False\n        in_table = False\n\n        text_data: list[str] = []\n        table_data: list[str] = []\n        caption_data: list[str] = []\n\n        # parents: dict[int, Union[DocItem, GroupItem, None]] = {}\n        parents: dict[int, Union[GroupItem, None]] = {}\n        # indents: dict[int, Union[DocItem, GroupItem, None]] = {}\n        indents: dict[int, Union[GroupItem, None]] = {}\n\n        for i in range(10):\n            parents[i] = None\n            indents[i] = None\n\n        for line in self.lines:\n            # line = line.strip()\n\n            # Title\n            if self._is_title(line):\n                item = self._parse_title(line)\n                level = item[\"level\"]\n\n                parents[level] = doc.add_text(\n                    text=item[\"text\"], label=DocItemLabel.TITLE\n                )\n\n            # Section headers\n            elif self._is_section_header(line):\n                item = self._parse_section_header(line)\n                level = item[\"level\"]\n\n                parents[level] = doc.add_heading(\n                    text=item[\"text\"], level=item[\"level\"], parent=parents[level - 1]\n                )\n                for k, v in parents.items():\n                    if k > level:\n                        parents[k] = None\n\n            # Lists\n            elif self._is_list_item(line):\n                _log.debug(f\"line: {line}\")\n                item = self._parse_list_item(line)\n                _log.debug(f\"parsed list-item: {item}\")\n\n                level = self._get_current_level(parents)\n\n                if not in_list:\n                    in_list = True\n\n                    parents[level + 1] = doc.add_group(\n                        parent=parents[level], name=\"list\", label=GroupLabel.LIST\n                    )\n                    indents[level + 1] = item[\"indent\"]\n\n                elif in_list and item[\"indent\"] > indents[level]:\n                    parents[level + 1] = doc.add_group(\n                        parent=parents[level], name=\"list\", label=GroupLabel.LIST\n                    )\n                    indents[level + 1] = item[\"indent\"]\n\n                elif in_list and item[\"indent\"] < indents[level]:\n                    # print(item[\"indent\"], \" => \", indents[level])\n                    while item[\"indent\"] < indents[level]:\n                        # print(item[\"indent\"], \" => \", indents[level])\n                        parents[level] = None\n                        indents[level] = None\n                        level -= 1\n\n                doc.add_list_item(\n                    item[\"text\"], parent=self._get_current_parent(parents)\n                )\n\n            elif in_list and not self._is_list_item(line):\n                in_list = False\n\n                level = self._get_current_level(parents)\n                parents[level] = None\n\n            # Tables\n            elif line.strip() == \"|===\" and not in_table:  # start of table\n                in_table = True\n\n            elif self._is_table_line(line):  # within a table\n                in_table = True\n                table_data.append(self._parse_table_line(line))\n\n            elif in_table and (\n                (not self._is_table_line(line)) or line.strip() == \"|===\"\n            ):  # end of table\n                caption = None\n                if len(caption_data) > 0:\n                    caption = doc.add_text(\n                        text=\" \".join(caption_data), label=DocItemLabel.CAPTION\n                    )\n\n                caption_data = []\n\n                data = self._populate_table_as_grid(table_data)\n                doc.add_table(\n                    data=data, parent=self._get_current_parent(parents), caption=caption\n                )\n\n                in_table = False\n                table_data = []\n\n            # Picture\n            elif self._is_picture(line):\n                caption = None\n                if len(caption_data) > 0:\n                    caption = doc.add_text(\n                        text=\" \".join(caption_data), label=DocItemLabel.CAPTION\n                    )\n\n                caption_data = []\n\n                item = self._parse_picture(line)\n\n                size: Size\n                if \"width\" in item and \"height\" in item:\n                    size = Size(width=int(item[\"width\"]), height=int(item[\"height\"]))\n                else:\n                    size = Size(width=DEFAULT_IMAGE_WIDTH, height=DEFAULT_IMAGE_HEIGHT)\n\n                uri = None\n                if (\n                    \"uri\" in item\n                    and not item[\"uri\"].startswith(\"http\")\n                    and item[\"uri\"].startswith(\"//\")\n                ):\n                    uri = \"file:\" + item[\"uri\"]\n                elif (\n                    \"uri\" in item\n                    and not item[\"uri\"].startswith(\"http\")\n                    and item[\"uri\"].startswith(\"/\")\n                ):\n                    uri = \"file:/\" + item[\"uri\"]\n                elif \"uri\" in item and not item[\"uri\"].startswith(\"http\"):\n                    uri = \"file://\" + item[\"uri\"]\n\n                image = ImageRef(mimetype=\"image/png\", size=size, dpi=70, uri=uri)\n                doc.add_picture(image=image, caption=caption)\n\n            # Caption\n            elif self._is_caption(line) and len(caption_data) == 0:\n                item = self._parse_caption(line)\n                caption_data.append(item[\"text\"])\n\n            elif (\n                len(line.strip()) > 0 and len(caption_data) > 0\n            ):  # allow multiline captions\n                item = self._parse_text(line)\n                caption_data.append(item[\"text\"])\n\n            # Plain text\n            elif len(line.strip()) == 0 and len(text_data) > 0:\n                doc.add_text(\n                    text=\" \".join(text_data),\n                    label=DocItemLabel.PARAGRAPH,\n                    parent=self._get_current_parent(parents),\n                )\n                text_data = []\n\n            elif len(line.strip()) > 0:  # allow multiline texts\n                item = self._parse_text(line)\n                text_data.append(item[\"text\"])\n\n        if len(text_data) > 0:\n            doc.add_text(\n                text=\" \".join(text_data),\n                label=DocItemLabel.PARAGRAPH,\n                parent=self._get_current_parent(parents),\n            )\n            text_data = []\n\n        if in_table and len(table_data) > 0:\n            data = self._populate_table_as_grid(table_data)\n            doc.add_table(data=data, parent=self._get_current_parent(parents))\n\n            in_table = False\n            table_data = []\n\n        return doc\n\n    @staticmethod\n    def _get_current_level(parents):\n        for k, v in parents.items():\n            if v is None and k > 0:\n                return k - 1\n\n        return 0\n\n    @staticmethod\n    def _get_current_parent(parents):\n        for k, v in parents.items():\n            if v is None and k > 0:\n                return parents[k - 1]\n\n        return None\n\n    #   =========   Title\n    @staticmethod\n    def _is_title(line):\n        return re.match(r\"^= \", line)\n\n    @staticmethod\n    def _parse_title(line):\n        return {\"type\": \"title\", \"text\": line[2:].strip(), \"level\": 0}\n\n    #   =========   Section headers\n    @staticmethod\n    def _is_section_header(line):\n        return re.match(r\"^==+\\s+\", line)\n\n    @staticmethod\n    def _parse_section_header(line):\n        match = re.match(r\"^(=+)\\s+(.*)\", line)\n\n        marker = match.group(1)  # The list marker (e.g., \"*\", \"-\", \"1.\")\n        text = match.group(2)  # The actual text of the list item\n\n        header_level = marker.count(\"=\")  # number of '=' represents level\n        return {\n            \"type\": \"header\",\n            \"level\": header_level - 1,\n            \"text\": text.strip(),\n        }\n\n    #   =========   Lists\n    @staticmethod\n    def _is_list_item(line):\n        return re.match(r\"^(\\s)*(\\*|-|\\d+\\.|\\w+\\.) \", line)\n\n    @staticmethod\n    def _parse_list_item(line):\n        \"\"\"Extract the item marker (number or bullet symbol) and the text of the item.\"\"\"\n\n        match = re.match(r\"^(\\s*)(\\*|-|\\d+\\.)\\s+(.*)\", line)\n        if match:\n            indent = match.group(1)\n            marker = match.group(2)  # The list marker (e.g., \"*\", \"-\", \"1.\")\n            text = match.group(3)  # The actual text of the list item\n\n            if marker == \"*\" or marker == \"-\":\n                return {\n                    \"type\": \"list_item\",\n                    \"marker\": marker,\n                    \"text\": text.strip(),\n                    \"numbered\": False,\n                    \"indent\": 0 if indent is None else len(indent),\n                }\n            else:\n                return {\n                    \"type\": \"list_item\",\n                    \"marker\": marker,\n                    \"text\": text.strip(),\n                    \"numbered\": True,\n                    \"indent\": 0 if indent is None else len(indent),\n                }\n        else:\n            # Fallback if no match\n            return {\n                \"type\": \"list_item\",\n                \"marker\": \"-\",\n                \"text\": line,\n                \"numbered\": False,\n                \"indent\": 0,\n            }\n\n    #   =========   Tables\n    @staticmethod\n    def _is_table_line(line):\n        return re.match(r\"^\\|.*\\|\", line)\n\n    @staticmethod\n    def _parse_table_line(line):\n        # Split table cells and trim extra spaces\n        return [cell.strip() for cell in line.split(\"|\") if cell.strip()]\n\n    @staticmethod\n    def _populate_table_as_grid(table_data):\n        num_rows = len(table_data)\n\n        # Adjust the table data into a grid format\n        num_cols = max(len(row) for row in table_data)\n\n        data = TableData(num_rows=num_rows, num_cols=num_cols, table_cells=[])\n        for row_idx, row in enumerate(table_data):\n            # Pad rows with empty strings to match column count\n            # grid.append(row + [''] * (max_cols - len(row)))\n\n            for col_idx, text in enumerate(row):\n                row_span = 1\n                col_span = 1\n\n                cell = TableCell(\n                    text=text,\n                    row_span=row_span,\n                    col_span=col_span,\n                    start_row_offset_idx=row_idx,\n                    end_row_offset_idx=row_idx + row_span,\n                    start_col_offset_idx=col_idx,\n                    end_col_offset_idx=col_idx + col_span,\n                    column_header=row_idx == 0,\n                    row_header=False,\n                )\n                data.table_cells.append(cell)\n\n        return data\n\n    #   =========   Pictures\n    @staticmethod\n    def _is_picture(line):\n        return re.match(r\"^image::\", line)\n\n    @staticmethod\n    def _parse_picture(line):\n        \"\"\"\n        Parse an image macro, extracting its path and attributes.\n        Syntax: image::path/to/image.png[Alt Text, width=200, height=150, align=center]\n        \"\"\"\n        mtch = re.match(r\"^image::(.+)\\[(.*)\\]$\", line)\n        if mtch:\n            picture_path = mtch.group(1).strip()\n            attributes = mtch.group(2).split(\",\")\n            picture_info = {\"type\": \"picture\", \"uri\": picture_path}\n\n            # Extract optional attributes (alt text, width, height, alignment)\n            if attributes:\n                picture_info[\"alt\"] = attributes[0].strip() if attributes[0] else \"\"\n                for attr in attributes[1:]:\n                    key, value = attr.split(\"=\")\n                    picture_info[key.strip()] = value.strip()\n\n            return picture_info\n\n        return {\"type\": \"picture\", \"uri\": line}\n\n    #   =========   Captions\n    @staticmethod\n    def _is_caption(line):\n        return re.match(r\"^\\.(.+)\", line)\n\n    @staticmethod\n    def _parse_caption(line):\n        mtch = re.match(r\"^\\.(.+)\", line)\n        if mtch:\n            text = mtch.group(1)\n            return {\"type\": \"caption\", \"text\": text}\n\n        return {\"type\": \"caption\", \"text\": \"\"}\n\n    #   =========   Plain text\n    @staticmethod\n    def _parse_text(line):\n        return {\"type\": \"text\", \"text\": line.strip()}",
    "source": "github_repo:docling-project/docling",
    "file": "docling/backend/asciidoc_backend.py",
    "license": "MIT",
    "language": "python"
}