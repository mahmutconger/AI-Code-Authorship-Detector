{
    "code": "def _get_tft_input_indices(self):\n        \"\"\"Returns the relevant indexes and input sizes required by TFT.\"\"\"\n\n        # Functions\n        def _extract_tuples_from_data_type(data_type, defn):\n            return [tup for tup in defn if tup[1] == data_type and tup[2] not in {InputTypes.ID, InputTypes.TIME}]\n\n        def _get_locations(input_types, defn):\n            return [i for i, tup in enumerate(defn) if tup[2] in input_types]\n\n        # Start extraction\n        column_definition = [\n            tup for tup in self.get_column_definition() if tup[2] not in {InputTypes.ID, InputTypes.TIME}\n        ]\n\n        categorical_inputs = _extract_tuples_from_data_type(DataTypes.CATEGORICAL, column_definition)\n        real_inputs = _extract_tuples_from_data_type(DataTypes.REAL_VALUED, column_definition)\n\n        locations = {\n            \"input_size\": len(self._get_input_columns()),\n            \"output_size\": len(_get_locations({InputTypes.TARGET}, column_definition)),\n            \"category_counts\": self.num_classes_per_cat_input,\n            \"input_obs_loc\": _get_locations({InputTypes.TARGET}, column_definition),\n            \"static_input_loc\": _get_locations({InputTypes.STATIC_INPUT}, column_definition),\n            \"known_regular_inputs\": _get_locations({InputTypes.STATIC_INPUT, InputTypes.KNOWN_INPUT}, real_inputs),\n            \"known_categorical_inputs\": _get_locations(\n                {InputTypes.STATIC_INPUT, InputTypes.KNOWN_INPUT}, categorical_inputs\n            ),\n        }\n\n        return locations",
    "source": "github_repo:microsoft/qlib",
    "file": "examples/benchmarks/TFT/data_formatters/base.py",
    "license": "MIT",
    "language": "python"
}