{
    "code": "class SourceFiles:\n    def __init__(self, black_repo_dir: Path):\n        # File path fun all pathlib to be platform agnostic\n        self.black_repo_path = black_repo_dir\n        self.changes_path = self.black_repo_path / \"CHANGES.md\"\n        self.docs_path = self.black_repo_path / \"docs\"\n        self.version_doc_paths = (\n            self.docs_path / \"integrations\" / \"source_version_control.md\",\n            self.docs_path / \"usage_and_configuration\" / \"the_basics.md\",\n        )\n        self.current_version = self.get_current_version()\n        self.next_version = self.get_next_version()\n\n    def __str__(self) -> str:\n        return f\"\"\"\\\n> SourceFiles ENV:\n  Repo path: {self.black_repo_path}\n  CHANGES.md path: {self.changes_path}\n  docs path: {self.docs_path}\n  Current version: {self.current_version}\n  Next version: {self.next_version}\n\"\"\"\n\n    def add_template_to_changes(self) -> int:\n        \"\"\"Add the template to CHANGES.md if it does not exist\"\"\"\n        LOG.info(f\"Adding template to {self.changes_path}\")\n\n        with self.changes_path.open(\"r\", encoding=\"utf-8\") as cfp:\n            changes_string = cfp.read()\n\n        if \"## Unreleased\" in changes_string:\n            LOG.error(f\"{self.changes_path} already has unreleased template\")\n            return 1\n\n        templated_changes_string = changes_string.replace(\n            \"# Change Log\\n\",\n            f\"# Change Log\\n\\n{NEW_VERSION_CHANGELOG_TEMPLATE}\",\n        )\n\n        with self.changes_path.open(\"w\", encoding=\"utf-8\") as cfp:\n            cfp.write(templated_changes_string)\n\n        LOG.info(f\"Added template to {self.changes_path}\")\n        return 0\n\n    def cleanup_changes_template_for_release(self) -> None:\n        LOG.info(f\"Cleaning up {self.changes_path}\")\n\n        with self.changes_path.open(\"r\", encoding=\"utf-8\") as cfp:\n            changes_string = cfp.read()\n\n        # Change Unreleased to next version\n        changes_string = changes_string.replace(\n            \"## Unreleased\", f\"## {self.next_version}\"\n        )\n\n        # Remove all comments\n        changes_string = re.sub(r\"(?m)^<!--(?>(?:.|\\n)*?-->)\\n\\n\", \"\", changes_string)\n\n        # Remove empty subheadings\n        changes_string = re.sub(r\"(?m)^###.+\\n\\n(?=#)\", \"\", changes_string)\n\n        with self.changes_path.open(\"w\", encoding=\"utf-8\") as cfp:\n            cfp.write(changes_string)\n\n        LOG.debug(f\"Finished Cleaning up {self.changes_path}\")\n\n    def get_current_version(self) -> str:\n        \"\"\"Get the latest git (version) tag as latest version\"\"\"\n        return sorted(get_git_tags(), key=lambda k: tuple_calver(k))[-1]\n\n    def get_next_version(self) -> str:\n        \"\"\"Workout the year and month + version number we need to move to\"\"\"\n        base_calver = datetime.today().strftime(\"%y.%m\")\n        calver_parts = base_calver.split(\".\")\n        base_calver = f\"{calver_parts[0]}.{int(calver_parts[1])}\"  # Remove leading 0\n        git_tags = get_git_tags()\n        same_month_releases = [\n            t for t in git_tags if t.startswith(base_calver) and \"a\" not in t\n        ]\n        if len(same_month_releases) < 1:\n            return f\"{base_calver}.0\"\n        same_month_version = same_month_releases[-1].split(\".\", 2)[-1]\n        return f\"{base_calver}.{int(same_month_version) + 1}\"\n\n    def update_repo_for_release(self) -> int:\n        \"\"\"Update CHANGES.md + doc files ready for release\"\"\"\n        self.cleanup_changes_template_for_release()\n        self.update_version_in_docs()\n        return 0  # return 0 if no exceptions hit\n\n    def update_version_in_docs(self) -> None:\n        for doc_path in self.version_doc_paths:\n            LOG.info(f\"Updating black version to {self.next_version} in {doc_path}\")\n\n            with doc_path.open(\"r\", encoding=\"utf-8\") as dfp:\n                doc_string = dfp.read()\n\n            next_version_doc = doc_string.replace(\n                self.current_version, self.next_version\n            )\n\n            with doc_path.open(\"w\", encoding=\"utf-8\") as dfp:\n                dfp.write(next_version_doc)\n\n            LOG.debug(\n                f\"Finished updating black version to {self.next_version} in {doc_path}\"\n            )",
    "source": "github_repo:psf/black",
    "file": "scripts/release.py",
    "license": "MIT",
    "language": "python"
}