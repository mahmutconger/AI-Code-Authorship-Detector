{
    "code": "def generate_parentheses_iterative(length: int) -> list:\n    \"\"\"\n    Generate all valid combinations of parentheses (Iterative Approach).\n\n    The algorithm works as follows:\n    1. Initialize an empty list to store the combinations.\n    2. Initialize a stack to keep track of partial combinations.\n    3. Start with empty string and push it onstack along with the counts of '(' and ')'.\n    4. While the stack is not empty:\n        a. Pop a partial combination and its open and close counts from the stack.\n        b. If the combination length is equal to 2*length, add it to the result.\n        c. If open count < length, push new combination with added '(' on stack.\n        d. If close count < open count, push new combination with added ')' on stack.\n    5. Return the result containing all valid combinations.\n\n    Args:\n        length: The desired length of the parentheses combinations\n\n    Returns:\n        A list of strings representing valid combinations of parentheses\n\n    Time Complexity:\n        O(2^(2*length))\n\n    Space Complexity:\n        O(2^(2*length))\n\n    >>> generate_parentheses_iterative(3)\n    ['()()()', '()(())', '(())()', '(()())', '((()))']\n    >>> generate_parentheses_iterative(2)\n    ['()()', '(())']\n    >>> generate_parentheses_iterative(1)\n    ['()']\n    >>> generate_parentheses_iterative(0)\n    ['']\n    \"\"\"\n    result = []\n    stack = []\n\n    # Each element in stack is a tuple (current_combination, open_count, close_count)\n    stack.append((\"\", 0, 0))\n\n    while stack:\n        current_combination, open_count, close_count = stack.pop()\n\n        if len(current_combination) == 2 * length:\n            result.append(current_combination)\n\n        if open_count < length:\n            stack.append((current_combination + \"(\", open_count + 1, close_count))\n\n        if close_count < open_count:\n            stack.append((current_combination + \")\", open_count, close_count + 1))\n\n    return result",
    "source": "github_repo:TheAlgorithms/Python",
    "file": "backtracking/generate_parentheses_iterative.py",
    "license": "MIT",
    "language": "python"
}