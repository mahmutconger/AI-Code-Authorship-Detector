{
    "code": "class PuzzleState:\n    \"\"\"Represents a state in 8-puzzle solving with A* algorithm.\"\"\"\n\n    def __init__(\n        self,\n        board: List[List[int]],\n        goal: List[List[int]],\n        moves: int = 0,\n        previous: Optional[\"PuzzleState\"] = None,\n    ) -> None:\n        self.board = board  # Current 3x3 board configuration\n        self.goal = goal  # Target 3x3 configuration\n        self.moves = moves  # Number of moves taken to reach here\n        self.previous = previous  # Previous state in solution path\n\n    def __lt__(self, other: \"PuzzleState\") -> bool:\n        \"\"\"For PriorityQueue ordering: compare priorities.\"\"\"\n        return self.priority() < other.priority()\n\n    def priority(self) -> int:\n        \"\"\"A* priority: moves + Manhattan distance.\"\"\"\n        return self.moves + self.manhattan()\n\n    def manhattan(self) -> int:\n        \"\"\"Calculate Manhattan distance using actual goal positions.\"\"\"\n        distance = 0\n        # Create a lookup table for goal tile positions\n        goal_pos = {self.goal[i][j]: (i, j) for i in range(3) for j in range(3)}\n\n        for i in range(3):\n            for j in range(3):\n                value = self.board[i][j]\n                if value != 0:  # skip the empty tile\n                    x, y = goal_pos[value]\n                    distance += abs(x - i) + abs(y - j)\n        return distance\n\n\n    def is_goal(self) -> bool:\n        \"\"\"Check if current state matches goal.\"\"\"\n        return self.board == self.goal\n\n    def neighbors(self) -> List[\"PuzzleState\"]:\n        \"\"\"Generate all valid neighboring states by moving empty tile (0).\"\"\"\n        neighbors = []\n        x, y = next((i, j) for i in range(3) for j in range(3) if self.board[i][j] == 0)\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 3 and 0 <= ny < 3:\n                new_board = [row[:] for row in self.board]\n                new_board[x][y], new_board[nx][ny] = new_board[nx][ny], new_board[x][y]\n                neighbors.append(\n                    PuzzleState(new_board, self.goal, self.moves + 1, self)\n                )\n        return neighbors",
    "source": "github_repo:geekcomputers/Python",
    "file": "8_puzzle.py",
    "license": "MIT",
    "language": "python"
}