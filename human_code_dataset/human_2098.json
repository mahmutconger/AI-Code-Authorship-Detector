{
    "code": "class TextRank(KeywordExtractor):\n\n    def __init__(self):\n        self.tokenizer = self.postokenizer = jieba.posseg.dt\n        self.stop_words = self.STOP_WORDS.copy()\n        self.pos_filt = frozenset(('ns', 'n', 'vn', 'v'))\n        self.span = 5\n\n    def pairfilter(self, wp):\n        return (wp.flag in self.pos_filt and len(wp.word.strip()) >= 2\n                and wp.word.lower() not in self.stop_words)\n\n    def textrank(self, sentence, topK=20, withWeight=False, allowPOS=('ns', 'n', 'vn', 'v'), withFlag=False):\n        \"\"\"\n        Extract keywords from sentence using TextRank algorithm.\n        Parameter:\n            - topK: return how many top keywords. `None` for all possible words.\n            - withWeight: if True, return a list of (word, weight);\n                          if False, return a list of words.\n            - allowPOS: the allowed POS list eg. ['ns', 'n', 'vn', 'v'].\n                        if the POS of w is not in this list, it will be filtered.\n            - withFlag: if True, return a list of pair(word, weight) like posseg.cut\n                        if False, return a list of words\n        \"\"\"\n        self.pos_filt = frozenset(allowPOS)\n        g = UndirectWeightedGraph()\n        cm = defaultdict(int)\n        words = tuple(self.tokenizer.cut(sentence))\n        for i, wp in enumerate(words):\n            if self.pairfilter(wp):\n                for j in xrange(i + 1, i + self.span):\n                    if j >= len(words):\n                        break\n                    if not self.pairfilter(words[j]):\n                        continue\n                    if allowPOS and withFlag:\n                        cm[(wp, words[j])] += 1\n                    else:\n                        cm[(wp.word, words[j].word)] += 1\n\n        for terms, w in cm.items():\n            g.addEdge(terms[0], terms[1], w)\n        nodes_rank = g.rank()\n        if withWeight:\n            tags = sorted(nodes_rank.items(), key=itemgetter(1), reverse=True)\n        else:\n            tags = sorted(nodes_rank, key=nodes_rank.__getitem__, reverse=True)\n\n        if topK:\n            return tags[:topK]\n        else:\n            return tags\n\n    extract_tags = textrank",
    "source": "github_repo:fxsjy/jieba",
    "file": "jieba/analyse/textrank.py",
    "license": "MIT",
    "language": "python"
}