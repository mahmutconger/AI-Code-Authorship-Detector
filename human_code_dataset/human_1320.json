{
    "code": "class DoclingParseV4PageBackend(PdfPageBackend):\n    def __init__(\n        self,\n        *,\n        dp_doc: PdfDocument,\n        page_obj: PdfPage,\n        page_no: int,\n        create_words: bool = True,\n        create_textlines: bool = True,\n        keep_chars: bool = False,\n        keep_lines: bool = False,\n        keep_images: bool = True,\n    ):\n        self._ppage = page_obj\n        self._dp_doc = dp_doc\n        self._page_no = page_no\n\n        self._create_words = create_words\n        self._create_textlines = create_textlines\n\n        self._keep_chars = keep_chars\n        self._keep_lines = keep_lines\n        self._keep_images = keep_images\n\n        self._dpage: Optional[SegmentedPdfPage] = None\n        self._unloaded = False\n        self.valid = (self._ppage is not None) and (self._dp_doc is not None)\n\n    def _ensure_parsed(self) -> None:\n        if self._dpage is not None:\n            return\n\n        seg_page = self._dp_doc.get_page(\n            self._page_no + 1,\n            keep_chars=self._keep_chars,\n            keep_lines=self._keep_lines,\n            keep_bitmaps=self._keep_images,\n            create_words=self._create_words,\n            create_textlines=self._create_textlines,\n            enforce_same_font=True,\n        )\n\n        # In Docling, all TextCell instances are expected with top-left origin.\n        [\n            tc.to_top_left_origin(seg_page.dimension.height)\n            for tc in seg_page.textline_cells\n        ]\n        [tc.to_top_left_origin(seg_page.dimension.height) for tc in seg_page.char_cells]\n        [tc.to_top_left_origin(seg_page.dimension.height) for tc in seg_page.word_cells]\n\n        self._dpage = seg_page\n\n    def is_valid(self) -> bool:\n        return self.valid\n\n    def get_text_in_rect(self, bbox: BoundingBox) -> str:\n        self._ensure_parsed()\n        assert self._dpage is not None\n\n        # Find intersecting cells on the page\n        text_piece = \"\"\n        page_size = self.get_size()\n\n        scale = (\n            1  # FIX - Replace with param in get_text_in_rect across backends (optional)\n        )\n\n        for i, cell in enumerate(self._dpage.textline_cells):\n            cell_bbox = (\n                cell.rect.to_bounding_box()\n                .to_top_left_origin(page_height=page_size.height)\n                .scaled(scale)\n            )\n\n            overlap_frac = cell_bbox.intersection_over_self(bbox)\n\n            if overlap_frac > 0.5:\n                if len(text_piece) > 0:\n                    text_piece += \" \"\n                text_piece += cell.text\n\n        return text_piece\n\n    def get_segmented_page(self) -> Optional[SegmentedPdfPage]:\n        self._ensure_parsed()\n        return self._dpage\n\n    def get_text_cells(self) -> Iterable[TextCell]:\n        self._ensure_parsed()\n        assert self._dpage is not None\n\n        return self._dpage.textline_cells\n\n    def get_bitmap_rects(self, scale: float = 1) -> Iterable[BoundingBox]:\n        self._ensure_parsed()\n        assert self._dpage is not None\n\n        AREA_THRESHOLD = 0  # 32 * 32\n\n        images = self._dpage.bitmap_resources\n\n        for img in images:\n            cropbox = img.rect.to_bounding_box().to_top_left_origin(\n                self.get_size().height\n            )\n\n            if cropbox.area() > AREA_THRESHOLD:\n                cropbox = cropbox.scaled(scale=scale)\n\n                yield cropbox\n\n    def get_page_image(\n        self, scale: float = 1, cropbox: Optional[BoundingBox] = None\n    ) -> Image.Image:\n        page_size = self.get_size()\n\n        if not cropbox:\n            cropbox = BoundingBox(\n                l=0,\n                r=page_size.width,\n                t=0,\n                b=page_size.height,\n                coord_origin=CoordOrigin.TOPLEFT,\n            )\n            padbox = BoundingBox(\n                l=0, r=0, t=0, b=0, coord_origin=CoordOrigin.BOTTOMLEFT\n            )\n        else:\n            padbox = cropbox.to_bottom_left_origin(page_size.height).model_copy()\n            padbox.r = page_size.width - padbox.r\n            padbox.t = page_size.height - padbox.t\n\n        with pypdfium2_lock:\n            image = (\n                self._ppage.render(\n                    scale=scale * 1.5,\n                    rotation=0,  # no additional rotation\n                    crop=padbox.as_tuple(),\n                )\n                .to_pil()\n                .resize(\n                    size=(round(cropbox.width * scale), round(cropbox.height * scale))\n                )\n            )  # We resize the image from 1.5x the given scale to make it sharper.\n\n        return image\n\n    def get_size(self) -> Size:\n        with pypdfium2_lock:\n            return Size(width=self._ppage.get_width(), height=self._ppage.get_height())\n\n        # TODO: Take width and height from docling-parse.\n        # return Size(\n        #    width=self._dpage.dimension.width,\n        #    height=self._dpage.dimension.height,\n        # )\n\n    def unload(self):\n        if not self._unloaded and self._dp_doc is not None:\n            self._dp_doc.unload_pages((self._page_no + 1, self._page_no + 2))\n            self._unloaded = True\n\n        self._ppage = None\n        self._dpage = None\n        self._dp_doc = None",
    "source": "github_repo:docling-project/docling",
    "file": "docling/backend/docling_parse_v4_backend.py",
    "license": "MIT",
    "language": "python"
}