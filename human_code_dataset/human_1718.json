{
    "code": "def _toqclass_helper(im):\n    data = None\n    colortable = None\n    exclusive_fp = False\n\n    # handle filename, if given instead of image name\n    if hasattr(im, \"toUtf8\"):\n        # FIXME - is this really the best way to do this?\n        im = str(im.toUtf8(), \"utf-8\")\n\n    qt_format = QImage\n    if im.mode == \"1\":\n        format = qt_format.Format_Mono\n    elif im.mode == \"L\":\n        format = qt_format.Format_Indexed8\n        colortable = []\n        for i in range(256):\n            colortable.append(rgb(i, i, i))\n    elif im.mode == \"P\":\n        format = qt_format.Format_Indexed8\n        colortable = []\n        palette = im.getpalette()\n        for i in range(0, len(palette), 3):\n            colortable.append(rgb(*palette[i : i + 3]))\n    elif im.mode == \"RGB\":\n        # Populate the 4th channel with 255\n        im = im.convert(\"RGBA\")\n\n        data = im.tobytes(\"raw\", \"BGRA\")\n        format = qt_format.Format_RGB32\n    elif im.mode == \"RGBA\":\n        data = im.tobytes(\"raw\", \"BGRA\")\n        format = qt_format.Format_ARGB32\n    elif im.mode == \"I;16\" and hasattr(qt_format, \"Format_Grayscale16\"):  # Qt 5.13+\n        im = im.point(lambda i: i * 256)\n\n        format = qt_format.Format_Grayscale16\n    else:\n        if exclusive_fp:\n            im.close()\n        msg = f\"unsupported image mode {repr(im.mode)}\"\n        raise ValueError(msg)\n\n    size = im.size\n    __data = data or align8to32(im.tobytes(), size[0], im.mode)\n    if exclusive_fp:\n        im.close()\n    return {\"data\": __data, \"size\": size, \"format\": format, \"colortable\": colortable}",
    "source": "github_repo:hiroi-sora/Umi-OCR",
    "file": "UmiOCR-data/py_src/image_controller/ImageQt.py",
    "license": "MIT",
    "language": "python"
}