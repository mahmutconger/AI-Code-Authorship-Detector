{
    "code": "class Adapter(with_metaclass(AdapterMC, object)):\n    \"\"\"\n    An abstract class, defines methods:\n\n    (cheat sheets retrieval)\n    * get_list\n    * is_found\n    * is_cache_needed\n\n    (repositories management)\n    \" fetch\n    * update\n\n    and several properties that have to be set in each adapter subclass.\n\n    \"\"\"\n\n    _adapter_name = None\n    _output_format = \"code\"\n    _cache_needed = False\n    _repository_url = None\n    _local_repository_location = None\n    _cheatsheet_files_prefix = \"\"\n    _cheatsheet_files_extension = \"\"\n    _pages_list = []\n\n    @classmethod\n    def _class_repr(cls):\n        return \"[Adapter: %s (%s)]\" % (cls._adapter_name, cls.__name__)\n\n    def __init__(self):\n        self._list = {None: self._get_list()}\n\n    @classmethod\n    def name(cls):\n        \"\"\"\n        Return name of the adapter\n        \"\"\"\n        return cls._adapter_name\n\n    @abc.abstractmethod\n    def _get_list(self, prefix=None):\n        return self._pages_list\n\n    def get_list(self, prefix=None):\n        \"\"\"\n        Return available pages for `prefix`\n        \"\"\"\n\n        if prefix in self._list:\n            return self._list[prefix]\n\n        self._list[prefix] = set(self._get_list(prefix=prefix))\n        return self._list[prefix]\n\n    def is_found(self, topic):\n        \"\"\"\n        check if `topic` is available\n        CAUTION: only root is checked\n        \"\"\"\n        return topic in self._list[None]\n\n    def is_cache_needed(self):\n        \"\"\"\n        Return True if answers should be cached.\n        Return False if answers should not be cached.\n        \"\"\"\n        return self._cache_needed\n\n    @staticmethod\n    def _format_page(text):\n        \"\"\"\n        Preformatting page hook.\n        Converts `text` (as in the initial repository)\n        to text (as to be displayed).\n        \"\"\"\n\n        return text\n\n    @abc.abstractmethod\n    def _get_page(self, topic, request_options=None):\n        \"\"\"\n        Return page for `topic`\n        \"\"\"\n        pass\n\n    def _get_output_format(self, topic):\n        if \"/\" in topic:\n            subquery = topic.split(\"/\")[-1]\n        else:\n            subquery = topic\n\n        if subquery in [\":list\"]:\n            return \"text\"\n        return self._output_format\n\n    # pylint: disable=unused-argument\n    @staticmethod\n    def _get_filetype(topic):\n        \"\"\"\n        Return language name (filetype) for `topic`\n        \"\"\"\n        return None\n\n    def get_page_dict(self, topic, request_options=None):\n        \"\"\"\n        Return page dict for `topic`\n        \"\"\"\n\n        #\n        # if _get_page() returns a dict, use the dictionary\n        # for the answer. It is possible to specify some\n        # useful properties as the part of the answer\n        # (e.g. \"cache\")\n        # answer by _get_page() always overrides all default properties\n        #\n        answer = self._get_page(topic, request_options=request_options)\n        if not isinstance(answer, dict):\n            answer = {\"answer\": answer}\n\n        answer_dict = {\n            \"topic\": topic,\n            \"topic_type\": self._adapter_name,\n            \"format\": self._get_output_format(topic),\n            \"cache\": self._cache_needed,\n        }\n        answer_dict.update(answer)\n\n        # pylint: disable=assignment-from-none\n        filetype = self._get_filetype(topic)\n        if filetype:\n            answer_dict[\"filetype\"] = filetype\n        return answer_dict\n\n    @classmethod\n    def local_repository_location(cls, cheat_sheets_location=False):\n        \"\"\"\n        Return local repository location.\n        If name `self._repository_url` for the class is not specified, return None\n        It is possible that several adapters has the same repository_url,\n        in this case they should use the same local directory.\n        If for some reason the local repository location should be overridden\n        (e.g. if several different branches of the same repository are used)\n        if should set in `self._local_repository_location` of the adapter.\n        If `cheat_sheets_location` is specified, return path of the cheat sheets\n        directory instead of the repository directory.\n        \"\"\"\n\n        dirname = None\n\n        if cls._local_repository_location:\n            dirname = cls._local_repository_location\n\n        if not dirname and cls._repository_url:\n            dirname = cls._repository_url\n            if dirname.startswith(\"https://\"):\n                dirname = dirname[8:]\n            elif dirname.startswith(\"http://\"):\n                dirname = dirname[7:]\n\n        # if we did not manage to find out dirname up to this point,\n        # that means that neither repository url, not repository location\n        # is specified for the adapter, so it should be skipped\n        if not dirname:\n            return None\n\n        if dirname.startswith(\"/\"):\n            return dirname\n\n        # it is possible that several repositories will\n        # be mapped to the same location name\n        # (because only the last part of the path is used)\n        # in this case provide the name in _local_repository_location\n        # (detected by fetch.py)\n        if \"/\" in dirname:\n            dirname = dirname.split(\"/\")[-1]\n\n        path = os.path.join(CONFIG[\"path.repositories\"], dirname)\n\n        if cheat_sheets_location:\n            path = os.path.join(path, cls._cheatsheet_files_prefix)\n\n        return path\n\n    @classmethod\n    def repository_url(cls):\n        \"\"\"\n        Return URL of the upstream repository\n        \"\"\"\n        return cls._repository_url\n\n    @classmethod\n    def fetch_command(cls):\n        \"\"\"\n        Initial fetch of the repository.\n        Return cmdline that has to be executed to fetch the repository.\n        Skipping if `self._repository_url` is not specified\n        \"\"\"\n        if not cls._repository_url:\n            return None\n\n        # in this case `fetch` has to be implemented\n        # in the distinct adapter subclass\n        raise RuntimeError(\n            \"Do not known how to handle this repository: %s\" % cls._repository_url\n        )\n\n    @classmethod\n    def update_command(cls):\n        \"\"\"\n        Update of the repository.\n        Return cmdline that has to be executed to update the repository\n        inside `local_repository_location()`.\n        \"\"\"\n\n        if not cls._repository_url:\n            return None\n\n        local_repository_dir = cls.local_repository_location()\n        if not local_repository_dir:\n            return None\n\n        # in this case `update` has to be implemented\n        # in the distinct adapter subclass\n        raise RuntimeError(\n            \"Do not known how to handle this repository: %s\" % cls._repository_url\n        )\n\n    @classmethod\n    def current_state_command(cls):\n        \"\"\"\n        Get current state of repository (current revision).\n        This is used to find what cache entries should be invalidated.\n        \"\"\"\n\n        if not cls._repository_url:\n            return None\n\n        local_repository_dir = cls.local_repository_location()\n        if not local_repository_dir:\n            return None\n\n        # in this case `update` has to be implemented\n        # in the distinct adapter subclass\n        raise RuntimeError(\n            \"Do not known how to handle this repository: %s\" % cls._repository_url\n        )\n\n    @classmethod\n    def save_state(cls, state):\n        \"\"\"\n        Save state `state` of the repository.\n        Must be called after the cache clean up.\n        \"\"\"\n        local_repository_dir = cls.local_repository_location()\n        state_filename = os.path.join(local_repository_dir, \".cached_revision\")\n        open(state_filename, \"w\").write(state)\n\n    @classmethod\n    def get_state(cls):\n        \"\"\"\n        Return the saved `state` of the repository.\n        If state cannot be read, return None\n        \"\"\"\n\n        local_repository_dir = cls.local_repository_location()\n        state_filename = os.path.join(local_repository_dir, \".cached_revision\")\n        state = None\n        if os.path.exists(state_filename):\n            state = open(state_filename, \"r\").read()\n        return state\n\n    @classmethod\n    def get_updates_list_command(cls):\n        \"\"\"\n        Return the command to get the list of updates\n        since the last update whose id is saved as the repository state (`cached_state`).\n        The list is used to invalidate the cache.\n        \"\"\"\n        return None\n\n    @classmethod\n    def get_updates_list(cls, updated_files_list):\n        \"\"\"\n        Return the pages that have to be invalidated if the files `updates_files_list`\n        were updated in the repository.\n        \"\"\"\n        if not cls._cheatsheet_files_prefix:\n            return updated_files_list\n\n        answer = []\n        cut_len = len(cls._cheatsheet_files_prefix)\n        for entry in updated_files_list:\n            if entry.startswith(cls._cheatsheet_files_prefix):\n                answer.append(entry[cut_len:])\n            else:\n                answer.append(entry)\n        return answer",
    "source": "github_repo:chubin/cheat.sh",
    "file": "lib/adapter/adapter.py",
    "license": "MIT",
    "language": "python"
}