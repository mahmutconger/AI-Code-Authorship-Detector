{
    "code": "class CliDirector:\n    def __init__(self):\n        self.record_start = None\n        self.pause_between_keys = 0.2\n        self.instructions: list[InstructionSpec] = []\n\n    def start(self, filename: str, width: int = 0, height: int = 0) -> libtmux.Session:\n        self.start_session(width, height)\n        self.start_recording(filename)\n        return self.tmux_session\n\n    def start_session(self, width: int = 0, height: int = 0) -> libtmux.Session:\n        self.tmux_server = libtmux.Server()\n        self.tmux_session = self.tmux_server.new_session(\n            session_name=\"asciinema_recorder\", kill_session=True\n        )\n        self.tmux_pane = self.tmux_session.attached_window.attached_pane\n        self.tmux_version = self.tmux_pane.display_message(\"#{version}\", True)\n        if width and height:\n            self.resize_window(width, height)\n        self.pause(3)\n        return self.tmux_session\n\n    def start_recording(self, filename: str) -> None:\n        self.asciinema_proc = subprocess.Popen(\n            [\n                \"asciinema\",\n                \"rec\",\n                \"-y\",\n                \"--overwrite\",\n                \"-c\",\n                \"tmux attach -t asciinema_recorder\",\n                filename,\n            ]\n        )\n        self.pause(1.5)\n        self.record_start = time.time()\n\n    def resize_window(self, width: int, height: int) -> None:\n        subprocess.Popen(\n            [\"resize\", \"-s\", str(height), str(width)],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n\n    def end(self) -> None:\n        self.end_recording()\n        self.end_session()\n\n    def end_recording(self) -> None:\n        self.asciinema_proc.terminate()\n        self.asciinema_proc.wait(timeout=5)\n        self.record_start = None\n        self.instructions = []\n\n    def end_session(self) -> None:\n        self.tmux_session.kill_session()\n\n    def press_key(\n        self, keys: str, count=1, pause: float | None = None, target=None\n    ) -> None:\n        if pause is None:\n            pause = self.pause_between_keys\n        if target is None:\n            target = self.tmux_pane\n        for i in range(count):\n            if keys == \" \":\n                keys = \"Space\"\n            target.send_keys(cmd=keys, enter=False, suppress_history=False)\n\n            # inspired by https://github.com/dmotz/TuringType\n            real_pause = random.uniform(0, pause) + 0.4 * pause\n            if keys == \"Space\":\n                real_pause += 1.5 * pause\n            elif keys == \".\":\n                real_pause += pause\n            elif random.random() > 0.75:\n                real_pause += pause\n            elif random.random() > 0.95:\n                real_pause += 2 * pause\n            self.pause(real_pause)\n\n    def type(self, keys: str, pause: float | None = None, target=None) -> None:\n        if pause is None:\n            pause = self.pause_between_keys\n        if target is None:\n            target = self.tmux_pane\n        target.select_pane()\n        for key in keys:\n            self.press_key(key, pause=pause, target=target)\n\n    def exec(self, keys: str, target=None) -> None:\n        if target is None:\n            target = self.tmux_pane\n        self.type(keys, target=target)\n        self.pause(1.25)\n        self.press_key(\"Enter\", target=target)\n        self.pause(0.5)\n\n    def focus_pane(self, pane: libtmux.Pane, set_active_pane: bool = True) -> None:\n        pane.select_pane()\n        if set_active_pane:\n            self.tmux_pane = pane\n\n    def pause(self, seconds: float) -> None:\n        time.sleep(seconds)\n\n    def run_external(self, command: str) -> None:\n        subprocess.run(command, shell=True)\n\n    def message(\n        self,\n        msg: str,\n        duration: int | None = None,\n        add_instruction: bool = True,\n        instruction_html: str = \"\",\n    ) -> None:\n        if duration is None:\n            duration = len(msg) * 0.08  # seconds\n        self.tmux_session.set_option(\n            \"display-time\", int(duration * 1000)\n        )  # milliseconds\n        self.tmux_pane.display_message(\" \" + msg)\n\n        if add_instruction or instruction_html:\n            if not instruction_html:\n                instruction_html = msg\n            self.instruction(instruction=instruction_html, duration=duration)\n        self.pause(duration + 0.5)\n\n    def popup(self, content: str, duration: int = 4) -> None:\n        # todo: check if installed tmux version supports display-popup\n\n        # tmux's display-popup is blocking, so we close it in a separate thread\n        t = threading.Thread(target=self.close_popup, args=[duration])\n        t.start()\n\n        lines = content.splitlines()\n        self.tmux_pane.cmd(\"display-popup\", \"\", *lines)\n        t.join()\n\n    def close_popup(self, duration: float = 0) -> None:\n        self.pause(duration)\n        self.tmux_pane.cmd(\"display-popup\", \"-C\")\n\n    def instruction(\n        self, instruction: str, duration: float = 3, time_from: float | None = None\n    ) -> None:\n        if time_from is None:\n            time_from = self.current_time\n\n        self.instructions.append(\n            InstructionSpec(\n                instruction=str(len(self.instructions) + 1) + \". \" + instruction,\n                time_from=round(time_from, 1),\n                time_to=round(time_from + duration, 1),\n            )\n        )\n\n    def save_instructions(self, output_path: str) -> None:\n        instr_as_dicts = []\n        for instr in self.instructions:\n            instr_as_dicts.append(instr._asdict())\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(instr_as_dicts, f, ensure_ascii=False, indent=4)\n\n    @property\n    def current_time(self) -> float:\n        now = time.time()\n        return round(now - self.record_start, 1)\n\n    @property\n    def current_pane(self) -> libtmux.Pane:\n        return self.tmux_pane",
    "source": "github_repo:mitmproxy/mitmproxy",
    "file": "docs/scripts/clirecording/clidirector.py",
    "license": "MIT",
    "language": "python"
}