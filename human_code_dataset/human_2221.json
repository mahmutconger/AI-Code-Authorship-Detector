{
    "code": "class PackageFilterPolicy:\n    policy: dataclasses.InitVar[str | list[str] | None]\n    packages: list[str] = dataclasses.field(init=False)\n\n    def __post_init__(self, policy: str | list[str] | None) -> None:\n        if not policy:\n            policy = []\n        elif isinstance(policy, str):\n            policy = self.normalize(policy)\n        self.packages = policy\n\n    def allows(self, package_name: str) -> bool:\n        if \":all:\" in self.packages:\n            return False\n\n        return (\n            not self.packages\n            or \":none:\" in self.packages\n            or canonicalize_name(package_name) not in self.packages\n        )\n\n    def has_exact_package(self, package_name: str) -> bool:\n        return canonicalize_name(package_name) in self.packages\n\n    @classmethod\n    def is_reserved(cls, name: str) -> bool:\n        return bool(re.match(r\":(all|none):\", name))\n\n    @classmethod\n    def normalize(cls, policy: str) -> list[str]:\n        if boolean_validator(policy):\n            if boolean_normalizer(policy):\n                return [\":all:\"]\n            else:\n                return [\":none:\"]\n\n        return list(\n            {\n                name.strip() if cls.is_reserved(name) else canonicalize_name(name)\n                for name in policy.strip().split(\",\")\n                if name\n            }\n        )\n\n    @classmethod\n    def validator(cls, policy: str) -> bool:\n        if boolean_validator(policy):\n            return True\n\n        names = policy.strip().split(\",\")\n\n        for name in names:\n            if (\n                not name\n                or (cls.is_reserved(name) and len(names) == 1)\n                or re.match(r\"^[a-zA-Z\\d_-]+$\", name)\n            ):\n                continue\n            return False\n\n        return True",
    "source": "github_repo:python-poetry/poetry",
    "file": "src/poetry/config/config.py",
    "license": "MIT",
    "language": "python"
}