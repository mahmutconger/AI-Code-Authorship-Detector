{
    "code": "import networkx as nx\nimport numpy as np\nfrom collections import deque\n\ndef chinese_postman(G):\n    # Find all the nodes with odd degree\n    odd_degree_nodes = [node for node, degree in dict(G.degree()).items() if degree % 2 != 0]\n\n    # If there are no odd degree nodes, the graph is Eulerian\n    if not odd_degree_nodes:\n        return list(nx.eulerian_circuit(G))\n\n    # Create a complete graph with the odd degree nodes\n    odd_graph = nx.Graph()\n    odd_graph.add_nodes_from(odd_degree_nodes)\n    for i in range(len(odd_degree_nodes)):\n        for j in range(i+1, len(odd_degree_nodes)):\n            path = nx.shortest_path(G, source=odd_degree_nodes[i], target=odd_degree_nodes[j], weight='weight')\n            odd_graph.add_edge(odd_degree_nodes[i], odd_degree_nodes[j], weight=sum(G[u][v]['weight'] for u,v in zip(path[:-1], path[1:])))\n\n    # Find a minimum weight perfect matching in the odd graph\n    matching = nx.max_weight_matching(odd_graph, maxcardinality=True)\n\n    # Construct the Eulerian tour\n    tour = []\n    visited = set()\n    for u, v in matching.items():\n        path = nx.shortest_path(G, source=u, target=v, weight='weight')\n        tour.extend(path[:-1])\n        visited.update(path[:-1])\n    for node in G.nodes:\n        if node not in visited:\n            tour.extend(nx.shortest_path(G, source=tour[-1], target=node, weight='weight'))\n            tour.extend(nx.shortest_path(G, source=node, target=tour[0], weight='weight'))\n\n    return tour",
    "source": "test-data-ai",
    "prompt": "Chinese Postman Problem için temel çözüm yaz.",
    "license": "MIT",
    "language": "python"
}