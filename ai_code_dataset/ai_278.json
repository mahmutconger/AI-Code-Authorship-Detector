{
    "code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef invmod(a, b):\n    b0 = b\n    x0, x1 = 0, 1\n    if b == 1: return 1\n    while a > 1:\n        q = a // b\n        a, b = b, a%b\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0: x1 += b0\n    return x1\n\ndef NTT(a, n, invn):\n    if n == 1:\n        return a % p\n    a0, a1 = [], []\n    for x in a:\n        a0.append(x)\n    for x in a:\n        a1.append(x * 128 % p)\n    y = NTT(a0, n//2, invn)\n    z = NTT(a1, n//2, invn)\n    w = 1\n    for i in range(n//2):\n        t = w * z[i]\n        u = (t[0] + t[1]) * invn % p\n        v = (t[0] - t[1] + p) * invn % p\n        y[i], y[i + n//2] = u, v\n        w = w * 129 % p\n    return y\n\ndef INTT(a, n, invn):\n    if n == 1:\n        return a[0]\n    a0, a1 = [], []\n    for x in a:\n        a0.append(x)\n    for x in a:\n        a1.append(x * invn % p)\n    y = INTT(a0, n//2, invn)\n    z = INTT(a1, n//2, invn)\n    w = pow(129, n, p)\n    wi = pow(w, p-2, p)\n    for i in range(n//2):\n        t = [z[i], z[i + n//2]]\n        u = [(t[0] + t[1]) * wi % p, (t[0] - t[1]) * wi % p]\n        y[i], y[i + n//2] = u[0], u[1]\n        w *= wi\n    return y\n\np = 167772161\ninv64 = invmod(64, p)\ninv128 = invmod(128, p)\n\ndef yaz(a):\n    n = 1\n    while n < len(a):\n        n *= 2\n    invn = invmod(n, p)\n    a = NTT(a, n, invn)\n    for i in range(n):\n        a[i] = (a[i] * a[i]) % p\n    return INTT(a, n, invn)\n\nif __name__ == '__main__':\n    a = [1, 1, 1, 1, 0, 0, 0, 0]\n    print(yaz(a))",
    "source": "test-data-ai",
    "prompt": "Number theoretic transform yaz.",
    "license": "MIT",
    "language": "python"
}