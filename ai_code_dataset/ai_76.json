{
    "code": "class Edge:\n    def __init__(self, u, v, capacity):\n        self.u = u\n        self.v = v\n        self.capacity = capacity\n        self.flow = 0\n\ndef bfs(graph, source, sink, parent):\n    visited = [False] * (len(graph) + 1)\n    queue = [source]\n    visited[source] = True\n    while queue:\n        u = queue.pop(0)\n        for edge in graph[u]:\n            v = edge.v\n            if not visited[v] and edge.capacity - edge.flow > 0:\n                queue.append(v)\n                visited[v] = True\n                parent[v] = u\n                if v == sink:\n                    return True\n    return False\n\ndef dinic(graph, source, sink):\n    parent = [-1] * (len(graph) + 1)\n    max_flow = 0\n    while bfs(graph, source, sink, parent):\n        path_flow = float(\"inf\")\n        s = sink\n        while s != source:\n            for edge in graph[parent[s]]:\n                if edge.v == s:\n                    path_flow = min(path_flow, edge.capacity - edge.flow)\n                    break\n            s = parent[s]\n        s = sink\n        while s != source:\n            for edge in graph[parent[s]]:\n                if edge.v == s:\n                    edge.flow += path_flow\n                    for rev_edge in graph[s]:\n                        if rev_edge.v == parent[s]:\n                            rev_edge.flow -= path_flow\n                            break\n                    break\n            s = parent[s]\n        max_flow += path_flow\n    return max_flow",
    "source": "test-data-ai",
    "prompt": "Dinic's algoritmasını max flow için yaz.",
    "license": "MIT",
    "language": "python"
}