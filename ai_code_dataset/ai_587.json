{
    "code": "import socket\nimport threading\nimport queue\nimport time\nimport requests\nimport urllib3\n\nclass ConnectionPool:\n    def __init__(self, max_connections=10, timeout=60, max_retries=3):\n        self.max_connections = max_connections\n        self.timeout = timeout\n        self.max_retries = max_retries\n        self.lock = threading.Lock()\n        self.threads = []\n        self.connections = []\n        self.requests = queue.Queue()\n\n    def get_connection(self):\n        with self.lock:\n            if len(self.connections) > 0:\n                connection = self.connections.pop()\n                connection.active = True\n                return connection\n            else:\n                while len(self.connections) < self.max_connections:\n                    connection = Connection(self.host, self.port, self.timeout)\n                    connection.start()\n                    self.connections.append(connection)\n                return None\n\n    def return_connection(self, connection):\n        with self.lock:\n            connection.active = False\n            self.connections.append(connection)\n\n    class Connection:\n        def __init__(self, host, port, timeout):\n            self.host = host\n            self.port = port\n            self.timeout = timeout\n            self.active = False\n            self.request = None\n            self.response = None\n\n        def start(self):\n            self.thread = threading.Thread(target=self.run)\n            self.thread.start()\n\n        def run(self):\n            while True:\n                with self.lock:\n                    if not self.active:\n                        break\n                    if self.request is None:\n                        self.request = self.requests.get()\n                        self.response = self.request.send()\n                time.sleep(0)\n\n        def send(self):\n            with self.lock:\n                if self.request is None:\n                    return None\n                try:\n                    response = requests.get('http://' + self.host + ':' + str(self.port) + self.request.url, timeout=self.timeout)\n                    response.connection = self\n                    return response\n                except requests.exceptions.RequestException as e:\n                    print(f'Error: {e}')\n                    return None\n\n    def close(self):\n        with self.lock:\n            for connection in self.connections:\n                connection.active = False\n            for connection in self.connections:\n                connection.thread.join()\n            self.connections = []\n\n    def get(self, url, retries=0):\n        connection = self.get_connection()\n        if connection is None:\n            return None\n        self.requests.put(url)\n        response = connection.response\n        if response is None:\n            if retries < self.max_retries:\n                return self.get(url, retries + 1)\n            return None\n        self.return_connection(connection)\n        return response",
    "source": "test-data-ai",
    "prompt": "API client class with connection pooling yaz.",
    "license": "MIT",
    "language": "python"
}